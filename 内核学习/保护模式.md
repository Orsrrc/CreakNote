# 保护模式

## 实模式

在16位系统的时期，程序在内存上面运行直接得到的就是真实，对于内存上面线性的地址的增加，没有什么有效的防护手段避免由程序跳转到内核区域

会使得creaker可以任意的修改内核中的内容

![image-20250623104024367](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623104024367.png)

> 最终去的地址  线性地址  其中cs ss ds es fs gs 是用于地址跳转用的段寄存器，
>
> 反汇编工具上面的地址是虚拟地址
>
> 段地址 * 0x10  + 虚拟地址 = 线性地址
>
> 对于线性地址，即在一块内存区中，程序的入口地址是线性增加的。

后面开发出 x86 386  最终实现了保护模式

段页保护模式（保护目标）

在逻辑上可以设置成只有段模式没有页模式，但是页模式不能单独存在，即不存在只有页模式没有段模式这种模式。

- 资源限制（段）

  - 硬件资源 如寄存器 例如权限访问

- 内存隔离（页）

  ![image-20250623110226195](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623110226195.png)

对于内核态地址，大部分是共享的地址，即从A程序访问0x8FFFFFFF 与B程序访问0x8FFFFFFF得到的数据是一样的。可以简单理解为系统调用。

系统对权限的分层

![image-20250623112845743](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623112845743.png)

从外往里分别是Running3 Running2 Running1 Running0  权限的大小从R0 （内核态）到最外部的用户态R3

Windows和大部分Linux的系统仅有内核态（R0）和用户态(R3) 两层。



寄存器 ss cs ds es fs gs

- ds 数据段寄存器  malloc 和new 在堆申请的空间 均用该寄存器进行索引
  - mov eax, dword ptr ds:[eax]
- es额外段寄存器 mosb es:[edi]
- ss 堆栈段寄存器  mov eax, dword ptr ss:[ebp] [esp]
- cs代码段寄存器 jmp call dword ptr cs[eax]
- fs 环境段寄存器 当前执行线程的环境块teb
- gs 32 位系统未涉及， 64位环境段寄存器

## 段探测

1.段寄存器修改

​	测试在三环（R3）环境下是否能够修改段寄存器

在Windows7 32bit下 用vs2008 编写一个简单的程序 并放入汇编程序查看

![image-20250623114747848](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623114747848.png)

![image-20250623145638015](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145638015.png)

![image-20250623115502365](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115502365.png)

改为cs寄存器，并且在入口处打上断点

![image-20250623115528935](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115528935.png)

打开寄存器窗口

![image-20250623115617225](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115617225.png)![image-20250624120427596](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624120427596.png)

记得右键选择cpu段

打开编译器的调试寄存器窗口 并打上断点

![image-20250623120428031](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120428031.png)

![image-20250623120516639](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120516639.png)

发现成功修改段寄存器的值

**这里未把ds的值修改回去，那么后续的指令的地址可能会出错。**



### **段寄存器中值的含义**

那么原本的ds段寄存器中的值有什么含义呢？

- 段选择符

查开发指南可以知道，intel的cpu 的低三位 为标志位 第三位T I 代表table index 位为 表的一个索引，

这里intel处理器下， 0 表示全局段描述表 1表示本地段描述表



**DS == 0x0023 写作二进制 0000 0000 0010 0011  表示RPL位 为 11~（b）~ TI 位 为 0 表示索引表位全局段描述表**

intel下有一个寄存器 GDT 存储了全局段描述表和GDT表长

LDT存储了本地段描述表，但本地端描述表的标头，存储在GDT中

![image-20250623120647383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120647383.png)

- windbg的使用 `r` 表示读取寄存器值

  

![image-20250623134759752](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623134759752.png)

在windbg并不区分大小写

![image-20250624121213654](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624121213654.png)

可以通过该指令修改寄存器的值

![image-20250623134858531](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623134858531.png)

这里windbg的低版本不支持直接输入寄存器  要在寄存器名字前面加上`@`符号 表示该标识为寄存器

![image-20250623135025880](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623135025880.png)

在高版本下，实现的效果是一致的

![image-20250623135256288](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623135256288.png)



![image-20250623140325154](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623140325154.png)

这里读取gdt表可以知道  其首地址为0x80b99000

根据段选择符的划分可知 index == 4

![image-20250623141632913](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623141632913.png)

> windge 下查看段描述表  
>
> db一个字节一个字节的查看
>
> dw 两个字节的查看
>
> dd (d double word)   四个字节的查看
>
> dq  八个字节查看 
>
> d 字节数  s 竖着查看

- dqs
  ![image-20250623143456242](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623143456242.png)

**由于是32bit电脑  每一个段描述符占8btye**

**段选择符中的段选择索引指向一个段描述符**

![image-20250623142442647](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623142442647.png)

快速查看

> ​	段选择符的后三位是标记位，这里用其与0xFFF8做与运算   结果为0x20 表明是32bit的前八个字节
>
> 再简化一些就是 地址的低四位大于8那么就是后八个字节 小于8 就是前八个字节

最终得到一个段描述符 `0x00cff300 0000ffff`

#### 段描述符的划分

##### base

在32bit系统里面  线性地址算法变为 段描述符.base + 虚拟地址  = 线性地址

![image-20250623145315871](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145315871.png)

此时的虚拟地址为程序的入口地址

![image-20250623145747070](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145747070.png)

对于base的地址等于零  称作平躺模式

##### limit 限长

- 即从base开始 可以访问到的内存的最大位置

继续划分得到LIMIT == 0xFFFFF

![image-20250623151321455](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623151321455.png)

这里限长为 0xFFFFF

即地址的最大访问为 0~ 0xFFFFF 

> Question： 为什么地址的访问大多都大于这个值

G位 为1  

G位表示限长的单位  1 表示页  0 表示字节

32 bit电脑 一页有4096B 转换为16进制为0x1000

那么地址最大值为限长* 单位 

即0xFFFFF * 0x1000 即左移12位  等于 0xFFFFF000

注意这里要求是限长 * 单位

即总的限长大小  而不是限长地址的最大值 

那么总得限长为0x100000B 

再乘以单位为 0x100000B * 0x1000 = 0x100000000

得到总的限长  由于地址从0开始  最终限长的地址的最大值为 0x100000000 - 1 = 0xFFFFFFFF

**测试限长**

对于fs寄存器  其值为0x003B  对于的段描述符为`0x0040F300 00000FFF`

得到其base为0x00000000

G位为0 单位为byte

其限长为0x00FFF 这个限长比较小 方便测试  

![image-20250623161913221](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623161913221.png)

读取fs保存的地址的数据

![image-20250623162441447](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162441447.png)

![image-20250623162456097](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162456097.png)

![image-20250623162907041](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162907041.png)

![image-20250623163524740](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623163524740.png)

##### 验证线性地址

![image-20250623164045673](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623164045673.png)

![image-20250623171756349](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623171756349.png)

![image-20250623172351656](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172351656.png)



> tips:注意 x不一定存放在eax寄存器中，这里可以直接赋值给x，其目的是查看修改base后访问x1的地址是否会得到x1.

![image-20250624131356003](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131356003.png)

![image-20250624131420280](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131420280.png)

![image-20250623172334128](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172334128.png)

![image-20250623172529161](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172529161.png)

![image-20250623172745029](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172745029.png)

##### P位

P位 为 Segment present 是否有效

- 1 有效 能够正常价值
- 0 无效 无法正常加载

验证

![image-20250623170345093](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623170345093.png)

此时相同的程序 debug报错

![image-20250623172849083](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172849083.png)



![image-20250623165459414](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623165459414.png)

现在再来看这个图  就会发现得到段描述表以后  段寄存器中的值为表示该段描述表中的各个字段所归属的段寄存器的值。

**段寄存器中的值叫做段选择子**