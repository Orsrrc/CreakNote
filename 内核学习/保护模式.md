# 保护模式

## 实模式

在16位系统的时期，程序在内存上面运行直接得到的就是真实，对于内存上面线性的地址的增加，没有什么有效的防护手段避免由程序跳转到内核区域

会使得creaker可以任意的修改内核中的内容

![image-20250623104024367](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623104024367.png)

> 最终去的地址  线性地址  其中cs ss ds es fs gs 是用于地址跳转用的段寄存器，
>
> 反汇编工具上面的地址是虚拟地址
>
> 段地址 * 0x10  + 虚拟地址 = 线性地址
>
> 对于线性地址，即在一块内存区中，程序的入口地址是线性增加的。

后面开发出 x86 386  最终实现了保护模式

段页保护模式（保护目标）

在逻辑上可以设置成只有段模式没有页模式，但是页模式不能单独存在，即不存在只有页模式没有段模式这种模式。

- 资源限制（段）

  - 硬件资源 如寄存器 例如权限访问

- 内存隔离（页）

  ![image-20250623110226195](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623110226195.png)

对于内核态地址，大部分是共享的地址，即从A程序访问0x8FFFFFFF 与B程序访问0x8FFFFFFF得到的数据是一样的。可以简单理解为系统调用。

系统对权限的分层

![image-20250623112845743](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623112845743.png)

从外往里分别是Running3 Running2 Running1 Running0  权限的大小从R0 （内核态）到最外部的用户态R3

Windows和大部分Linux的系统仅有内核态（R0）和用户态(R3) 两层。



- 

## 段探测

### 段寄存器 

ss cs ds es fs gs

- ds 数据段寄存器  malloc 和new 在堆申请的空间 均用该寄存器进行索引
  - `mov eax, dword ptr ds:[eax]`
- es额外段寄存器 `mosb es:[edi]`
- ss 堆栈段寄存器  `mov eax, dword ptr ss:[ebp] [esp]`
- cs代码段寄存器 `jmp call dword ptr cs[eax]`
- fs 环境段寄存器 当前执行线程的环境块teb
- gs 32 位系统未涉及， 64位环境段寄存器

### 段寄存器修改

​	测试在三环（R3）环境下是否能够修改段寄存器

在Windows7 32bit下 用vs2008 编写一个简单的程序 并放入汇编程序查看

![image-20250623114747848](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623114747848.png)

![image-20250623145638015](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145638015.png)

![image-20250623115502365](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115502365.png)

改为cs寄存器，并且在入口处打上断点

![image-20250623115528935](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115528935.png)

打开寄存器窗口

![image-20250623115617225](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115617225.png)![image-20250624120427596](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624120427596.png)

记得右键选择cpu段

打开编译器的调试寄存器窗口 并打上断点

![image-20250623120428031](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120428031.png)

![image-20250623120516639](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120516639.png)

发现成功修改段寄存器的值

**这里未把ds的值修改回去，那么后续的指令的地址可能会出错。**

#### 跨段跳转

##### 裸函数

首先，先看一个函数如果里面没有任何语句时，它的汇编代码：

编写一个普通的函数查看它的反汇编代码

![image-20250625131128262](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131128262.png)



![image-20250625131315383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131315383.png)

按F11进入后得到一个**增量链接**，这个增量链接就是在调试的时候，由编辑器增添的符号。**如果采用release模式，并关闭程序的运行和代码优化，就不会产生增量链接**，从反汇编按F11会直接进入到函数的汇编代码中。

![image-20250625131425564](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131425564.png)

- 关闭增量链接

![image-20250625133245330](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625133245330.png)



进入到实际的汇编代码里面，注意，这个函数原本是空的，里面什么都没有写，但汇编代码任然存在，这就不是一个裸函数。

![image-20250625131441935](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131441935.png)

裸函数，其实际含义是编写什么就翻译为对应的汇编代码，而编译器不会添加额外的汇编语句

裸函数关键字写法 （注意：64bit中没有裸函数）

![image-20250625133708693](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625133708693.png)

>`__declspec(attribute) ` 是 Microsoft Visual C++（MSVC）特有的扩展关键字，用于指定存储类属性（storage-class attributes），控制变量、函数或类的编译和链接行为。它通常用于 Windows 平台开发，尤其是在 DLL 导出/导入、内存对齐、线程局部存储等场景。
>
>其中 `attribute` 是具体的属性修饰符，例如：
>
>- `dllimport` / `dllexport`（DLL 导入/导出）
>- `naked`（无额外编译器生成的函数序言/尾声）
>- `align`（内存对齐）
>- `thread`（线程局部存储）
>- `property`（COM 属性支持）
>- `deprecated`（标记为弃用）
>- `noalias` / `restrict`（优化内存访问）

转到其汇编查看，会看到不会再生成别的汇编代码

![image-20250625134709724](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625134709724.png)

编写一个return查看

![image-20250625134910768](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625134910768.png)

![image-20250625134922578](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625134922578.png)

添加局部变量 发现失败，因为没有开辟堆栈，无法将一块内存分配给局部变量

![image-20250625135019958](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625135019958.png)

##### 跨段不提权

- 在汇编语句中实现跳转的写法：

###### JMP

> `JMP FAR 0060:地址` 是一条 **远跳转（Far Jump）** 指令，用于跨段跳转（即同时修改 `CS` 和 `IP/EIP`）。它的作用是从当前代码段跳转到另一个代码段（段选择子 `0060`）的指定偏移地址处执行。
>
> ------
>
> ### **指令格式**
>
> ```assembly
> JMP FAR 0060:地址   ; 16位模式下：CS=0060, IP=地址
> JMP FAR 0060:地址   ; 32位模式下：CS=0060, EIP=地址
> ```
>
> - **`0060`** 是目标段选择子（Segment Selector），会加载到 `CS` 寄存器。
> - **`地址`** 是目标偏移地址（Offset），会加载到 `IP`（16位）或 `EIP`（32位）。
>
> ------
>
> ### **具体行为**
>
> 1. **16位实模式（Real Mode）**
>    - `CS`（代码段寄存器）被设置为 `0060`。
>    - `IP`（指令指针）被设置为指定的偏移地址。
>    - 实际跳转的物理地址 = `(CS << 4) + IP`（即 `0060 * 16 + 地址`）。
> 2. **32位保护模式（Protected Mode）**
>    - `0060` 是一个段选择子，CPU 会检查 GDT（全局描述符表）或 LDT（局部描述符表）中的段描述符，获取目标段的基址和权限。
>    - `EIP` 被设置为目标偏移地址。
>    - 实际跳转的线性地址 = `段基址 + EIP`。
>
> ------
>
> ### **机器码表示**
>
> `JMP FAR` 的机器码通常包含：
>
> - **操作码**：`EA`（直接远跳转）或 `FF /5`（间接远跳转）。
> - **操作数**：偏移地址 + 段选择子（小端存储）。
>
> ```assembly
> JMP FAR 0060:1234  ; 机器码：EA 34 12 60 00
> ```
>
> - `EA` = 远跳转操作码。
> - `34 12` = 偏移地址 `0x1234`（小端存储）。
> - `60 00` = 段选择子 `0x0060`（小端存储）。

这里将cs的值改为0x63即段选择子为0x63，而里面的基址等于原本的cs的段选择子里面的段描述符相同，所以对于代码地址来说没有变化。



> `*(PULONG)&buf[0] = (ULONG)text;`
>
> 1. **`text`**
>    - 这是一个**函数的指针**（例如 `void text()`）。
>    - 在 C/C++ 中，函数名本身就是一个指针，指向函数的入口地址。
> 2. **`(ULONG)text`**
>    - 将函数指针 `text` **强制转换**为 `ULONG`（无符号长整型，32 位）。
>    - 这样做的目的是将函数地址存储为数值（而不是函数指针）。
> 3. **`&buf[0]`**
>    - 获取缓冲区 `buf` 的**首地址**（即 `buf` 的第 0 个元素的地址）。
> 4. **`(PULONG)&buf[0]`**
>    - 将 `buf[0]` 的地址**强制转换**为 `PULONG`（指向 `ULONG` 的指针）。
>    - 这样做的目的是让编译器认为 `buf` 的前 4 字节是一个 `ULONG` 变量。
> 5. **`*(PULONG)&buf[0] = ...`**
>    - 对转换后的指针**解引用**，并向其写入 `(ULONG)text`。
>    - 相当于把 `text` 的地址（32 位）写入 `buf` 的前 4 字节。
>
> ------
>
> ### **等效写法**
>
> ```cpp
> // 方法 1：直接指针操作
> *(unsigned long *)buf = (unsigned long)text;
> 
> // 方法 2：使用 memcpy（更安全，避免类型转换警告）
> memcpy(buf, &text, sizeof(ULONG));
> 
> // 方法 3：使用 union（类型安全）
> union {
>     void (*func)();
>     unsigned long addr;
>     char buf[4];
> } converter;
> converter.func = text;
> memcpy(buf, converter.buf, 4);
> ```

![image-20250625140245957](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140245957.png)

最终翻译为0x0063(段选择子):地址  `0x63:test`

其中 cs段选择子占两个字节  32位系统下 地址占4字节

![image-20250625140356920](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140356920.png)

打上断点

![image-20250625140510069](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140510069.png)

![image-20250625140806460](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140806460.png)

- 发现jmp对堆栈不产生影响

(跳转前ESP内容)

![image-20250627124410350](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627124410350.png)

（跳转后ESP内容）

![image-20250627124457119](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627124457119.png)

cs的值被修改，跨段跳转成功

![image-20250625141141516](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625141141516.png)

利用jmp从被调函数中返回：

已知当调用ret时，会将栈指针向低地址走4字节，即出栈。而jmp不修改栈的值，所以用jmp跳转会主函数时，不会出现堆栈不平衡的现象。 利用jmp从被调函数返回，其根本原理就是手动保存返回地址，call指令会自动将返回地址压入到栈中，jmp可以手动将返回地址保存至寄存器(确保其值不会改变)，或者手动压入栈中。

```c++
__asm {
        LEA EAX, return_point  ; 保存返回地址到 EAX
        JMP target_function    ; 跳转

    return_point:
        MOV EBX, 0x5678        ; 返回后继续执行
    }
```

这里 return_point 是一个标记，里面保存着返回地址  

```c++
__asm {
        PUSH return_point  ; 手动压入返回地址
        JMP target_function

    return_point:
        ADD ESP, 4        ; 平衡栈（可选）  //不平衡栈 会在调试器中报出警告
    }

void target_function() {
    __asm {
        RET  ; 弹出栈顶地址并跳转
    }
}
```

###### CALL

call 在执行时是调用函数，后跟函数首地址，并且将本来的地址（4字节）压入栈中，便于从被调函数返回。

现将jmp改为call

![image-20250625142719028](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625142719028.png)

打开内存窗口

![image-20250625142631290](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625142631290.png)

在内存窗口查看ESP的内存

![image-20250625142847309](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625142847309.png)

在执行跳转以后，发现栈顶寄存器ESP偏移了八个字节

![image-20250625143450290](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625143450290.png)

查看新的栈顶地址，发现压入了两个值，一个是返回地址，另一个是原本的CS的值**，即在跨段不提权下，CALL指令会将原本的CS值以及返回地址压入栈中**

![image-20250625143708206](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625143708206.png)

现在直接执行被调函数中的return指令返回主函数，能够正确返回，但会出现一个**堆栈不平衡**的错误

![image-20250625144004441](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144004441.png)

这表明，`CALL fword loacation `与`ret`这样的指令并不能保证堆栈平衡。这里的`fword`表明远跳，与其配套的返回指令是`retf`远返回

验证：

在调用函数之前`ESP = 0x002DF944`

![image-20250625144641552](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144641552.png)

跳转以后变为3c 等于44 - 8

![image-20250625144804797](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144804797.png)

![image-20250625144915187](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144915187.png)

在从retf返回，发现ESP的值变回了在主函数中的堆栈的地址，并且CS的值变为了原本的CS的值。表明正确返回。

CALL 用于提权  retf用于降权

### **段寄存器中值的含义**

那么原本的ds段寄存器中的值有什么含义呢？

**段寄存器中的值叫做段选择子**

- 段选择符

查开发指南可以知道，intel的cpu 的低三位 为标志位 第三位T I 代表table index 位为 表的一个索引，

这里intel处理器下， 0 表示全局段描述表 1表示本地段描述表



**DS == 0x0023 写作二进制 0000 0000 0010 0011  表示RPL位 为 11~（b）~ TI 位 为 0 表示索引表位全局段描述表**

intel下有一个寄存器 GDT 存储了全局段描述表和GDT表长

LDT存储了本地段描述表，但本地端描述表的标头，存储在GDT中

![image-20250623120647383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120647383.png)

- windbg的使用 `r` 表示读取寄存器值

  

![image-20250623134759752](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623134759752.png)

在windbg并不区分大小写

![image-20250624121213654](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624121213654.png)

可以通过该指令修改寄存器的值

![image-20250623134858531](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623134858531.png)

这里windbg的低版本不支持直接输入寄存器  要在寄存器名字前面加上`@`符号 表示该标识为寄存器

![image-20250623135025880](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623135025880.png)

在高版本下，实现的效果是一致的

![image-20250623135256288](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623135256288.png)

> 这里段选择子的内容用于查询段选择表
>
> 但并不是每次运行程序的时候去查一次表来得到段描述符
>
> 而是每一次修改段描述符的时候查一次表，或者修改段选择子的时候查一次表



![image-20250623140325154](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623140325154.png)

这里读取gdt表可以知道  其首地址为0x80b99000

**注意 在多核的情况下 每一个核都有一个gdt表，在后续编写程序的时候可能执行的核  与运行程序的核不同，导致修改的段描述符与实际运行的段描述符不同，所以在本次测试中，虚拟机需要使用一核的cpu**

根据段选择符的划分可知 index == 4

![image-20250623141632913](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623141632913.png)

> windge 下查看段描述表  
>
> db一个字节一个字节的查看
>
> dw 两个字节的查看
>
> dd (d double word)   四个字节的查看
>
> dq  八个字节查看 
>
> d 字节数  s 竖着查看

- dqs
  ![image-20250623143456242](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623143456242.png)

**由于是32bit电脑  每一个段描述符占8btye**

**段选择符中的段选择索引指向一个段描述符**

![image-20250623142442647](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623142442647.png)

快速查看

> ​	段选择符的后三位是标记位，这里用其与0xFFF8做与运算   结果为0x20 表明是32bit的前八个字节
>
> 再简化一些就是 地址的低四位大于8那么就是后八个字节 小于8 就是前八个字节

最终得到一个段描述符 `0x00cff300 0000ffff`

### 段描述符的划分

tips:在查看一个段描述符的时候 先看P位 判断是否有效，再看S位。

#### P位

P位 为 Segment present 是否有效

- = 1 有效 能够正常价值
- = 0 无效 无法正常加载

#### S位

- = 1 数据代码段
- = 0 系统段
  - 系统段又分为 调用门 任务段等

#### 数据代码段的划分方式

![image-20250624141619793](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624141619793.png)

确认是数据段还是代码段就需要看type位

##### Type位

**s = 1 时 type位的含义**

数据代码段将type划分到了 8 9 10 11 四个位

看下面的含义可以看出 11位  是区分是数据段还是代码段

- 11 = 1 代码段
- 11 = 0 数据段

![image-20250624142300533](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624142300533.png)

###### 第8位 A 

脏位

当对该描述段进行**加载或者写**时  标记为1。

###### 第9位 W

 是否可写

###### 第10位 E

- E = 0 向上拓展
- E = 1向下拓展

这里的方向表示高地址与低地址

> 设计的作用：
>
> 当系统的字长更大的时候，例如64bit往上的时候，就会需要更大的地址，通过指定拓展方向就可以选择哪部分可以访问或者说哪一部分不能访问
>
> 到64bit下 base = 0 limit = 0

由于内存的地址是递增的，所以当E位为0是表示 从低位向高位拓展  E = 1  时表示由高位向低位拓展

这里拓展是可访问的方向 由base开始  若base为0  那么向上拓展时  可以访问0x00000000~0xFFFFFFFF

但向下拓展时为内存给定空间的边界，所以无法访问别的内存空间。

![image-20250624154703409](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624154703409.png)

![image-20250624155418543](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624155418543.png)

当base为0x80000000时 向下访问时 从base 到 limit的部分不可访问  但从0x7FFFFFFF ~ 0x00000000是可以访问的

> 注意：0x8000000不可以访问 因为从0x800000000的地址开始到0x80000001的这部分内存属于向上拓展

###### 代码段部分

- A位依然是脏位
- R 位代表是否可读

> 基本不会设定只能执行的内存段，因为读与执行通常是绑定在一起的
>
> 例如汇编语句`jmp dword ptr cs:[0x12345678]`
>
> 要执行也要读取内存[0x12345678]
>
> 如果设定一段只能执行的代码段，那么该类指令语句就不能使用

- C
  - C = 1 一致代码段
  - C = 0 非一致代码段

> 一致代码段就是running3 与Running0 的代码段看成一个整体，在纯段(没有页保护)模式下可以从Running3的内存区域访问Running0的代码区域。
>
> 非一致代码段在访问的过程中经过DPL的权限的划分对内核代码进行保护

![image-20250624162729551](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624162729551.png)

##### AVL

这个是预留给操作系统使用的，因特尔的cpu并没有使用到这个位

##### D/B位

> 用于兼容一些很老的程序，所设立的

- D == Default
- B == bit 位数

作用于代码段  会改变默认操作数

例如 `push 0x12345678`

当D/b = 1 数据段时

按照默认操作数，此时压入 4字节

当D/b = 0 代码段时

此时默认操作数被修改，压入2字节

##### 验证DB位

- 将代码段的段描述符放入到0x60中

![image-20250624174516933](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624174516933.png)

![image-20250627103919517](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627103919517.png)

![image-20250624174659705](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624174659705.png)

![image-20250624170825383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624170825383.png)

###### **跨段跳转 **

用于修改cs的值

![image-20250624170947463](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624170947463.png)

![image-20250624172033527](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624172033527.png)

执行完汇编语句以后，cs的值改为了0x63

![image-20250624172103995](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624172103995.png)

###### 作用于代码段

将原本的cs的段描述符修改其D/B位为0 后写入到0x63

![image-20250624175255022](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624175255022.png)

![image-20250624172601487](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624172601487.png)

![image-20250624171435528](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624171435528.png)

右下角的地址原本应该由8c - 4 变为88 由于修改了默认操作数 使得地址变为了8C-2 = 8A

![image-20250624171631171](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624171631171.png)

###### D/b 作用于普通数据段

![image-20250624175910018](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624175910018.png)

![image-20250624180128559](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624180128559.png)

作用于数据段是没有区别的，改为堆栈段

将数据存放到堆栈中

此时 D/b作用于栈，那么会将ESP变为SP

![image-20250624180707354](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624180707354.png)

此时 32bit下并没有FF8C这个地址压入栈中就会报错

![image-20250624180757843](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624180757843.png)

##### Base

在32bit系统里面  线性地址算法变为 段描述符.base + 虚拟地址  = 线性地址

![image-20250623145315871](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145315871.png)

DPL：程序描述权限等级。其含义是确认该段描述符是否在用户态下可以访问。

此时的虚拟地址为程序的入口地址

![image-20250623145747070](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145747070.png)

对于base的地址等于零  称作平躺模式

##### Limit 限长

- 即从base开始 可以访问到的内存的最大位置

继续划分得到LIMIT == 0xFFFFF

![image-20250623151321455](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623151321455.png)

这里限长为 0xFFFFF

即地址的最大访问为 0~ 0xFFFFF 

> Question： 为什么地址的访问大多都大于这个值

G位 为1  

G位表示限长的单位  1 表示页  0 表示字节

32 bit电脑 一页有4096B 转换为16进制为0x1000

那么地址最大值为限长* 单位 

即0xFFFFF * 0x1000 即左移12位  等于 0xFFFFF000

注意这里要求是限长 * 单位

即总的限长大小  而不是限长地址的最大值 

那么总得限长为0x100000B 

再乘以单位为 0x100000B * 0x1000 = 0x100000000

得到总的限长  由于地址从0开始  最终限长的地址的最大值为 0x100000000 - 1 = 0xFFFFFFFF

**测试限长**

对于fs寄存器  其值为0x003B  对于的段描述符为`0x0040F300 00000FFF`

得到其base为0x00000000

G位为0 单位为byte

其限长为0x00FFF 这个限长比较小 方便测试  

![image-20250623161913221](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623161913221.png)

读取fs保存的地址的数据

![image-20250623162441447](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162441447.png)

![image-20250623162456097](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162456097.png)

![image-20250623162907041](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162907041.png)

![image-20250623163524740](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623163524740.png)

##### 验证线性地址

![image-20250623164045673](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623164045673.png)

![image-20250623171756349](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623171756349.png)

![image-20250623172351656](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172351656.png)



> tips:注意 x不一定存放在eax寄存器中，这里可以直接赋值给x，其目的是查看修改base后访问x1的地址是否会得到x1.

![image-20250624131356003](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131356003.png)

![image-20250624131420280](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131420280.png)

![image-20250623172334128](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172334128.png)

![image-20250623172529161](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172529161.png)

![image-20250623172745029](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172745029.png)

##### P位的验证

![image-20250623170345093](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623170345093.png)

此时相同的程序 debug报错

![image-20250623172849083](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172849083.png)

![image-20250623165459414](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623165459414.png)

![image-20250624131726273](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131726273.png)

现在再来看这个图  就会发现得到段描述表以后  段寄存器中的值 段选择子为表示该段描述表中的各个字段所归属的段寄存器的值。

##### type 位 写入权限的验证

![image-20250624145011495](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624145011495.png)

![image-20250624144542405](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624144542405.png)

![image-20250624144653839](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624144653839.png)

### 段寄存器的字长

**段寄存器本质上是一个96位的寄存器**

段描述选择子占两字节  16bit 

![image-20250623172351656](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172351656.png)

然后是段描述表中的段描述符的详细信息 包括基址 限长 权限

![image-20250624131726273](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131726273.png)

其中 基址占32bit 限长占 20bit 权限占16bit

共有16bit +32bit + 20bit + 16bit =  84bit

之后 限长根据G位的计算 在单位为页的情况下最大有32bit 则多加上12bit。共96bit长

**这里划分时虽然attribute 权限部分中包含了4bit的限长  但划分时这4bit是重复使用的。**

![image-20250624154129089](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624154129089.png)





## 权限位

![image-20250624141619793](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624141619793.png)

![image-20250623120647383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120647383.png)

![image-20250625112601231](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625112601231.png)

用于描述一个段 有什么样的权限 

- DPL  describe privilege level
  - DPL占2bit 刚好对于四种情况 0 1 2 3 
    - 其数据对应于Running0 Running1 Running2 Running3 即该段具有0环、1环、2环等权限
- RPL request  privilege level
  - 请求权限  即是否赋予该权限由系统决定
- CPL current privilege level（当前权限）

![image-20250625114356303](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625114356303.png)

**通过查看cs ss的段描述符里面的DPL，可以知道当前所处的段是什么权限**

例如，cs的值为0x1B 那么查询其段描述表找到对于的段描述符可知

![image-20250625114558901](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625114558901.png)

**CS段和SS段中的DPL是一致的，在查看段权限的时候通常是两个段描述符一起看**

![image-20250625114930869](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625114930869.png)

在用户态下(三环) cs通常是1B SS对应于23

**在提权后，内核态下(零环)cs通常为0x08 SS紧接着对应于cs后面的那一个段**（例如cs为0x08 那么ss就为0x10）

于是再看GDT表的时候呢，就有一个默认规则，**便是代码段后面跟着堆栈段** 

那也就意味着，**如果想从用户态提权到内核态，那一定要能够同时修改CS和SS的段选择子，才可以提权**

验证：

将原本ss的段描述符复制到0x60对应的段描述符位置，RPL的值为3，即请求三环的权限，后在段描述符中的DPL为3的情况下，令RPL为0，去请求零环权限，最终报错。

![image-20250625120727319](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625120727319.png)

现仅修改ss的段描述符，而不修改cs的段描述符

![image-20250625121536825](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625121536825.png)

![image-20250625121732645](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625121732645.png)

最终结果任然报错

![image-20250625121802084](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625121802084.png)

现尝试在段描述符为零环，对于数据段以零环权限来请求的情况

![image-20250625122233749](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625122233749.png)

最终结果还是报错，此时cs和ss还是三环的权限，表明提权并没有成功。

![image-20250625122445192](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625122445192.png)



对于普通的数据段，**RPL在数值上是可以小于等于DPL**的但在数据上的访问权限是由页表来控制的，也就是说能访问哪一块内存，是根据页表的限制，RPL请求的权限无意义。

![image-20250625123543469](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625123543469.png)

将ds的RPL改为0，此后请求零环权限

![image-20250625123817908](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625123817908.png)

验证：请求与实际授予的权限

![image-20250625124542710](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625124542710.png)

前面收到过，跨段跳转可以修改cs的值，申请0x60的权限，进行跨段跳转，可以发现，汇编代码执行以后，cs的值变成了0x63，即是否授予零环权限由系统决定，申请的RPL与最终得到的权限不同。

![image-20250625124644283](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625124644283.png)

![image-20250625125426127](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625125426127.png)

![image-20250625125506882](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625125506882.png)
