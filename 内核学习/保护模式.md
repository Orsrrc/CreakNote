# 实模式

在16位系统的时期，程序在内存上面运行直接得到的就是真实，**对于内存上面线性的地址的增加，没有什么有效的防护手段避免由程序跳转到内核区域。**

会使得creaker可以任意的修改内核中的内容

![image-20250623104024367](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623104024367.png)

> 最终去的地址  线性地址  其中cs ss ds es fs gs 是用于地址跳转用的段寄存器，
>
> 反汇编工具上面的地址是虚拟地址
>
> 段地址 * 0x10  + 虚拟地址 = 线性地址
>
> 对于线性地址，即在一块内存区中，程序的入口地址是线性增加的。

后面开发出 x86 386  最终实现了保护模式

# 保护模式

段页保护模式（保护目标）

在逻辑上可以设置成只有段模式没有页模式，但是页模式不能单独存在，即不存在只有页模式没有段模式这种模式。

- 资源限制（段）

  - 硬件资源 如寄存器 例如权限访问

- 内存隔离（页）

  ![image-20250623110226195](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623110226195.png)

对于内核态地址，大部分是共享的地址，即从A程序访问0x8FFFFFFF 与B程序访问0x8FFFFFFF得到的数据是一样的。可以简单理解为系统调用。

系统对权限的分层

![image-20250623112845743](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623112845743.png)

从外往里分别是Running3 Running2 Running1 Running0  权限的大小从R0 （内核态）到最外部的用户态R3

Windows和大部分Linux的系统仅有内核态（R0）和用户态(R3) 两层。

## 段探测

### 段寄存器 

ss cs ds es fs gs

- ds 数据段寄存器  malloc 和new 在堆申请的空间 均用该寄存器进行索引
  - `mov eax, dword ptr ds:[eax]`
- es额外段寄存器 `mosb es:[edi]`
- ss 堆栈段寄存器  `mov eax, dword ptr ss:[ebp] [esp]`
- cs代码段寄存器 `jmp call dword ptr cs[eax]`
- fs 环境段寄存器 当前执行线程的环境块teb
- gs 32 位系统未涉及， 64位环境段寄存器

### 段寄存器修改

​	测试在三环（R3）环境下是否能够修改段寄存器

在Windows7 32bit下 用vs2008 编写一个简单的程序 并放入汇编程序查看

![image-20250623114747848](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623114747848.png)

![image-20250623145638015](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145638015.png)

![image-20250623115502365](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115502365.png)

改为cs寄存器，并且在入口处打上断点

![image-20250623115528935](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115528935.png)

打开寄存器窗口

![image-20250623115617225](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623115617225.png)![image-20250624120427596](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624120427596.png)

记得右键选择cpu段

打开编译器的调试寄存器窗口 并打上断点

![image-20250623120428031](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120428031.png)

![image-20250623120516639](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120516639.png)

发现成功修改段寄存器的值

**这里未把ds的值修改回去，那么后续的指令的地址可能会出错。**

#### 跨段跳转

##### 裸函数

首先，先看一个函数如果里面没有任何语句时，它的汇编代码：

编写一个普通的函数查看它的反汇编代码

![image-20250625131128262](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131128262.png)



![image-20250625131315383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131315383.png)

按F11进入后得到一个**增量链接**，这个增量链接就是在调试的时候，由编辑器增添的符号。**如果采用release模式，并关闭程序的运行和代码优化，就不会产生增量链接**，从反汇编按F11会直接进入到函数的汇编代码中。

![image-20250625131425564](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131425564.png)

- 关闭增量链接

![image-20250625133245330](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625133245330.png)

进入到实际的汇编代码里面，注意，这个函数原本是空的，里面什么都没有写，但汇编代码任然存在，这就不是一个裸函数。

![image-20250625131441935](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625131441935.png)

裸函数，其实际含义是编写什么就翻译为对应的汇编代码，而编译器不会添加额外的汇编语句

裸函数关键字写法 （注意：64bit中没有裸函数）

![image-20250625133708693](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625133708693.png)

>`__declspec(attribute) ` 是 Microsoft Visual C++（MSVC）特有的扩展关键字，用于指定存储类属性（storage-class attributes），控制变量、函数或类的编译和链接行为。它通常用于 Windows 平台开发，尤其是在 DLL 导出/导入、内存对齐、线程局部存储等场景。
>
>其中 `attribute` 是具体的属性修饰符，例如：
>
>- `dllimport` / `dllexport`（DLL 导入/导出）
>- `naked`（无额外编译器生成的函数序言/尾声）
>- `align`（内存对齐）
>- `thread`（线程局部存储）
>- `property`（COM 属性支持）
>- `deprecated`（标记为弃用）
>- `noalias` / `restrict`（优化内存访问）

转到其汇编查看，会看到不会再生成别的汇编代码

![image-20250625134709724](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625134709724.png)

编写一个return查看

![image-20250625134910768](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625134910768.png)

![image-20250625134922578](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625134922578.png)

添加局部变量 发现失败，因为没有开辟堆栈，无法将一块内存分配给局部变量

![image-20250625135019958](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625135019958.png)

##### 跨段不提权

- 在汇编语句中实现跳转的写法：

###### JMP

> `JMP FAR 0060:地址` 是一条 **远跳转（Far Jump）** 指令，用于跨段跳转（即同时修改 `CS` 和 `IP/EIP`）。它的作用是从当前代码段跳转到另一个代码段（段选择子 `0060`）的指定偏移地址处执行。
>
> ------
>
> ### **指令格式**
>
> ```assembly
> JMP FAR 0060:地址   ; 16位模式下：CS=0060, IP=地址
> JMP FAR 0060:地址   ; 32位模式下：CS=0060, EIP=地址
> ```
>
> - **`0060`** 是目标段选择子（Segment Selector），会加载到 `CS` 寄存器。
> - **`地址`** 是目标偏移地址（Offset），会加载到 `IP`（16位）或 `EIP`（32位）。
>
> ------
>
> ### **具体行为**
>
> 1. **16位实模式（Real Mode）**
>    - `CS`（代码段寄存器）被设置为 `0060`。
>    - `IP`（指令指针）被设置为指定的偏移地址。
>    - 实际跳转的物理地址 = `(CS << 4) + IP`（即 `0060 * 16 + 地址`）。
> 2. **32位保护模式（Protected Mode）**
>    - `0060` 是一个段选择子，CPU 会检查 GDT（全局描述符表）或 LDT（局部描述符表）中的段描述符，获取目标段的基址和权限。
>    - `EIP` 被设置为目标偏移地址。
>    - 实际跳转的线性地址 = `段基址 + EIP`。
>
> ------
>
> ### **机器码表示**
>
> `JMP FAR` 的机器码通常包含：
>
> - **操作码**：`EA`（直接远跳转）或 `FF /5`（间接远跳转）。
> - **操作数**：偏移地址 + 段选择子（小端存储）。
>
> ```assembly
> JMP FAR 0060:1234  ; 机器码：EA 34 12 60 00
> ```
>
> - `EA` = 远跳转操作码。
> - `34 12` = 偏移地址 `0x1234`（小端存储）。
> - `60 00` = 段选择子 `0x0060`（小端存储）。

这里将cs的值改为0x63即段选择子为0x63，而里面的基址等于原本的cs的段选择子里面的段描述符相同，所以对于代码地址来说没有变化。

> `*(PULONG)&buf[0] = (ULONG)text;`
>
> 1. **`text`**
>    - 这是一个**函数的指针**（例如 `void text()`）。
>    - 在 C/C++ 中，函数名本身就是一个指针，指向函数的入口地址。
> 2. **`(ULONG)text`**
>    - 将函数指针 `text` **强制转换**为 `ULONG`（无符号长整型，32 位）。
>    - 这样做的目的是将函数地址存储为数值（而不是函数指针）。
> 3. **`&buf[0]`**
>    - 获取缓冲区 `buf` 的**首地址**（即 `buf` 的第 0 个元素的地址）。
> 4. **`(PULONG)&buf[0]`**
>    - 将 `buf[0]` 的地址**强制转换**为 `PULONG`（指向 `ULONG` 的指针）。
>    - 这样做的目的是让编译器认为 `buf` 的前 4 字节是一个 `ULONG` 变量。
> 5. **`*(PULONG)&buf[0] = ...`**
>    - 对转换后的指针**解引用**，并向其写入 `(ULONG)text`。
>    - 相当于把 `text` 的地址（32 位）写入 `buf` 的前 4 字节。
>
> ------
>
> ### **等效写法**
>
> ```cpp
> // 方法 1：直接指针操作
> *(unsigned long *)buf = (unsigned long)text;
> 
> // 方法 2：使用 memcpy（更安全，避免类型转换警告）
> memcpy(buf, &text, sizeof(ULONG));
> 
> // 方法 3：使用 union（类型安全）
> union {
>     void (*func)();
>     unsigned long addr;
>     char buf[4];
> } converter;
> converter.func = text;
> memcpy(buf, converter.buf, 4);
> ```

![image-20250625140245957](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140245957.png)

最终翻译为0x0063(段选择子):地址  `0x63:test`

其中 cs段选择子占两个字节  32位系统下 地址占4字节

![image-20250625140356920](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140356920.png)

打上断点

![image-20250625140510069](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140510069.png)

![image-20250625140806460](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625140806460.png)

- 发现jmp对堆栈不产生影响

(跳转前ESP内容)

![image-20250627124410350](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627124410350.png)

（跳转后ESP内容）

![image-20250627124457119](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627124457119.png)

cs的值被修改，跨段跳转成功

![image-20250625141141516](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625141141516.png)

利用jmp从被调函数中返回：

已知当调用ret时，会将栈指针向低地址走4字节，即出栈。而jmp不修改栈的值，所以用jmp跳转会主函数时，不会出现堆栈不平衡的现象。 利用jmp从被调函数返回，其根本原理就是手动保存返回地址，call指令会自动将返回地址压入到栈中，jmp可以手动将返回地址保存至寄存器(确保其值不会改变)，或者手动压入栈中。

```c++
__asm {
        LEA EAX, return_point  ; 保存返回地址到 EAX
        JMP target_function    ; 跳转

    return_point:
        MOV EBX, 0x5678        ; 返回后继续执行
    }
```

这里 return_point 是一个标记，里面保存着返回地址  

```c++
__asm {
        PUSH return_point  ; 手动压入返回地址
        JMP target_function

    return_point:
        ADD ESP, 4        ; 平衡栈（可选）  //不平衡栈 会在调试器中报出警告
    }

void target_function() {
    __asm {
        RET  ; 弹出栈顶地址并跳转
    }
}
```

压入堆栈写法

![image-20250627143605184](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627143605184.png)

这里不是汇编的标准语法，而是编译器提供的一个伪地址翻译，这里的haha 还是之前的return_point 都是一个编译器提供的一个标签，并不是关键字，可以自定义名称。

堆栈的设计 是栈底在高地址，栈顶在低地址。这样设计刚好对应于小端字节序（先存低位，后存高位）

![image-20250627144152575](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627144152575.png)

![image-20250627144934515](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627144934515.png)

这样可以返回并平衡了堆栈。

![image-20250627145426978](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627145426978.png)

注意这里 jmp fword 表明从 ptr所给的地址后读六个字节作为远跳的地址  这里实际上从[esp - 8] 往高地址读了六个字节  变成了 **cs:返回地址**

###### CALL

call 在执行时是调用函数，后跟函数首地址，并且将本来的地址（4字节）压入栈中，便于从被调函数返回。

现将jmp改为call

![image-20250625142719028](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625142719028.png)

打开内存窗口

![image-20250625142631290](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625142631290.png)

在内存窗口查看ESP的内存

![image-20250625142847309](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625142847309.png)

在执行跳转以后，发现栈顶寄存器ESP偏移了八个字节

![image-20250625143450290](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625143450290.png)

查看新的栈顶地址，发现压入了两个值，一个是返回地址，另一个是原本的CS的值**，即在跨段不提权下，CALL指令会将原本的CS值以及返回地址压入栈中**

![image-20250625143708206](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625143708206.png)

现在直接执行被调函数中的return指令返回主函数，能够正确返回，但会出现一个**堆栈不平衡**的错误

![image-20250625144004441](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144004441.png)

这表明，`CALL fword loacation `与`ret`这样的指令并不能保证堆栈平衡。这里的`fword`表明远跳，与其配套的返回指令是`retf`远返回

验证：

在调用函数之前`ESP = 0x002DF944`

![image-20250625144641552](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144641552.png)

跳转以后变为3c 等于44 - 8

![image-20250625144804797](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144804797.png)

![image-20250625144915187](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625144915187.png)

在从retf返回，发现ESP的值变回了在主函数中的堆栈的地址，并且CS的值变为了原本的CS的值。表明正确返回。

CALL 用于提权  retf用于降权

### 段寄存器的字长

**段寄存器本质上是一个96位的寄存器**

段描述选择子占两字节  16bit 

![image-20250623172351656](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172351656.png)

然后是段描述表中的段描述符的详细信息 包括基址 限长 权限

![image-20250624131726273](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131726273.png)

其中 基址占32bit 限长占 20bit 权限占16bit

共有16bit +32bit + 20bit + 16bit =  84bit

之后 限长根据G位的计算 在单位为页的情况下最大有32bit 则多加上12bit。共96bit长

**这里划分时虽然attribute 权限部分中包含了4bit的限长  但划分时这4bit是重复使用的。**

![image-20250624154129089](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624154129089.png)







### **段寄存器中值的含义**

那么原本的ds段寄存器中的值有什么含义呢？

**段寄存器中的值叫做段选择子**

- 段选择符

查开发指南可以知道，intel的cpu 的低三位 为标志位 第三位T I 代表table index 位为 表的一个索引，

这里intel处理器下， 0 表示全局段描述表 1表示本地段描述表



**DS == 0x0023 写作二进制 0000 0000 0010 0011  表示RPL位 为 11~（b）~ TI 位 为 0 表示索引表位全局段描述表**

intel下有一个寄存器 GDT 存储了全局段描述表和GDT表长

LDT存储了本地段描述表，但本地端描述表的标头，存储在GDT中

![image-20250623120647383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120647383.png)

- windbg的使用 `r` 表示读取寄存器值

  

![image-20250623134759752](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623134759752.png)

在windbg并不区分大小写

![image-20250624121213654](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624121213654.png)

可以通过该指令修改寄存器的值

![image-20250623134858531](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623134858531.png)

这里windbg的低版本不支持直接输入寄存器  要在寄存器名字前面加上`@`符号 表示该标识为寄存器

![image-20250623135025880](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623135025880.png)

在高版本下，实现的效果是一致的

![image-20250623135256288](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623135256288.png)

> 这里段选择子的内容用于查询段选择表
>
> 但并不是每次运行程序的时候去查一次表来得到段描述符
>
> 而是每一次修改段描述符的时候查一次表，或者修改段选择子的时候查一次表



![image-20250623140325154](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623140325154.png)

这里读取gdt表可以知道  其首地址为0x80b99000

**注意 在多核的情况下 每一个核都有一个gdt表，在后续编写程序的时候可能执行的核  与运行程序的核不同，导致修改的段描述符与实际运行的段描述符不同，所以在本次测试中，虚拟机需要使用一核的cpu**

根据段选择符的划分可知 index == 4

![image-20250623141632913](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623141632913.png)

> windge 下查看段描述表  
>
> db一个字节一个字节的查看
>
> dw 两个字节的查看
>
> dd (d double word)   四个字节的查看
>
> dq  八个字节查看 
>
> d 字节数  s 竖着查看

- dqs
  ![image-20250623143456242](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623143456242.png)

**由于是32bit电脑  每一个段描述符占8btye**

**段选择符中的段选择索引指向一个段描述符**

![image-20250623142442647](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623142442647.png)

快速查看

> ​	段选择符的后三位是标记位，这里用其与0xFFF8做与运算   结果为0x20 表明是32bit的前八个字节
>
> 再简化一些就是 地址的低四位大于8那么就是后八个字节 小于8 就是前八个字节

最终得到一个段描述符 `0x00cff300 0000ffff`

### 段描述符的划分(GDT表)

![image-20250624141619793](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624141619793.png)

tips:在查看一个段描述符的时候 先看P位 判断是否有效，再看S位。

#### P位

P位 为 Segment present 是否有效

- = 1 有效 能够正常价值
- = 0 无效 无法正常加载

#### S位

- = 1 数据代码段
- = 0 系统段
  - 系统段又分为 调用门 任务段等



确认是数据段还是代码段就需要看type位

#### Type位

##### 数据代码段的划分方式

**s = 1 时 type位的含义**

数据代码段将type划分到了 8 9 10 11 四个位

看下面的含义可以看出 11位  是区分是数据段还是代码段

- 11 = 1 代码段
- 11 = 0 数据段

![image-20250624142300533](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624142300533.png)

###### 第8位 A 

脏位

当对该描述段进行**加载或者写**时  标记为1。

###### 第9位 W

 是否可写

###### 第10位 E

- E = 0 向上拓展
- E = 1向下拓展

这里的方向表示高地址与低地址

> 设计的作用：
>
> 当系统的字长更大的时候，例如64bit往上的时候，就会需要更大的地址，通过指定拓展方向就可以选择哪部分可以访问或者说哪一部分不能访问
>
> 到64bit下 base = 0 limit = 0

由于内存的地址是递增的，所以当E位为0是表示 从低位向高位拓展  E = 1  时表示由高位向低位拓展

这里拓展是可访问的方向 由base开始  若base为0  那么向上拓展时  可以访问0x00000000~0xFFFFFFFF

但向下拓展时为内存给定空间的边界，所以无法访问别的内存空间。

![image-20250624154703409](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624154703409.png)

![image-20250624155418543](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624155418543.png)

当base为0x80000000时 向下访问时 从base 到 limit的部分不可访问  但从0x7FFFFFFF ~ 0x00000000是可以访问的

> 注意：0x8000000不可以访问 因为从0x800000000的地址开始到0x80000001的这部分内存属于向上拓展

###### 代码段部分

- A位依然是脏位
- R 位代表是否可读

> 基本不会设定只能执行的内存段，因为读与执行通常是绑定在一起的
>
> 例如汇编语句`jmp dword ptr cs:[0x12345678]`
>
> 要执行也要读取内存[0x12345678]
>
> 如果设定一段只能执行的代码段，那么该类指令语句就不能使用

- C
  - C = 1 一致代码段
  - C = 0 非一致代码段

> 一致代码段就是running3 与Running0 的代码段看成一个整体，在纯段(没有页保护)模式下可以从Running3的内存区域访问Running0的代码区域。
>
> 非一致代码段在访问的过程中经过DPL的权限的划分对内核代码进行保护

![image-20250624162729551](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624162729551.png)

##### 系统段的划分方式

系统段 即s = 0 时 表明该段描述符 是系统段  其type的划分与数据代码段的划分不同（s=1）

![image-20250627150225530](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627150225530.png)

#### AVL

这个是预留给操作系统使用的，因特尔的cpu并没有使用到这个位

#### D/B位

> 用于兼容一些很老的程序，所设立的

- D == Default
- B == bit 位数

作用于代码段  会改变默认操作数

例如 `push 0x12345678`

当D/b = 1 数据段时

按照默认操作数，此时压入 4字节

当D/b = 0 代码段时

此时默认操作数被修改，压入2字节

##### 验证DB位

- 将代码段的段描述符放入到0x60中

![image-20250624174516933](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624174516933.png)

![image-20250627103919517](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627103919517.png)

![image-20250624174659705](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624174659705.png)

![image-20250624170825383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624170825383.png)

###### **跨段跳转 **

用于修改cs的值

![image-20250624170947463](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624170947463.png)

![image-20250624172033527](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624172033527.png)

执行完汇编语句以后，cs的值改为了0x63

![image-20250624172103995](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624172103995.png)

###### 作用于代码段

将原本的cs的段描述符修改其D/B位为0 后写入到0x63

![image-20250624175255022](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624175255022.png)

![image-20250624172601487](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624172601487.png)

![image-20250624171435528](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624171435528.png)

右下角的地址原本应该由8c - 4 变为88 由于修改了默认操作数 使得地址变为了8C-2 = 8A

![image-20250624171631171](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624171631171.png)

###### D/b 作用于普通数据段

![image-20250624175910018](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624175910018.png)

![image-20250624180128559](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624180128559.png)

作用于数据段是没有区别的，改为堆栈段

将数据存放到堆栈中

此时 D/b作用于栈，那么会将ESP变为SP

![image-20250624180707354](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624180707354.png)

此时 32bit下并没有FF8C这个地址压入栈中就会报错

![image-20250624180757843](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624180757843.png)

#### Base

在32bit系统里面  线性地址算法变为 段描述符.base + 虚拟地址  = 线性地址

![image-20250623145315871](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145315871.png)

DPL：程序描述权限等级。其含义是确认该段描述符是否在用户态下可以访问。

此时的虚拟地址为程序的入口地址

![image-20250623145747070](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623145747070.png)

对于base的地址等于零  称作平躺模式

#### Limit 限长

- 即从base开始 可以访问到的内存的最大位置

继续划分得到LIMIT == 0xFFFFF

![image-20250623151321455](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623151321455.png)

这里限长为 0xFFFFF

即地址的最大访问为 0~ 0xFFFFF 

> Question： 为什么地址的访问大多都大于这个值

G位 为1  

G位表示限长的单位  1 表示页  0 表示字节

32 bit电脑 一页有4096B 转换为16进制为0x1000

那么地址最大值为限长* 单位 

即0xFFFFF * 0x1000 即左移12位  等于 0xFFFFF000

注意这里要求是限长 * 单位

即总的限长大小  而不是限长地址的最大值 

那么总得限长为0x100000B 

再乘以单位为 0x100000B * 0x1000 = 0x100000000

得到总的限长  由于地址从0开始  最终限长的地址的最大值为 0x100000000 - 1 = 0xFFFFFFFF

**测试限长**

对于fs寄存器  其值为0x003B  对于的段描述符为`0x0040F300 00000FFF`

得到其base为0x00000000

G位为0 单位为byte

其限长为0x00FFF 这个限长比较小 方便测试  

![image-20250623161913221](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623161913221.png)

读取fs保存的地址的数据

![image-20250623162441447](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162441447.png)

![image-20250623162456097](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162456097.png)

![image-20250623162907041](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623162907041.png)

![image-20250623163524740](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623163524740.png)

##### 验证线性地址

![image-20250623164045673](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623164045673.png)

![image-20250623171756349](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623171756349.png)

![image-20250623172351656](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172351656.png)



> tips:注意 x不一定存放在eax寄存器中，这里可以直接赋值给x，其目的是查看修改base后访问x1的地址是否会得到x1.

![image-20250624131356003](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131356003.png)

![image-20250624131420280](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131420280.png)

![image-20250623172334128](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172334128.png)

![image-20250623172529161](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172529161.png)

![image-20250623172745029](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172745029.png)

#### P位的验证

![image-20250623170345093](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623170345093.png)

此时debug报错

![image-20250623172849083](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623172849083.png)

![image-20250623165459414](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623165459414.png)

![image-20250624131726273](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624131726273.png)

现在再来看这个图  就会发现得到段描述表以后  段寄存器中的值 段选择子为表示该段描述表中的各个字段所归属的段寄存器的值。

#### type 位 写入权限的验证

![image-20250624145011495](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624145011495.png)

![image-20250624144542405](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624144542405.png)

![image-20250624144653839](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624144653839.png)

#### DPL

![image-20250624141619793](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250624141619793.png)

![image-20250623120647383](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250623120647383.png)

![image-20250625112601231](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625112601231.png)

用于描述一个段 有什么样的权限 

- DPL  describe privilege level
  - DPL占2bit 刚好对于四种情况 0 1 2 3 
    - 其数据对应于Running0 Running1 Running2 Running3 即该段具有0环、1环、2环等权限
- RPL request  privilege level
  - 请求权限  即是否赋予该权限由系统决定
- CPL current privilege level（当前权限）

![image-20250625114356303](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625114356303.png)

**通过查看cs ss的段描述符里面的DPL，可以知道当前所处的段是什么权限**

例如，cs的值为0x1B 那么查询其段描述表找到对于的段描述符可知

![image-20250625114558901](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625114558901.png)

**CS段和SS段中的DPL是一致的，在查看段权限的时候通常是两个段描述符一起看**

![image-20250625114930869](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625114930869.png)

在用户态下(三环) cs通常是1B SS对应于23

**在提权后，内核态下(零环)cs通常为0x08 SS紧接着对应于cs后面的那一个段**（例如cs为0x08 那么ss就为0x10）

于是再看GDT表的时候呢，就有一个默认规则，**便是代码段后面跟着堆栈段** 

那也就意味着，**如果想从用户态提权到内核态，那一定要能够同时修改CS和SS的段选择子，才可以提权**

##### 验证

将原本ss的段描述符复制到0x60对应的段描述符位置，RPL的值为3，即请求三环的权限，后在段描述符中的DPL为3的情况下，令RPL为0，去请求零环权限，最终报错。

![image-20250625120727319](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625120727319.png)

现仅修改ss的段描述符，而不修改cs的段描述符

![image-20250625121536825](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625121536825.png)

![image-20250625121732645](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625121732645.png)

最终结果任然报错

![image-20250625121802084](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625121802084.png)

现尝试在段描述符为零环，对于数据段以零环权限来请求的情况

![image-20250625122233749](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625122233749.png)

最终结果还是报错，此时cs和ss还是三环的权限，表明提权并没有成功。

![image-20250625122445192](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625122445192.png)



对于普通的数据段，**RPL在数值上是可以小于等于DPL**的但在数据上的访问权限是由页表来控制的，也就是说能访问哪一块内存，是根据页表的限制，RPL请求的权限无意义。

![image-20250625123543469](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625123543469.png)

将ds的RPL改为0，此后请求零环权限

![image-20250625123817908](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625123817908.png)

验证：请求与实际授予的权限

![image-20250625124542710](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625124542710.png)

前面收到过，跨段跳转可以修改cs的值，申请0x60的权限，进行跨段跳转，可以发现，汇编代码执行以后，cs的值变成了0x63，即是否授予零环权限由系统决定，申请的RPL与最终得到的权限不同。

![image-20250625124644283](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625124644283.png)

![image-20250625125426127](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625125426127.png)

![image-20250625125506882](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250625125506882.png)



## 门的概念

在不同空间中传送的通道，一个门就有一个去向 有一个权限

### 调用门

![image-20250627150225530](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627150225530.png)

可以看到 当type等于0xC 的时候  是一个Call Gate （调用门）

调用门的段描述符的划分与别的不同

- 一个门，有对应段选择子

![image-20250627151527290](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627151527290.png)

- offse in segment 
  - 偏移地址
- segment selector
  - 段选择子
  - 这里对应着通过调用门，是否申请提权，例如内核态下cs为0x08 可知，这里的RPL为0 请求零环权限

- Param Count
  - 参数个数
- 上面有参数的部分代表默认值
- type 一定等于C
- DPL代表本身具有的权限。这里DPL代表通过门的一个本身权限上的基本要求，如果，而segment selector段选择子，代表通过这个门后 要求有的权限，以及去哪个段描述符的请求。

#### 构建一个调用门

![image-20250627154011832](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627154011832.png)

得到test的函数入口地址后，进行构建门 这里的test的地址是`0x00401000`

![image-20250627154504100](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627154504100.png)

param count 参数个数为0  type为c 由于在三环下调用该门进行提权，所以DPL等于3  P位表示该段描述符是否有效，所以肯定等于1   所以这里就是 1 11 0 (2) == E(H)

最终等于`0x0040EC00 0x00081000 ` 

![image-20250627155149702](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627155149702.png)

同样 利用门进行跳转

> 注意，用门进行跳转的时候，只需要指定段选择子而不用给出后面的虚拟地址进行修正，函数的地址，已经放到门的段描述符里面。

注意，如果被调函数打上的断点不是在内核态下，**那么在三环下的编译器就可以捕获到这个断点**，不会被内核态的dbg捕获，反之，如果被调函数处于内核态，那么其发出的中断信号只能在内核态下的dbg捕获。

`int 3` 是 x86/x64 架构中的一条**软中断指令**，专门用于**调试目的**（触发断点）

- **作用**：触发一个调试中断（Breakpoint Exception），使 CPU 暂停执行并进入调试器（如 OllyDbg、x64dbg、GDB）。
- **机器码**：`0xCC`（单字节指令，便于动态插入）。
- 行为：
  - CPU 执行到 `INT 3` 时，会暂停当前程序。
  - 调试器捕获该中断，并显示当前寄存器、内存状态等。

![image-20250627155806145](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627155806145.png)

![image-20250627160156734](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627160156734.png)

查看 内核态下和三环下 ESP内容发生了变化

![image-20250627160835491](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627160835491.png)

变化的内容

- ESP 
- EIP 这里保存着即将执行的指令地址  一定会变
- CS
- SS
- FS

前面提到过 **cs ss 一同改变，表明提权成功**  这里 cs的值是在门的段描述符里面的段选择子部分。

ss的值并未指定，这里是因为因特尔设立了一个默认值为cs的段选择子加8  即紧挨着cs的段描述符的后一个段描述符。

![image-20250627161543834](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627161543834.png)

这里的fs并不是调用门替换的  而是`INT 3 ` 替换的，这里`INT 3`这个指令 本质上会执行一个函数，这个函数之中有语句将fs进行替换。所以调试时，FS发生改变，并不是调用门这个机制的改变，而是`INT 3`对其进行的改变。

发生改变的部分，在返回的时候，就需要修复，不然在被调函数执行完成后，无法返回。

查看三环下的堆栈

![image-20250627162841681](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627162841681.png)

查看零环下的堆栈

![image-20250627163106951](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627163106951.png)

查看栈顶地址 指令的汇编

![image-20250627163240599](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627163240599.png)

可以看到在0x00401050调用的函数，其下一条指令地址为0x00401053即函数调用完成后的返回地址，所以零环下的栈中保存了返回地址以及0x001b 即原cs的段选择子。

**这里也体现出了因特尔的x86架构不是rics 即指令长短是不一致的。**

总结：

![image-20250627164628375](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627164628375.png)

JMP 

尝试使用jmp来进行提权。在逻辑上如果jmp能进入到内核态的话，那么在正确返回的时候retf会从内核栈中取出四个值 `ss esp cs retaddress`  因此我们需要将值通过调用门传递过去。注意，压栈的时候esp是第二个压，但是在返回的时候，retf会恢复esp为用户栈的栈顶地址，此时栈顶部分就是不匹配的，所以由于esp要压入四个值，可以先将其存入 eax中，并让eax加14（4*4）这样当eps恢复的时候就是对应的esp。

```c++
		mov eax,esp;
		add eax,16;
		push ss;
		push eax;
		push cs;
		push ret_point;
		jmp fword ptr kernal_addr;
```

但此时有一个问题就是，如果内核栈中不预先保存cs ss esp 等值的话，并不知道内核栈里面的数据是怎么样的，那么就需要去查看后才能恢复。

![image-20250629154816125](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250629154816125.png)

运行后发现并不能正确跳转，但如果把调用门中的段选择子改为用户态的话是可以正确跳转的，**所以这表明`jmp far `并不能提权。** 或者说远跳不能通过调用门来提权，因为调用门没有一次性替换CS和SS的机制，但远跳**可以通过任务段来提权**。

CALL

- 跨段不提权(仅改变cs的值)， 压入EIP CS 没有改变ESP
- 跨段提权(同时改变CS与SS)，替换ESP,并且在新的ESP中压入 EIP、CS、R3、ESP、SS
- retf 通过对比在被调函数中的CS、SS的值与 返回堆栈中CS的值SS的值进行对比。判断是同级跳转（R3->R3）还是降级跳转(R0->R3)，来判断是弹出16个字节还是弹出8个字节

前面说过，除了其他几个寄存器以外，还是FS在INT 3 指令下会修改，当调用retf的时候，并不会压入FS的值，所以也不会返回。**这里由于FS不可以在三环的权限下修改其值，所以要还原fs的值就要到零环里面去修改。**

![image-20250627165349953](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627165349953.png)

> tips:如果将在三环下的值压入栈中，后弹出到fs中是可以正确运行的，这表明，在对fs赋值前会先判断权限以及赋值与fs的值是否相同的一个验证。
>
> ![image-20250629122620266](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250629122620266.png)

我们可以先压入原来的FS的值，在dbg完成后，修改回来。

![image-20250627165605511](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627165605511.png)

> 注意 这里如果在call 前面打上断点的话，那么继续执行时是**单步调试**，单步调试可以看成是每一步前面都打上断点，也就是说跳转到push fs 时也会发出一个中断信号，凡中断dbg都是调用INT 3 这样的话相当于每次都会修改fs的值，会导致最后fs的值没有被恢复。
>
> 这里想要查看三环下的栈的内容的话可以在 call前面插入断点 并写上代码。

##### 调用门携带参数

将调用门的段描述符的参数字段改为2

![image-20250627170705369](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627170705369.png)

在三环下，将参数`0x11111111`  `0x12345678` 压入栈中

观察内核态下的栈

![image-20250627170739227](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627170739227.png)

![image-20250627170810317](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627170810317.png)

FS的值是在被调函数中压入的  也就是说正常的情况下，我们要取在三环压入栈的两个参数，就需要从栈顶往下8字节开始。 

注意 此时retf 返回会蓝屏  因为 retf不会识别有几个参数，或者说其默认值为0  也就是cs与esp之间没有字节需要跳过，直接返回会蓝屏

如果携带参数进去，应该在retf后面跟随上有几个字节的参数，例如两个参数就是8字节。

验证是否提权

编写一个结构体，大小为六字节，这里如果用一字节对齐的话，那这个结构体实际上由于字节对齐会变为八个字节

![image-20250627173248320](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627173248320.png)

在三环下，访问gdt表

![image-20250627173410766](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627173410766.png)

这里是保存表的地址，并对该地址进行 写入，运行后报错，表明权限不足

![image-20250627173515804](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627173515804.png)

在跨段提权后的函数test()中编写

![image-20250627174104715](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627174104715.png)

运行后在windbg中查看反汇编

![image-20250627174147476](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627174147476.png)

![image-20250627174223321](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627174223321.png)

对比在内核态在看到的gdt表的内容 与在用户态下看到的内容

![image-20250627174501657](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627174501657.png)

这个内容保存在全局变量里面

![image-20250627174518371](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627174518371.png)

相同，表明提权成功

> Question：retf 能否用于提权？
>
> 不能，retf 只能用于降权，同权限返回

### 中断门

#### IDT表(中断表)

`r idtr` 查看中断表首地址

![image-20250628104415034](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628104415034.png)

![image-20250628104643123](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628104643123.png)

这表明，不论是怎样的划分方式，**只要涉及到段描述符的部分都绕不开GDT表**

IDT中存的是一个又一个的函数

例如 `INT 3` 其中3表示索引，从IDT表的首地址开始从0开始编号，依次是0、1、2、3

![image-20250628105322419](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628105322419.png)

中断门的划分与调用门相同

![image-20250627151527290](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627151527290.png)

注意：前面可知 32bit中断门的type是E，并且，**中断门是没有参数的，即Param Count 字段全是0**。

这里的偏移地址部分，在调用门中是被调函数首地址，到中断门这就是中断函数的首地址。

#### INT 3

我们可以查看一下该函数的汇编

![image-20250628105807292](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628105807292.png)

可以得到 `INT 3` 调用的函数的汇编

这也验证了，在调用门的验证中，fs的值是由于调用了`INT 3` 才被改变的，并非是因为调用门这个机制会改变FS。

![image-20250628110106204](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628110106204.png)

> 调用汇编语句INT 3 和在调试器中打上断点的效果是一样的，即只要运行内核态函数，发出了断点信号，那么三环下的调试器就捕获不到中断信号，必须由内核态捕获。
>
> 调试器下断点是通过修改目标代码的指令，**临时将某条指令的第一个字节替换为 `0xCC`（`INT 3` 的机器码）。触发断点后，调试器会恢复原始指令。**
>
> `INT 3`是程序员在源代码或二进制中硬编码 `INT 3` 指令，直接触发软中断。断点永久存在于代码中，需手动修改代码文件。

所以两个发出中断信号后都会被内核态的捕获，且其本质是都是调用INT 3，所以在内核态下打断点，也会修改FS的值。

#### 异常

异常分为三类

- 终止

  - 出现了不可修复的异常

- 可修复错误

  - 通常内存产生的错误都是可修复的

    > 例如:
    >
    > 之前通过VirtualAlloc 申请了内存，这块内存所在的物理页没有被调用，只有首次访问的时候检测到缺页才会取调页。此时访问这块内存，就会出错，但是windows的内存管理器中（VAD）发现这个地址是申请过的，只是第一次申请出来的地址没有挂物理页，就会抛出页异常。但这种异常是可修复的，**微软会在执行这条语句前面打上断点。如果系统能够处理就继续执行，如果处理不了就会抛给用户。**
    >
    > [INT 3]mov eax,dword ptr ds:[0x12345678]
    >
    > nop
    >
    > movdword ptr ds:[0x12345678],eax

- 陷阱

  - 陷阱执行了以后，断点是断在下一行的。例如`INT 3`执行后，EIP在下一行。
  - 硬件断点，也是陷阱。但陷阱和陷阱门是没有关系的。

三个对应于错误(Fault) 中断（Interrupt）陷阱（Trap）  当看到Fault类型的中断的时候，表明是可以修复的。   终止（Abort），是外部中断。

![image-20250630150013478](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630150013478.png)

#### 中断

我们知道中断分为可屏蔽中断、不可屏蔽中断。**按由软件和硬件中断，又可分为中断与异常。**

CPU的硬件厂商，对系统厂商进行规定，要求将每个CPU上的引脚，通电以后调用的函数写入到中断表中

![image-20250628111118096](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628111118096.png)

中断和异常，在调用对应处理函数的时候都需要经过IDT表。前面所说的`INT 3`是由软件引起的，所以叫做异常。

部分函数的作用是由硬件厂商所预设的，下列表中就有部分中断调用函数的标准规定。例如3号就是下断点、0号是处理除零异常。

![image-20250628112451023](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628112451023.png)

IDT表中，前32个通常是被预设好了函数的，后面的标号可以系统进行自定义。

> tips: `INT 3` 与 `INT3`  `INT1`与`INT 1`
>
> 这两个语句中  编号分开写和编号合在一起写，效果上都是一样的，用于下断点
>
> 在上面的表中可以看到 `INT 1`是debug  其效果就是单步调试，那么这两个语句有什么不同吗?

![image-20250628113942323](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628113942323.png)

可以看到，其根本上的不同是所占的字节数不同  分开写是占两字节  合在一起写是占一字节。

**由于通常所见到的都是合在一起的写法，少见的是分开写的时候，如果在程序员不知道的情况下，用这种方式是可以去过掉检测的。**

#### 构建一个中断门

首先打印目标函数地址 `0x401000`

![image-20250627151527290](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250627151527290.png)构建一个门 DPL为三环  参数个数部分为0，其余的部分顺序填入，

结果为 `0x0040EE00 0x00081000`

段选择子是0x08 即在内核态下的cs段

查看IDT表，注意，不要写入到预设的部分。

这里 从`0x80b99500`到`0x80b99400`有`0x100`个字节，对应256byte，每个段描述符有8byte，刚好有32个段描述符，对应于前面所说的有32个预设的中断函数。

![image-20250628115725838](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628115725838.png)

往系统可自定义的部分写入构建好的中断门。

![image-20250628120535896](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628120535896.png)

如何返回？

查看一下内核态下压入栈的内容，看需要恢复的数据有多少

![image-20250628121138326](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628121138326.png)

可以看到压入了五个数据   esp是跳转前栈顶地址。 如果将efl看成参数（调用门中，cs和esp中间部分是压入的参数），那么就可以用`retf 4`返回，但同理，这样就恢复不了efl的内容。

- 用 `retf 4`返回 efl 的值未修复，看返回原因是回到主函数以后蓝屏

![image-20250628122810304](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628122810304.png)

在主函数先在栈中压入一个脏数据，然后在目标函数中手动修改efl的值

![image-20250628130701445](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628130701445.png)

运行 仍然蓝屏

![image-20250628130324603](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628130324603.png)

删除修改efl的汇编代码，即不修改efl，仍然蓝屏报错，说明直接用`retf 4`不能正确返回

![image-20250628130823789](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628130823789.png)

尝试将efl的值在内核栈中删去，只保留其余四个值，并在三环保存一份efl 让efl在回到主函数后恢复

![image-20250628131409949](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628131409949.png)

![image-20250628131709814](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628131709814.png)

记得每次重新打开dbg的时候都要重新构建门。

结果蓝屏

![image-20250628131924412](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628131924412.png)

![image-20250628132259312](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628132259312.png)

可以发现，需要恢复的不仅仅只有那几个位，windbg上用`u`命令查看汇编代码。

排查下来看是否是将pushf 改为对应的字节位 `pushfd` `popfd`否则 返回地址不正确

![image-20250628134135265](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628134135265.png)

验证 `pushf` 是否压入32bit的数据

![image-20250628135303812](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628135303812.png)

调试器中将pushf  在32bit环境下改为了pushfd，但在裸函数下并没有，所以代码中用pushf 只会压入16bit 导致内核栈中压入的返回地址错误。

排查fs的问题，将fs的值修改，变为在三环下解决。

![image-20250628134826519](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628134826519.png)

![image-20250628134920267](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628134920267.png)

##### 中断门的返回方式 `iret`

部分编译器会将iret翻译为16bit系统的返回，所以呢，最好在后面加上对应的系统字长

![image-20250628121940646](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628121940646.png)

同样  由于`INT 3`会修改fs，所以在调试的时候记得保存fs的值，否则无法正确返回。

![image-20250628122443364](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628122443364.png)

##### 实验 

将INT 3 中的函数hook住，即每次调用INT 3 时变为调用我们自己写的目标函数，注意并不是修改IDT表，而是将IDT表中3号被调函数的偏移地址值记录下来 

已知  目标线性地址 = 代码段.base + 虚拟地址   这里的偏移地址坐虚拟地址部分   我们要改的是cs的base部分  例如  目标代码段是401000  根据IDT表中的3号被调函数的偏移地址为0x83e4f5c0 可以得到base的地址为 7C5B1A40  将其改为cs的base地址，尝试将3号被调函数HOOK下来

![image-20250628140632516](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250628140632516.png)

这里需要注意，当跳入到目标函数的时候，cs的值是0x60，此后所执行的指令的线性地址都是错的，所以进入到目标函数后的第一件事就是将cs改为8

## INT 3 HOOK

### 查看INT 3 地址

有两种方式，一种是查看idt表，找到第3号段描述符，然后根据描述符的偏移地址来查找INT 3

第二种是通过命令`!idt 3`来查询，这个是windbg提供的指令。

![image-20250630110849936](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630110849936.png)

已知线性地址 = base + 偏移地址 

现在要hook掉INT 3，则线性地址是已知的，偏移地址就是INT 3的地址，用线性地址减去INT 3的地址，就可以得到base的地址，有了base的地址以后就可以构建INT3对应的段选择子对应的段描述符。

![image-20250630111424272](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630111424272.png)

INT 3原本选择的是0x08的段选择子，我们只修改其base部分，将0x08段描述符中的base地址，填充为我们计算好的base地址

![image-20250630112209942](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630112209942.png)

编写代码，在HOOK住INT 3了以后，想要跳转到正确的目标函数  需要重新计算正确的INT 3地址，

这里由于在躺平模式下，有base表的地址是0x00000000 所以INT 3的偏移地址就是INT 3的线性地址。就像前面所说的，当跳转到目标函数的时候，此时cs的内容是0x60，对应的段选择子的base地址是通过计算目标函数得来的，往后的代码涉及到用到cs寄存器的话，后面得到的目标地址都是错的。因此，进入到函数以后，应该要先恢复cs的值。

`jmp far` 会从栈顶读取``0x08`并加载到 cs

```bash
push 0x08         ; 段选择子（cs）入栈
push _haha        ; 偏移（eip）入栈
jmp fword ptr [esp] ; 从栈顶读取 cs:eip 并跳转
_haha:
add esp, 8        ; 清理栈（移除 0x08 和 _haha）
```

![image-20250630120350447](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630120350447.png)

> 思考，既然cs的值被改变了，那么为什么跳转过来以后可以正确执行修改cs的这几条语句呢?
>
> 我们知道英特尔的cpu由于不是采用的精简指令集(RISC)所以呢，每条指令的地址并不是由当前的地址加上指令字节数，而是通过cs段寄存器中的base表加上偏移地址计算得到最终地址。
>
> 那么，这里cs段中的base地址被改变了，往后的每一条指令的地址计算，如`push 0x08`
>
> 前面的由于要hook `INT 3`，因此呢将cs.base变为 `0x7C5A 5A40`，偏移地址为函数入口地址`0x401000`，得到push 0x08的地址应该是 cs.base + offset = 0x7C9A 6A40，但正确执行的时候，base部分应该是原本cs的值。

这里就涉及到**cpu的流水线技术**，不论是几级流水线，都会预取几条指令放在流水线寄存器中，然后寻址，访存，执行等。因此呢，当程序跳转到HOOK函数的时候，它已经取出这个函数内存区域的前几条指令放入到指令执行队列中，而不是通过cs计算每条指令的地址。通过cs计算每条指令的EIP仅有显示其地址的作用，实际的运行是从指令执行队列中取出指令来执行。

![image-20250630124644959](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630124644959.png)

在执行的过程中，预取的指令之中涉及到跳转、调用指令时就会跳转至目标内存区域继续读取指令，原先缓存好的指令就丢弃。

![image-20250630124835182](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630124835182.png)

![image-20250630112810316](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630112810316.png)

写入IDT 和GDT表

![image-20250630113209121](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630113209121.png)

此时运行会蓝屏。

这是因为windows的调试会在exe程序还没有运行的时候，先触发一次断点，这个断点叫系统断点。

![image-20250630113832205](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630113832205.png)

那么 由于我们先改写了IDT 和GDT，而这个断点下在函数编译之前，这样就会导致，跳转到的地址错误，导致蓝屏。![image-20250630114304305](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630114304305.png)

这里还有一个问题，如果通过esp寄存器进行修改，那么如果在程序执行的时候，发生了线程切换或者系统调用，原ESP的值会保存，但是[esp - 4] 的值是一定不会保存的，也就是说，执行远跳的时候，实际跳转的地址可能不一样。这样蓝屏的几率非常大

![image-20250630130101797](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630130101797.png)

修改代码，改为从寄存器中读取地址进行跳转。

![image-20250630115008650](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630115008650.png)

并且，直接打开生成好的exe文件，而不从调试器打开。成功捕获到INT 3 指令。

![image-20250630115113933](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630115113933.png)

### 验证

通过打印日志，来验证HOOK成功

### 加载ntdll模块

`lm`指令查看当前解析模块  `ld *` 加载所有能加载模块的符号

![image-20250630132021978](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630132021978.png)

`.reload`重新进行加载模块符号

![image-20250630132055571](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630132055571.png)

![image-20250630132106248](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630132106248.png)

`！process 0 0` 遍历所有进程 ，注意**零环下是没有进程的**，所以这里遍历的自然是三环下的进程。

![image-20250630133114211](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630133114211.png)

`.process /i 进程ID` 切换到目标进程  并**断下**

![image-20250630133230541](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630133230541.png)

`.reload ntdll.dll` 重新加载模块

![image-20250630133322040](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630133322040.png)

查看 ntdll加载成功

![image-20250630133534304](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630133534304.png)

通过ascii码排序，会此时查看DbgPrint的汇编代码，优先显示ntdll。因此呢，查看时需要带上模块名前缀。

![image-20250630133837491](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630133837491.png)

查看DbgPrint的内存地址。

![image-20250630130806879](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630130806879.png)

- 调用DbgPrint函数来打印日志

![image-20250630130510489](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630130510489.png)

这里的语法含义是将该地址强转为这个函数

![image-20250630141026157](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630141026157.png)

随意输入一个字符串，调用函数。注意，调用内核态的函数需要保存fs的值。

![image-20250630140944589](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630140944589.png)

对于函数 要注意其**调用约定**

![image-20250630130510489](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630130510489.png)

该函数的调用约定是CD CALL  其特征是外平衡而不是内平衡。需要在外部给它平衡堆栈，顾名思义，内平衡就是函数在内部自己平衡堆栈。

![image-20250630141709673](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630141709673.png)

所以呢，在调用完成之后，将堆栈平衡

DbgPrint 前面加上`typedef`

![image-20250630141947397](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630141947397.png)

打开DbgView，并勾选。

![image-20250630142013076](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630142013076.png)

打印成功，表明HOOk成功。

![image-20250630142138316](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250630142138316.png)

## efl的划分

![image-20250701171912575](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701171912575.png)





## 任务段

**任务** 是硬件厂商提供的一个概念，其含义和线程差不多，即**一个进程可以有多个任务，但是由于其存在绑定过深、消耗内存等原因**，软件厂商并没有使用任务这个描述。

- 绑定深
  - 硬件厂商更新换代、那么软件厂商就必须跟着换

- 消耗内存
  - 每创建一个任务就会往GDT表中写入一个段描述符，不适合于现代的软件要求（有1000个任务就会有1000个段描述符写入GDT表)
  
- 任务切换影响效率

  - 任务的切换每次都要求提供对应的寄存器的值

    ![image-20250701141008452](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701141008452.png)

    如果不进行任务的切换，那么CPU一个核就只能执行一个任务，效率大幅降低

  - 并且，每一个任务段就需要至少104个字节来保存，这样就会大量的消耗的内存空间。


### 任务段的段描述符的划分

![image-20250701143634015](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701143634015.png)

  查看GDT表里面的段描述符

  tr是一个段寄存器，其段选择子指向任务段

  str 获取当前任务段 选择子

  ltr 加载任务段 

![image-20250701142125404](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701142125404.png)

  `dg 段选择子`  可以自动解析段选择子

![image-20250701142556058](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701142556058.png)

  任务段TSS的type有**Busy**和**Available**两种对应于空闲和忙碌两种状态

![image-20250701143015516](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701143015516.png)

如果跳转到一个Busy状态的任务段会失败。

`dt _KTSS`由ntdll模块里面提供的一个可查看任务段切换所需的一个结构体。

![image-20250701144131212](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701144131212.png)

- `Backlink`
  - 记录从哪一个任务段跳转而来的一个链接
  - `iret`指令
    - 如果eflgs.NT = 1 就按照Backlink返回到之前任务段的状态
    - 如果eflgs.NT =  1 就按照堆栈返回

![image-20250701144606451](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701144606451.png)

> 中断门和陷阱门 在被调用以后会将efl的NT TF IF VM 位清空
>
> 任务段由于可能要用Backlink返回，就不会去清空NT位
>
> NT ：任务嵌套位，主导iret的返回
>
> TF：调试单步位
>
> IF：可屏蔽中断位
>
> VM：虚拟8086模式

任务段1跳转到任务段2时，会将原本的环境和状态（寄存器数据）**保存在任务段1里面**。

如何明确跳转到任务段2?

当任务段1执行的时候，保存EIP等寄存器信息，然后将任务段2的EIP、ESP等替换到当前的寄存器中，实现从任务段1到任务段2的跳转。

其中Backlink是系统维护的，而其余的EIP等等，可以自己构建。

#### base 

任务段的base中保存的是一个结构

查看0x28段base的一个结构

![image-20250701151710571](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701151710571.png)

里面原有的一些寄存器数据是没有意义的，只有当这个段执行了以后，跳转到新的段时，保存了的旧任务段执行的数据才有意义。

Backlink = 0 表明没有嵌套任务，当前的任务就是主任务。



验证

根据_KTSS 构建一个数据结构

![image-20250701141008452](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701141008452.png)

![image-20250701153123401](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701153123401.png)

- 构建_KiIoAccessMap

![image-20250701153249026](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701153249026.png)

- 构建_KTSS

0x00a~0x00b两字节是预留的，可以直接合并到Ss0段

![image-20250701153716211](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701153716211.png)

![image-20250701154105163](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701154105163.png)

根据标准的任务段配置表可以看到，从ESP0到CR3 中间还有SS0 ESP1 SS1 ESP2 SS2 将大小和字节数添加进KTSS表中

![image-20250701154322325](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701154322325.png)

定义了4字节大小就将原来的预留部分全部删去

![image-20250701154617978](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701154617978.png)

定义完成了以后，看看一下结构体所占的大小与Windbg所显示的大小是否一致。

![image-20250701155032038](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701155032038.png)

![image-20250701155311013](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701155311013.png)

排查下来是前面的结构体中变量类型错了

![image-20250701155507354](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701155507354.png)

![image-20250701155818022](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701155818022.png)

由于要保存ESP 申请两块堆栈内存

![image-20250701160150048](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701160150048.png)

同样，在运行时清空，避免申请的内存没有挂物理页

![image-20250701161419012](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701161419012.png)

对于通用寄存器可以任意赋值，Cs、Ss赋值在零环下的值，其中IoMapBase为KTSS的大小（这个可以观察tr寄存器的KTSS结构体得到）

![image-20250701161605968](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701161605968.png)

对于栈 我们申请了两个页大小的全局变量，那么就是在堆上分配的

![image-20250701161835274](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701161835274.png)

> 在分配的时候是有小地址到大地址进行分配例如地址从`0x1235000`到`0x1237000`，但是栈的逻辑是从大地址往小地址递减，也就是分配了一块内存，那么ESP指向栈顶也就是大地址，当变量压入栈的时候ESP往上走，这样从逻辑上与栈是相同的。

在代码中，我们先在堆中申请了一块内存，如果给ESP这块内存的首地址，那从栈的逻辑上就会出错，因此呢将大地址给ESP并往上走几个内存，防止在大地址的时候ESP出栈，跑到别的程序的内存里面了。

![image-20250701162442322](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701162442322.png)

由于程序需要运行起来，系统才会分配CR3 所以呢需要在运行过程中给CR3赋值，不然无法得到程序的CR3

跳转部分的地址构造是一样的，给CS赋值，需要跳转的地址是CS段选择子里面的任务段。

![image-20250701162636576](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701162636576.png)

![image-20250701162554300](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701162554300.png)

![image-20250701162911769](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701162911769.png)

根据我们自己构造的TSS表构造一块任务段，写入到0x60段中。

然后在运行的过程中遍历进程

![image-20250701163112095](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701163112095.png)

这里呢由于用的是中文字符的程序名，所以呢在遍历的进程名中大概率是乱码

![image-20250701163220157](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701163220157.png)

查看`DirBase`字段，就可以得到给进程分配的CR3，输入

发现成功断下，表明任务段切换成功。

![image-20250701163334649](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701163334649.png)



- 查看tr 发现tr变化为跳转的任务段

![image-20250701170824847](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701170824847.png)

- 且变为busy状态

![image-20250701170734870](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701170734870.png)

查看base的结构数据，发现Backlink确实由系统维护成上一个任务段的tr，`0x28`

![image-20250701171113596](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701171113596.png)

查看跳转到新的任务段了以后，寄存器是否发生改变

![image-20250701171348413](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701171348413.png)

这里需要注意的是  切换任务段取得是新的任务段的ESP，切换线程的时候取得是ESP0。前面的中断门，调用门提权的时候，ESP的取值就是从任务段中取的ESP0。

- 观察原来的段tr = 0x28的值
  - 发现旧的段保存了我们代码执行到的一个EIP，查看EIP发现确实是我们自己编写的代码
    - 这就验证了，切换任务段的时候确实是将新的任务段的EIP和ESP取过来，并且将旧的环境保存在任务段里面

![image-20250701173924591](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701173924591.png)

注意观察，这里efl的值，前面的代码部分，我们并没有给efl赋值。那么这里的efl就是由系统维护的。

根据efl的划分可以看到`0x00004002`  刚好NT位为1

![image-20250701171912575](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701171912575.png)

前面提到过，中断门会重置NT位，导致这里`iret`指令默认从堆栈返回。这样返回会系统会报错，且是硬件方面的错误。

![image-20250701172310701](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701172310701.png)

观察新任务段的堆栈，发现并没有保存上一个段的值，如果INT 3 清空了NT位，那么自然就会返回到一个错误的位置。

![image-20250701172635772](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701172635772.png)

在`INT 3` 之后  重新恢复NT的值

![image-20250701173650965](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701173650965.png) 

此时返回还会出现一个内存方面的错误

![image-20250701174239503](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701174239503.png)

其原因是系统没有给我们保存旧的任务段的CR3的值，而默认的CR3的值为0，导致从Backlink返回的时候，会将0赋值给CR3没有赋值成功，就会出现一个访问内存的错误。

![image-20250701174427444](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701174427444.png)

我们需要在运行的时候，手动写入CR3到旧的段。

![image-20250701174513953](./%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.assets/image-20250701174513953.png)

- 这里是从_KTSS 的基址偏移1c 为CR3 的值。
