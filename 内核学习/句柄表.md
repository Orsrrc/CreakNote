# 句柄表

## 全局句柄表

只包含了进程和线程的内容

**通过PID**可以计算出该进程的句柄所在的**句柄表的索引值**，然后由**索引**到句柄表中**拿到进程的句柄**。

![image-20250807142914831](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807142914831.png)

查看`PsLookupProcessByProcessId`函数，该函数传入进程ID，返回进程对象

![image-20250807143027539](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143027539.png)

往下看，可以看到它调用了`ExMapHandleToPointer`函数，该函数返回一个句柄结构，该结构的首地址为进程对象，将进程对象放入到V3中然后返回。

![image-20250807143057956](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143057956.png)

其中**PspCidTable就是全局句柄表**。

我们查看一个该函数

![image-20250807143551042](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143551042.png)

![image-20250807143625708](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143625708.png)

我们查看一下系统中的全局句柄表结构

![image-20250807143932572](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143932572.png)

其中TableCode字段的低位，表示有几层句柄表结构

![image-20250807144656782](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807144656782.png)

当其低位为0时，代表该地址直接指向一张句柄表。为1时加上一级句柄表，为2时加上二级句柄表。

其地址指向最上层句柄。

我们如果将其低位直接去掉，例如系统的句柄存放结构是一个存在一级句柄表的结构，我们直接去掉低位，拿到的是一级句柄表的首地址

![image-20250807145125345](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807145125345.png)

全局句柄表中，每个句柄地址只有一个属性，该属性为地址的最低位（1bit），该位表示锁位，如果该位为0，运行会卡死。

可以看到通过索引拿取句柄的时候，会对句柄的最低位进行判断。

![image-20250807145638365](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807145638365.png)

手动计算句柄表索引

### Win7 x32

我们拿到一个进程ID以后（PID）首先需要计算它在哪个表里面。

并且PID以4为单位进行增长，这点在x64下也是一样，因此我们要计算其索引即计算其在整个系统里面的句柄的排名需要先除以4。拿到一个序号

一个句柄表的大小为4KB，在x86下一个句柄占8字节，那么一张句柄表可以存放512个句柄。

对应着，句柄的序号整除于512拿到其在哪一张句柄表里面。句柄的序号取模与512，拿到在句柄表中的序号。

例如：dwm.exe的PID为1324，1324/4  = 331   331/512 = 0  331%512 = 331

得到它的句柄索引为，第0号表的第331个位置。

验证：第一张句柄表的地址`0x8AC04000`，索引为14b，一个句柄占8字节

拿到其地址以后，可以得到一个句柄结构`_HANDLE_TABLE_ENTRY`，其首地址为进程的对象，减去1，得到完整的EPROCESS地址。

![image-20250807152127181](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807152127181.png)

成功找到

![image-20250807152411064](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807152411064.png)

但是在全局句柄表里面，既有线程句柄由有进程句柄，如何才能分辨一个句柄是线程句柄还是进程句柄呢？

法一：查看对象头。一个进程的对象头在EPROCESS的前面

在x86下为0x18个字节，在x64下为x030个字节（因为x64的地址大小是x86的两倍，因此其对象头结构大小也是它的两倍）

![image-20250807153026927](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153026927.png)

可以看到它的TypeIndex字段为0x7，表示为进程对象

![image-20250807153210605](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153210605.png)

法二

查看EPROCESS的KPROCESS结构，它的内核进程头部分有一个结构`DISPATCHER_HEADER`

![image-20250807153308078](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153308078.png)

对应的Type字段为0x3，代表进程

![image-20250807153410585](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153410585.png)

验证

1.通过导出的函数`ObGetObjectType`获取类型

![image-20250807154217731](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807154217731.png)

通过该函数我们也可以从入口地址加字节的方式拿到ObTypeIndexTable

![image-20250807155235662](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807155235662.png)

可以看到第7个位置为进程类型，8为线程类型

![image-20250807155331469](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807155331469.png)



### Win7 x64

同理，在x64下由于一个句柄占16字节，因此一个4KB的句柄表里面能存放256个句柄。

tips:在修改完

Windbg的字体以后，保存工作环境，下次打开时就可以不用在修改

![image-20250807160804014](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160804014.png)

例如：取PID2572

PID /4  = 643  643 / 256 = 2 表示在2号句柄表  643 % 256 = 131，即句柄的索引为131

![image-20250807161114195](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161114195.png)

同样，进程TableCode - 1

![image-20250807160832746](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160832746.png)



![image-20250807160933989](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160933989.png)

减去1

![image-20250807161034314](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161034314.png)

查找成功

查看其对象头中的TYPE，在x86中，对象头占0x30个字节

![image-20250807161449469](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161449469.png)

![image-20250807161009791](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161009791.png)

同样，解析type为7是什么类型

![image-20250807161409027](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161409027.png)

### Win10

任意找一个进程ID

![image-20250807163308924](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163308924.png)

计算索引：

10228 / 4 = 2557

x64下句柄表有256项

2557 / 256 = 9

2557 % 256 = 253

获取句柄表位置

![image-20250807163705191](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163705191.png)



![image-20250807163721120](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163721120.png)

![image-20250807163756494](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163756494.png)

注意，这里拿到的句柄是被加密过后的句柄，观察其特征发现并不是以FF开头

我们逆向一下Win10下的PID查找进程的函数

![image-20250807163820002](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163820002.png)

进入到函数`PspReferenceCidTableEntry`以后看到它对传入的句柄进行了运算。

![image-20250807163950464](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163950464.png)

我们拿到的句柄值末尾为0，那么就只用右移16位即可，与上`FFFFFFFFFFFFFFF0`与原本的值相同

![image-20250807164052048](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164052048.png)

成功查找

![image-20250807164215568](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164215568.png)

我们来看一下句柄的类型，拿到对象头以后，看到其Type为2

![image-20250807164246596](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164246596.png)

查看一下类型表，并且解析结构

![image-20250807164329413](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164329413.png)

发现是Type类型，这表明它对这句柄的类型也进行了加密

![image-20250807164340329](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164340329.png)

我们来逆向查看一下Win10下的获取对象类型的函数

![image-20250807164506180](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164506180.png)

```
movzx ecx, byte ptr [rcx-18h]
```

rcx里面保存着EPROCESS的首地址，减去18h，可以看到是对象头的TypeIndex字段



![image-20250807164955479](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164955479.png)

```
shr rax, 8
movzx eax, al
```

它将rax右移8位以后，取最低的一个字节。rax是对象头的首地址，我们看到本进程的对象头地址右移8位以后取最低一个字节也就是30h

![image-20250807164724726](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164724726.png)

```
movzx ecx, byte ptr cs:ObHeaderCookie
```

取系统代码段的ObHeaderCookie的第一个字节，我们看到是35h

![image-20250807165058821](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807165058821.png)



```
lea rcx, ObTypeIndexTale
mov rax, [rcx+rax*8]
```

获取类型表，然后取对应的类型到rax中，这也就表明，此时已经解密成功，解密的值放在rax中。



计算一下  

rcx = eprocess rax = objecthead

eax = 30h  ecx_1 = 2 ecx_2 = 35h 

其中， Win10下

>### 1. **RCX / RAX（64位）**
>
>- **RCX**（64位）：完整的 64 位寄存器。
>- **RAX**（64位）：完整的 64 位累加器寄存器。
>
>### 2. **ECX / EAX（32位）**
>
>- **ECX**（32位）：`RCX` 的低 32 位。
>- **EAX**（32位）：`RAX` 的低 32 位。
>
>### 3. **CX / AX（16位）**
>
>- **CX**（16位）：`ECX` 的低 16 位（即 `RCX` 的 16-31 位）。
>- **AX**（16位）：`EAX` 的低 16 位（即 `RAX` 的 16-31 位）

```
xor rax, rcx
```

它们两个异或，其实就是eax与ecx的异或，因为他们是在同一个进程结构里面，两个相差的大小为一个头的大小30h

30h  ^2h ^  35h = 7这才是正确的索引值

![image-20250807171105842](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807171105842.png)

可以看到，它是进程句柄

![image-20250807171126219](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807171126219.png)



作业：

1.遍历全局句柄表

2.通过句柄表实现进程的保护

例如 我们取一个我们要保护的进程PID7884

计算 7884 / 4 =1971   1971/256 = 7  1971 % 256 = 179

![image-20250807172230968](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172230968.png)

在全局句柄表里面找到该句柄以后，将其置为0

![image-20250807172354931](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172354931.png)

![image-20250807172420638](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172420638.png)

此时我们发现从任务管理器中无法关闭进程

![image-20250807172427349](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172427349.png)

由于许多API调用进程都需要通过句柄来实现，因此，我们在全局句柄表中删除或者修改为别的进程的句柄表，都可以实现保护的作用。



### 句柄查找

#### Win10

将手动计算的方式写成算法，可以成功查找。但是效率比Windows内部自己实现的效率低，因此，我们用Windows内部的算法来实现句柄的查找。

前面看过，句柄查找所调用的函数是`PsLookupProcessByProcessId`，该函数内部对函数所在的句柄表的查询进行了实现，我们可以直接复制ida的翻译代码，然后进行修改。

![image-20250809150020720](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809150020720.png)

分析一下变量地址，它拿到句柄表表以后取对应的TableCode，那么也就是首地址加上8字节偏移

![image-20250809155329364](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155329364.png)



![image-20250809155428506](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155428506.png)

![image-20250809155535974](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155535974.png)

```c
return (PVOID)(*(PULONG_PTR)(*(PILONG_PTR)(TableCode + 8 * (Value >> 19) - 2) + 8 * ((Value >> 0xA) & 0x1FF)) + 4 * (value & 0x3FF));
```

运行以后拿到的是加密过后的地址，我们右移10位得到其解密后的地址

![image-20250809155827890](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155827890.png)

查找成功

![image-20250809155919743](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155919743.png)

#### win7

我们将相同的代码拿到win7 x64下去运行

结果蓝屏报错，在其蓝屏分析部分会提示蓝屏的代码行，我们从最上面的代码开始修改

![image-20250809160056557](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809160056557.png)

查看win7下的该函数的算法

![image-20250809160147858](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809160147858.png)



![image-20250809161432942](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161432942.png)

![image-20250809161419942](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161419942.png)

成功查找

![image-20250809161354952](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161354952.png)



修改win10算法代码，兼容到win7中

![image-20250809161938861](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161938861.png)







## 私有句柄表

在进程的结构里面有一个成员名叫`ObjectTable`。

它的类型为Ptr HANDLE_TABLE，即这是一张句柄表，并且是进程内部的私有句柄表。

进程的私有句柄表，主要用于保存进程自身所打开的子进程的句柄，或者是孙子进程的句柄

![image-20250809162310199](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809162310199.png)

`OpenProcess`

第一个参数表示以什么权限打开

我们可以看到`PROCESS_ALL_ACCESS`由三个类别宏组成

![image-20250809165842584](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809165842584.png)

第二个参数表示是否允许子进程继承句柄

![image-20250809162318047](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809162318047.png)



私有句柄表的地址转换和全局句柄表相同，只不过私有句柄表是每个进程都有一份，而全局句柄表是共享的句柄表。

我们任意打开一个进程（优先自己编写的exe，某些系统exe对权限有所要求）

![image-20250809171140602](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171140602.png)

可以看到进程的句柄是24h，并且格式为%p，即进程在句柄表中的索引为24h。

![image-20250809170405058](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809170405058.png)

24h / 4 = 9h , 拿到句柄表里面的索引，一个句柄16字节，那么就得到偏移地址

![image-20250809171023835](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171023835.png)

拿到句柄，我们可以看到句柄低4bit位为3。

句柄的划分

私有句柄表里面的句柄有三个标志位

分别为：

- 是否允许关闭句柄
- 是否允许子进程继承父进程的句柄
- 锁位



### 继承

我们在上面的代码中将被打开的继承参数为1，那么这里的句柄表低4bit为3.

而在创建一个子进程的时候，它的参数中也有一个标记，表示是否继承父进程的句柄。

![image-20250809171539589](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171539589.png)

我们再来看私有句柄表，可以发现，一个进程的私有句柄表的表项中包含其打开进程的句柄，以及打开的权限。

![image-20250809171725683](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171725683.png)

可以看到在openProcess中所定义的权限进行组合即为0x1FFFFF，刚好就是句柄表中的表项的组成（8字节句柄 + 8 字节权限）

![image-20250809170112649](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809170112649.png)



验证子进程是否能够继承父进程句柄

CreateProcess的创建标记我们定义为`CREATE_NEW_CONSOLE`，创建新的控制台进程。

![image-20250809172131958](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172131958.png)

然后通过CE，搜索一下进程dwm.exe，并且输入进程到地址里面查找进程的入口地址`FF340000`.该地址为我们需要读取内存的地址

![image-20250809172207294](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172207294.png)

读取其内存，放入到缓冲区中。创建进程时，传入该地址。

![image-20250809172226099](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172226099.png)

![image-20250809172246814](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172246814.png)

运行后发现，其子进程的句柄不同

![image-20250809173655657](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809173655657.png)

查看其句柄表，可以看到其子进程、孙子进程所继承的句柄表。

![image-20250809174030385](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809174030385.png)

我们在打开进程的时候不允许子进程继承父进程句柄。此时子进程仍然能打开进程，因为初始的进程打开dwm.exe，其句柄永远是24h，而24h已经写死在代码中。

![image-20250809174216802](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809174216802.png)

![image-20250809173627298](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809173627298.png)

#### 继承的作用

**在三环下**，某些进程对自生有保护，这导致了CE或者是调用OpenProcess去打开进程失败。要么是权限不够，要么打开看到的进程内存字节为`？？`

在系统中每个进程创建时会被`csrss.exe`、`lass.exe`这种进程打开，这类进程在系统中含有一定的特权，如果系统中的进程不被这类进程打开句柄，可能会报错，于是我们就能够在这两个进程中找到我们需要的目标进程的句柄。

![image-20250809182853179](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182853179.png)

我们打开ce以后，可以看到里面有ce的句柄

![image-20250809182920893](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182920893.png)

当然，如果找不到也没有关系，我们可以注入到这`csrss.exe`**这类进程**以后再去打开目标进程。然后将其句柄设置为可被继承的权限。然后由被注入的进程来创建一个新的进程，这个新的进程继承父进程的所有句柄，我们就可以在我们自己创建的进程里面拿到**目标进程的句柄**。

不依赖于驱动。

对于特权进程的句柄的遍历，可以采用暴力枚举的方式进行，或者用API。

调用QueryProcessInformation，查询句柄表以及句柄表内容，并且可以查找句柄类型、进程名等等



### 句柄关闭

函数`SetHandleInformation`，将其标志位设置为不可以通过closeHandle函数来关闭句柄。

![image-20250809182332922](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182332922.png)

![image-20250809182538266](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182538266.png)

![image-20250809182519991](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182519991.png)

此时进程仍然能够正常的读取其内存

![image-20250809182751795](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182751795.png)



运行发现，关闭句柄后无法读取对应的内存

![image-20250809182646225](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182646225.png)









## 私有句柄表VS全局句柄表

全局句柄表存的是句柄实体

私有句柄表存的是对象头

我们用私有句柄表里面存放的句柄去掉末尾的标志位以后去解析进程结构

![image-20250809183015075](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183015075.png)

发现查找的文件名是错误的

![image-20250809183056480](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183056480.png)

此时拿到的是进程对象头地址，在x64下进程对象头占30hB，我们加上以后查看

![image-20250809183136210](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183136210.png)

查找成功

![image-20250809183234324](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183234324.png)