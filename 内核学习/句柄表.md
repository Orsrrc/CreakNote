# 句柄表

## 全局句柄表

只包含了进程和线程的内容

**通过PID**可以计算出该进程的句柄所在的**句柄表的索引值**，然后由**索引**到句柄表中**拿到进程的句柄**。

![image-20250807142914831](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807142914831.png)

查看`PsLookupProcessByProcessId`函数，该函数传入进程ID，返回进程对象

![image-20250807143027539](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143027539.png)

往下看，可以看到它调用了`ExMapHandleToPointer`函数，该函数返回一个句柄结构，该结构的首地址为进程对象，将进程对象放入到V3中然后返回。

![image-20250807143057956](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143057956.png)

其中**PspCidTable就是全局句柄表**。

我们查看一个该函数

![image-20250807143551042](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143551042.png)

![image-20250807143625708](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143625708.png)

我们查看一下系统中的全局句柄表结构

![image-20250807143932572](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143932572.png)

其中TableCode字段的低位，表示有几层句柄表结构

![image-20250807144656782](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807144656782.png)

当其低位为0时，代表该地址直接指向一张句柄表。为1时加上一级句柄表，为2时加上二级句柄表。

其地址指向最上层句柄。

我们如果将其低位直接去掉，例如系统的句柄存放结构是一个存在一级句柄表的结构，我们直接去掉低位，拿到的是一级句柄表的首地址

![image-20250807145125345](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807145125345.png)

全局句柄表中，每个句柄地址只有一个属性，该属性为地址的最低位（1bit），该位表示锁位，如果该位为0，运行会卡死。

可以看到通过索引拿取句柄的时候，会对句柄的最低位进行判断。

![image-20250807145638365](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807145638365.png)

手动计算句柄表索引

### Win7 x32

我们拿到一个进程ID以后（PID）首先需要计算它在哪个表里面。

并且PID以4为单位进行增长，这点在x64下也是一样，因此我们要计算其索引即计算其在整个系统里面的句柄的排名需要先除以4。拿到一个序号

一个句柄表的大小为4KB，在x86下一个句柄占8字节，那么一张句柄表可以存放512个句柄。

对应着，句柄的序号整除于512拿到其在哪一张句柄表里面。句柄的序号取模与512，拿到在句柄表中的序号。

例如：dwm.exe的PID为1324，1324/4  = 331   331/512 = 0  331%512 = 331

得到它的句柄索引为，第0号表的第331个位置。

验证：第一张句柄表的地址`0x8AC04000`，索引为14b，一个句柄占8字节

拿到其地址以后，可以得到一个句柄结构`_HANDLE_TABLE_ENTRY`，其首地址为进程的对象，减去1，得到完整的EPROCESS地址。

![image-20250807152127181](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807152127181.png)

成功找到

![image-20250807152411064](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807152411064.png)

但是在全局句柄表里面，既有线程句柄由有进程句柄，如何才能分辨一个句柄是线程句柄还是进程句柄呢？

法一：查看对象头。一个进程的对象头在EPROCESS的前面

在x86下为0x18个字节，在x64下为x030个字节（因为x64的地址大小是x86的两倍，因此其对象头结构大小也是它的两倍）

![image-20250807153026927](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153026927.png)

可以看到它的TypeIndex字段为0x7，表示为进程对象

![image-20250807153210605](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153210605.png)

法二

查看EPROCESS的KPROCESS结构，它的内核进程头部分有一个结构`DISPATCHER_HEADER`

![image-20250807153308078](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153308078.png)

对应的Type字段为0x3，代表进程

![image-20250807153410585](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153410585.png)

验证

1.通过导出的函数`ObGetObjectType`获取类型

![image-20250807154217731](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807154217731.png)

通过该函数我们也可以从入口地址加字节的方式拿到ObTypeIndexTable

![image-20250807155235662](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807155235662.png)

可以看到第7个位置为进程类型，8为线程类型

![image-20250807155331469](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807155331469.png)



### Win7 x64

同理，在x64下由于一个句柄占16字节，因此一个4KB的句柄表里面能存放256个句柄。

tips:在修改完

Windbg的字体以后，保存工作环境，下次打开时就可以不用在修改

![image-20250807160804014](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160804014.png)

例如：取PID2572

PID /4  = 643  643 / 256 = 2 表示在2号句柄表  643 % 256 = 131，即句柄的索引为131

![image-20250807161114195](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161114195.png)

同样，进程TableCode - 1

![image-20250807160832746](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160832746.png)



![image-20250807160933989](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160933989.png)

减去1

![image-20250807161034314](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161034314.png)

查找成功

查看其对象头中的TYPE，在x86中，对象头占0x30个字节

![image-20250807161449469](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161449469.png)

![image-20250807161009791](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161009791.png)

同样，解析type为7是什么类型

![image-20250807161409027](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161409027.png)

### Win10

任意找一个进程ID

![image-20250807163308924](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163308924.png)

计算索引：

10228 / 4 = 2557

x64下句柄表有256项

2557 / 256 = 9

2557 % 256 = 253

获取句柄表位置

![image-20250807163705191](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163705191.png)



![image-20250807163721120](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163721120.png)

![image-20250807163756494](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163756494.png)

注意，这里拿到的句柄是被加密过后的句柄，观察其特征发现并不是以FF开头

我们逆向一下Win10下的PID查找进程的函数

![image-20250807163820002](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163820002.png)

进入到函数`PspReferenceCidTableEntry`以后看到它对传入的句柄进行了运算。

![image-20250807163950464](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163950464.png)

我们拿到的句柄值末尾为0，那么就只用右移16位即可，与上`FFFFFFFFFFFFFFF0`与原本的值相同

![image-20250807164052048](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164052048.png)

成功查找

![image-20250807164215568](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164215568.png)

我们来看一下句柄的类型，拿到对象头以后，看到其Type为2

![image-20250807164246596](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164246596.png)

查看一下类型表，并且解析结构

![image-20250807164329413](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164329413.png)

发现是Type类型，这表明它对这句柄的类型也进行了加密

![image-20250807164340329](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164340329.png)

我们来逆向查看一下Win10下的获取对象类型的函数

![image-20250807164506180](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164506180.png)

```
movzx ecx, byte ptr [rcx-18h]
```

rcx里面保存着EPROCESS的首地址，减去18h，可以看到是对象头的TypeIndex字段



![image-20250807164955479](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164955479.png)

```
shr rax, 8
movzx eax, al
```

它将rax右移8位以后，取最低的一个字节。rax是对象头的首地址，我们看到本进程的对象头地址右移8位以后取最低一个字节也就是30h

![image-20250807164724726](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164724726.png)

```
movzx ecx, byte ptr cs:ObHeaderCookie
```

取系统代码段的ObHeaderCookie的第一个字节，我们看到是35h

![image-20250807165058821](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807165058821.png)



```
lea rcx, ObTypeIndexTale
mov rax, [rcx+rax*8]
```

获取类型表，然后取对应的类型到rax中，这也就表明，此时已经解密成功，解密的值放在rax中。



计算一下  

rcx = eprocess rax = objecthead

eax = 30h  ecx_1 = 2 ecx_2 = 35h 

其中， Win10下

>### 1. **RCX / RAX（64位）**
>
>- **RCX**（64位）：完整的 64 位寄存器。
>- **RAX**（64位）：完整的 64 位累加器寄存器。
>
>### 2. **ECX / EAX（32位）**
>
>- **ECX**（32位）：`RCX` 的低 32 位。
>- **EAX**（32位）：`RAX` 的低 32 位。
>
>### 3. **CX / AX（16位）**
>
>- **CX**（16位）：`ECX` 的低 16 位（即 `RCX` 的 16-31 位）。
>- **AX**（16位）：`EAX` 的低 16 位（即 `RAX` 的 16-31 位）

```
xor rax, rcx
```

它们两个异或，其实就是eax与ecx的异或，因为他们是在同一个进程结构里面，两个相差的大小为一个头的大小30h

30h  ^2h ^  35h = 7这才是正确的索引值

![image-20250807171105842](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807171105842.png)

可以看到，它是进程句柄

![image-20250807171126219](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807171126219.png)



作业：

1.遍历全局句柄表

2.通过句柄表实现进程的保护

例如 我们取一个我们要保护的进程PID7884

计算 7884 / 4 =1971   1971/256 = 7  1971 % 256 = 179

![image-20250807172230968](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172230968.png)

在全局句柄表里面找到该句柄以后，将其置为0

![image-20250807172354931](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172354931.png)

![image-20250807172420638](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172420638.png)

此时我们发现从任务管理器中无法关闭进程

![image-20250807172427349](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172427349.png)

由于许多API调用进程都需要通过句柄来实现，因此，我们在全局句柄表中删除或者修改为别的进程的句柄表，都可以实现保护的作用。



### 句柄查找

#### Win10

将手动计算的方式写成算法，可以成功查找。但是效率比Windows内部自己实现的效率低，因此，我们用Windows内部的算法来实现句柄的查找。

前面看过，句柄查找所调用的函数是`PsLookupProcessByProcessId`，该函数内部对函数所在的句柄表的查询进行了实现，我们可以直接复制ida的翻译代码，然后进行修改。

![image-20250809150020720](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809150020720.png)

分析一下变量地址，它拿到句柄表表以后取对应的TableCode，那么也就是首地址加上8字节偏移

![image-20250809155329364](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155329364.png)



![image-20250809155428506](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155428506.png)

![image-20250809155535974](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155535974.png)

```c
return (PVOID)(*(PULONG_PTR)(*(PILONG_PTR)(TableCode + 8 * (Value >> 19) - 2) + 8 * ((Value >> 0xA) & 0x1FF)) + 4 * (value & 0x3FF));
```

运行以后拿到的是加密过后的地址，我们右移10位得到其解密后的地址

![image-20250809155827890](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155827890.png)

查找成功

![image-20250809155919743](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809155919743.png)

#### win7

我们将相同的代码拿到win7 x64下去运行

结果蓝屏报错，在其蓝屏分析部分会提示蓝屏的代码行，我们从最上面的代码开始修改

![image-20250809160056557](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809160056557.png)

查看win7下的该函数的算法

![image-20250809160147858](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809160147858.png)



![image-20250809161432942](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161432942.png)

![image-20250809161419942](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161419942.png)

成功查找

![image-20250809161354952](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161354952.png)



修改win10算法代码，兼容到win7中

![image-20250809161938861](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809161938861.png)







## 私有句柄表

在进程的结构里面有一个成员名叫`ObjectTable`。

它的类型为Ptr HANDLE_TABLE，即这是一张句柄表，并且是进程内部的私有句柄表。

进程的私有句柄表，主要用于保存进程自身所打开的子进程的句柄，或者是孙子进程的句柄

![image-20250809162310199](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809162310199.png)

`OpenProcess`

第一个参数表示以什么权限打开

我们可以看到`PROCESS_ALL_ACCESS`由三个类别宏组成

![image-20250809165842584](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809165842584.png)

第二个参数表示是否允许子进程继承句柄

![image-20250809162318047](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809162318047.png)



私有句柄表的地址转换和全局句柄表相同，只不过私有句柄表是每个进程都有一份，而全局句柄表是共享的句柄表。

我们任意打开一个进程（优先自己编写的exe，某些系统exe对权限有所要求）

![image-20250809171140602](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171140602.png)

可以看到进程的句柄是24h，并且格式为%p，即进程在句柄表中的索引为24h。

![image-20250809170405058](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809170405058.png)

24h / 4 = 9h , 拿到句柄表里面的索引，一个句柄16字节，那么就得到偏移地址

![image-20250809171023835](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171023835.png)

拿到句柄，我们可以看到句柄低4bit位为3。

句柄的划分

私有句柄表里面的句柄有三个标志位

分别为：

- 是否允许关闭句柄
- 是否允许子进程继承父进程的句柄
- 锁位



### 继承

我们在上面的代码中将被打开的继承参数为1，那么这里的句柄表低4bit为3.

而在创建一个子进程的时候，它的参数中也有一个标记，表示是否继承父进程的句柄。

![image-20250809171539589](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171539589.png)

我们再来看私有句柄表，可以发现，一个进程的私有句柄表的表项中包含其打开进程的句柄，以及打开的权限。

![image-20250809171725683](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809171725683.png)

可以看到在openProcess中所定义的权限进行组合即为0x1FFFFF，刚好就是句柄表中的表项的组成（8字节句柄 + 8 字节权限）

![image-20250809170112649](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809170112649.png)



验证子进程是否能够继承父进程句柄

CreateProcess的创建标记我们定义为`CREATE_NEW_CONSOLE`，创建新的控制台进程。

![image-20250809172131958](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172131958.png)

然后通过CE，搜索一下进程dwm.exe，并且输入进程到地址里面查找进程的入口地址`FF340000`.该地址为我们需要读取内存的地址

![image-20250809172207294](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172207294.png)

读取其内存，放入到缓冲区中。创建进程时，传入该地址。

![image-20250809172226099](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172226099.png)

![image-20250809172246814](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809172246814.png)

运行后发现，其子进程的句柄不同

![image-20250809173655657](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809173655657.png)

查看其句柄表，可以看到其子进程、孙子进程所继承的句柄表。

![image-20250809174030385](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809174030385.png)

我们在打开进程的时候不允许子进程继承父进程句柄。此时子进程仍然能打开进程，因为初始的进程打开dwm.exe，其句柄永远是24h，而24h已经写死在代码中。

![image-20250809174216802](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809174216802.png)

![image-20250809173627298](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809173627298.png)

#### 继承的作用

**在三环下**，某些进程对自生有保护，这导致了CE或者是调用OpenProcess去打开进程失败。要么是权限不够，要么打开看到的进程内存字节为`？？`

在系统中每个进程创建时会被`csrss.exe`、`lass.exe`这种进程打开，这类进程在系统中含有一定的特权，如果系统中的进程不被这类进程打开句柄，可能会报错，于是我们就能够在这两个进程中找到我们需要的目标进程的句柄。

![image-20250809182853179](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182853179.png)

我们打开ce以后，可以看到里面有ce的句柄

![image-20250809182920893](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182920893.png)

当然，如果找不到也没有关系，我们可以注入到这`csrss.exe`**这类进程**以后再去打开目标进程。然后将其句柄设置为可被继承的权限。然后由被注入的进程来创建一个新的进程，这个新的进程继承父进程的所有句柄，我们就可以在我们自己创建的进程里面拿到**目标进程的句柄**。

不依赖于驱动。

对于特权进程的句柄的遍历，可以采用暴力枚举的方式进行，或者用API。

调用QueryProcessInformation，查询句柄表以及句柄表内容，并且可以查找句柄类型、进程名等等



### 句柄关闭

函数`SetHandleInformation`，将其标志位设置为不可以通过closeHandle函数来关闭句柄。

![image-20250809182332922](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182332922.png)

![image-20250809182538266](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182538266.png)

![image-20250809182519991](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182519991.png)

此时进程仍然能够正常的读取其内存

![image-20250809182751795](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182751795.png)



运行发现，关闭句柄后无法读取对应的内存

![image-20250809182646225](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809182646225.png)









## 私有句柄表VS全局句柄表

全局句柄表存的是句柄实体

私有句柄表存的是对象头

我们用私有句柄表里面存放的句柄去掉末尾的标志位以后去解析进程结构

![image-20250809183015075](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183015075.png)

发现查找的文件名是错误的

![image-20250809183056480](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183056480.png)

此时拿到的是进程对象头地址，在x64下进程对象头占30hB，我们加上以后查看

![image-20250809183136210](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183136210.png)

查找成功

![image-20250809183234324](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250809183234324.png)





## 句柄降权

通过调用OpenProcess去打开句柄的时候，我们需要给予一定量的权限，将句柄在系统中的权限标志修改或删去，实现降权。



在CE中打开dwm.exe然后查看它的句柄为0x514，在WinDbg中拿到CE的私有句柄表，然后找到该句柄。514h/4 = 145h，256对应着0x100，那么该句柄在第二个句柄表中

![image-20250810164443783](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810164443783.png)

![image-20250810164803534](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810164803534.png)

将其右移10位解密

![image-20250810164830906](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810164830906.png)

确认是该进程以后，将私有句柄表中的该句柄的权限位置为零。

![image-20250810164910531](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810164910531.png)

此时从CE看到的dwm.exe的内存全部是??

![image-20250810164949750](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810164949750.png)

此时由于只进行了一次降权，那么CE再次打开该进程，新的句柄仍然有对应的权限。

通过代码不断的编写循环，进行降权，可以实现对进程的保护。(游戏公司的保护逻辑也是这样)



找到指定的进程，用其句柄去降权。

![image-20250810170115130](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810170115130.png)

![image-20250810170106012](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810170106012.png)

没找到时没有释放句柄，进行修改。

![image-20250810171118970](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810171118970.png)

拿到进程的句柄以后，获取其句柄表。

对于一个没有导出的函数，可以按下x看有没有一个导出的函数去调用它，如果有就可以先拿到该导出函数的地址，然后取特征码拿到那个没有导出的函数的地址。

![image-20250810171839754](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810171839754.png)

找到一个导出的函数，该函数调用了那个没有被导出的函数

![image-20250810172024232](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810172024232.png)



![image-20250810172046904](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810172046904.png)

于是，我们拿到该函数以后，遍历其硬编码，只要找到第一个call指令，后面就是该函数的入口地址。



对于我们要获取的导出的目标函数，可以对其函数名进行加密。这里可以用火哥的工具，也可以自己写一个。

![image-20250810173044707](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810173044707.png)



![image-20250810173317945](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810173317945.png)

定义一个函数指针

![image-20250810172954203](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810172954203.png)

用该指针来存放我们找到的那个未导出的函数的地址

![image-20250810173442055](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810173442055.png)



对于修改句柄的函数，由于是要跑一个死循环，那么就需要用一个线程去跑，不可能让主线程去一直卡在死循环里面。

![image-20250810174257854](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810174257854.png)

在PsCreateSystemTHread函数里面，需要指出线程的入口函数，其结构为KSTART_ROUTINE，我们将其参数和返回值进行复制，函数名可以用自己的。

![image-20250810174518046](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810174518046.png)

另外，我们在主线程执行完以后，需要结束自线程的死循环。因此，可以用一个标志位来表示是否结束循环。在主线程执行卸载驱动的函数的时候修改，此时需要主线程延迟卸载驱动，因为在主线程修改标志位以后，子线程很有可能还在循环中，如果主线程先一步卸载了驱动，导致本进程的内存不存在，子线执行时很有可能蓝屏。

![image-20250810174747271](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810174747271.png)

![image-20250810174807010](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810174807010.png)



由于主线程子线程的执行情况、顺序未知。因此，两个线程的延迟时间差尽量大一点。

对于进程名，我们最好是在详细信息栏里面去确认一下。因为大多软件做系统的兼容，使得我们打开的进程的作用为选择器，不同的版本会打开不同版本的进程。而版本的选择，由选择器来完成。

![image-20250810175906027](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810175906027.png)

![image-20250810175620538](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810175620538.png)

在子线程中，我们查找到进程以后，调用函数获取其私有句柄表。拿到私有句柄表以后，我们需要遍历句柄。

遍历句柄需要调用函数`ExEnumHandleTable`该函数是导出的，但没有文档化



![image-20250810181921804](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810181921804.png)

![image-20250810182155666](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810182155666.png)



通常来说，对某一进程进行保护，是遍历系统中的所有进程，对非必要进程的私有句柄表进行降权。

![image-20250810182222707](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810182222707.png)

在遍历句柄的函数中先判断了锁位，如果没有锁，就跳出循环，然后调用回调函数

![image-20250810201403697](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810201403697.png)

![image-20250810201327065](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810201327065.png)

可以看到，**在枚举函数里面的逻辑是让我们传入的回调函数来判断是否是我们要找的句柄。如果回调函数返回真，就退出循环**。

![image-20250810182501841](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810182501841.png)

但是在实际运行中，由于别的进程打开别的进程时就会在自己的私有句柄表中保存一份句柄，有部分进程对重复打开的进程的句柄会进行关闭，但我们如果是对某一进程进行保护，就不能这么做。如果只对私有句柄表中的一个句柄进行降权，那么**如果该进程通过别的句柄进行操作，就会导致我们降权永远不成功**。因此，**我们所传入的回调函数永远返回false，让该函数遍历完所有的句柄，对满足要求的句柄进行降权**。

我们来看一下`_HANDLE_TABLE_ENTRY`，该结构的首元素为对象头

![image-20250810184545854](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810184545854.png)

在KTHREAD结构里面，其首元素为DISPATHCH_HEADER中有type位，当其值为3h时表示为进程。

![image-20250810184614667](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810184614667.png)

由于我们所保护的目标进程名比较短(小于15个字节），因此可以用短名字来判断该对象。

![image-20250810184642214](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810184642214.png)



![image-20250810185624549](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810185624549.png)

找到进程以后，直接将其标志位置为0.

![image-20250810201934840](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810201934840.png)

![image-20250810185648502](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810185648502.png)

此时运行以后，进程卡死

![image-20250810185717528](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810185717528.png)

其原因是，在函数内部会对`VolatileLowValue`的值进行循环减一，当该值减为零或者小于零时会卡死

![image-20250810195916860](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195916860.png)



对于这种调用函数的问题，我们可以看一下系统在调用的时候是怎么调用的，然后自己用相同的方法调用。

在函数的回调函数部分可以看到在`ObpEnumFindHandleProcedure`函数里面对该值进行了加一

![image-20250810195819208](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195819208.png)



往上看 这里的v10是该函数内部自己定义的，并不是对传入参数的处理，因此我们不同类比修改。

![image-20250810195644032](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195644032.png)

接着，当`value`有值的时候，会加一个PushLock

![image-20250810195456852](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195456852.png)

该函数是一个导出的函数，同样没有文档化

![image-20250810195545701](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195545701.png)

![image-20250810200537702](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810200537702.png)



![image-20250810195514194](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195514194.png)

打上断点单步调试，我们会发现在回调的时候，传入的参数和句柄的位置他们的值是相反的，通过其回调函数我们也可以看到格式应该是这样

![image-20250810195335479](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195335479.png)

![image-20250810201622904](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810201622904.png)



![image-20250810195247621](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810195247621.png)

这里还有一个问题是_stricmp函数在对比的时候，由于`PsGetProcessIMageFileName`函数返回的是字符串，并且该字符串没有以\0结尾，导致其在比较的时候由于没有结束符，就会一直读取字节直至越界。在内核态读一个不存在的内存会导致蓝屏。

![image-20250810202204199](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810202204199.png)

tips：在调试过程中通过修改中断为90可以删除该断点

![image-20250810200656668](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810200656668.png)

成功循环降级

![image-20250810200708497](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810200708497.png)



![image-20250810200736535](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250810200736535.png)



在实际过程中，由于对进程的句柄降权保护是扫描全部的进程的，因此其速度没有那么快，在运行过程中通常是打开的瞬间可以看到内存，在一两秒以后会变成问号。

如何破局

随便复制一个进程，将CR3改成被检测进程，再找到保护被检测进程的那个进程，将其打开的句柄的对象改成我的对象。此时它打开的进程就是一个假的进程，但是内存还是被检测进程的。但是名字、ID、对象指针与被检测的不同。

由于我们在保护的时候是通过判断句柄中的进程对象的进程名是否与我们的目标进程的进程名相同来进行保护的。那么就可以利用这一点，修改我们打开的进程的句柄的进程对象的内容，该进程对象里面的内存指向的是被保护进程的一块内存，但是对象的名字、类型与检测的不同，就可以绕过检测。



这种情况下，由于CR3是被检测进程的，因此，通过OD、CE等调试器是可以看到其真实的情况的。对于这种调试器，我们可以专门为期做一个插件，当打开调试器时，会自动调用该插件，hook`OpenProcess`等函数，让它打开一个不在句柄表里面的句柄，并且hook住所有的与该调试器相关的函数例如读写内存等等。这样可以使得调试器等失效。利用该方式，可以不走句柄调试了。



如果检测进程对比CR3，那么我们可以让CR3与其正常的CR3不同，我们将CR3所指向的物理页复制过来，形成不同的CR3，但是内存里面的内容是相同的，这样一种情况