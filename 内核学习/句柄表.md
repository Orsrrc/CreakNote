# 句柄表

## 全局句柄表

只包含了进程和线程的内容

**通过PID**可以计算出该进程的句柄所在的**句柄表的索引值**，然后由**索引**到句柄表中**拿到进程的句柄**。

![image-20250807142914831](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807142914831.png)

查看`PsLookupProcessByProcessId`函数，该函数传入进程ID，返回进程对象

![image-20250807143027539](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143027539.png)

往下看，可以看到它调用了`ExMapHandleToPointer`函数，该函数返回一个句柄结构，该结构的首地址为进程对象，将进程对象放入到V3中然后返回。

![image-20250807143057956](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143057956.png)

其中**PspCidTable就是全局句柄表**。

我们查看一个该函数

![image-20250807143551042](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143551042.png)

![image-20250807143625708](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143625708.png)

我们查看一下系统中的全局句柄表结构

![image-20250807143932572](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807143932572.png)

其中TableCode字段的低位，表示有几层句柄表结构

![image-20250807144656782](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807144656782.png)

当其低位为0时，代表该地址直接指向一张句柄表。为1时加上一级句柄表，为2时加上二级句柄表。

其地址指向最上层句柄。

我们如果将其低位直接去掉，例如系统的句柄存放结构是一个存在一级句柄表的结构，我们直接去掉低位，拿到的是一级句柄表的首地址

![image-20250807145125345](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807145125345.png)

全局句柄表中，每个句柄地址只有一个属性，该属性为地址的最低位（1bit），该位表示锁位，如果该位为0，运行会卡死。

可以看到通过索引拿取句柄的时候，会对句柄的最低位进行判断。

![image-20250807145638365](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807145638365.png)

手动计算句柄表索引

### Win7 x32

我们拿到一个进程ID以后（PID）首先需要计算它在哪个表里面。

并且PID以4为单位进行增长，这点在x64下也是一样，因此我们要计算其索引即计算其在整个系统里面的句柄的排名需要先除以4。拿到一个序号

一个句柄表的大小为4KB，在x86下一个句柄占8字节，那么一张句柄表可以存放512个句柄。

对应着，句柄的序号整除于512拿到其在哪一张句柄表里面。句柄的序号取模与512，拿到在句柄表中的序号。

例如：dwm.exe的PID为1324，1324/4  = 331   331/512 = 0  331%512 = 331

得到它的句柄索引为，第0号表的第331个位置。

验证：第一张句柄表的地址`0x8AC04000`，索引为14b，一个句柄占8字节

拿到其地址以后，可以得到一个句柄结构`_HANDLE_TABLE_ENTRY`，其首地址为进程的对象，减去1，得到完整的EPROCESS地址。

![image-20250807152127181](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807152127181.png)

成功找到

![image-20250807152411064](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807152411064.png)

但是在全局句柄表里面，既有线程句柄由有进程句柄，如何才能分辨一个句柄是线程句柄还是进程句柄呢？

法一：查看对象头。一个进程的对象头在EPROCESS的前面

在x86下为0x18个字节，在x64下为x030个字节（因为x64的地址大小是x86的两倍，因此其对象头结构大小也是它的两倍）

![image-20250807153026927](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153026927.png)

可以看到它的TypeIndex字段为0x7，表示为进程对象

![image-20250807153210605](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153210605.png)

法二

查看EPROCESS的KPROCESS结构，它的内核进程头部分有一个结构`DISPATCHER_HEADER`

![image-20250807153308078](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153308078.png)

对应的Type字段为0x3，代表进程

![image-20250807153410585](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807153410585.png)

验证

1.通过导出的函数`ObGetObjectType`获取类型

![image-20250807154217731](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807154217731.png)

通过该函数我们也可以从入口地址加字节的方式拿到ObTypeIndexTable

![image-20250807155235662](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807155235662.png)

可以看到第7个位置为进程类型，8为线程类型

![image-20250807155331469](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807155331469.png)



### Win7 x64

同理，在x64下由于一个句柄占16字节，因此一个4KB的句柄表里面能存放256个句柄。

tips:在修改完

Windbg的字体以后，保存工作环境，下次打开时就可以不用在修改

![image-20250807160804014](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160804014.png)

例如：取PID2572

PID /4  = 643  643 / 256 = 2 表示在2号句柄表  643 % 256 = 131，即句柄的索引为131

![image-20250807161114195](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161114195.png)

同样，进程TableCode - 1

![image-20250807160832746](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160832746.png)



![image-20250807160933989](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807160933989.png)

减去1

![image-20250807161034314](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161034314.png)

查找成功

查看其对象头中的TYPE，在x86中，对象头占0x30个字节

![image-20250807161449469](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161449469.png)

![image-20250807161009791](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161009791.png)

同样，解析type为7是什么类型

![image-20250807161409027](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807161409027.png)

### Win10

任意找一个进程ID

![image-20250807163308924](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163308924.png)

计算索引：

10228 / 4 = 2557

x64下句柄表有256项

2557 / 256 = 9

2557 % 256 = 253

获取句柄表位置

![image-20250807163705191](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163705191.png)



![image-20250807163721120](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163721120.png)

![image-20250807163756494](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163756494.png)

注意，这里拿到的句柄是被加密过后的句柄，观察其特征发现并不是以FF开头

我们逆向一下Win10下的PID查找进程的函数

![image-20250807163820002](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163820002.png)

进入到函数`PspReferenceCidTableEntry`以后看到它对传入的句柄进行了运算。

![image-20250807163950464](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807163950464.png)

我们拿到的句柄值末尾为0，那么就只用右移16位即可，与上`FFFFFFFFFFFFFFF0`与原本的值相同

![image-20250807164052048](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164052048.png)

成功查找

![image-20250807164215568](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164215568.png)

我们来看一下句柄的类型，拿到对象头以后，看到其Type为2

![image-20250807164246596](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164246596.png)

查看一下类型表，并且解析结构

![image-20250807164329413](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164329413.png)

发现是Type类型，这表明它对这句柄的类型也进行了加密

![image-20250807164340329](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164340329.png)

我们来逆向查看一下Win10下的获取对象类型的函数

![image-20250807164506180](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164506180.png)

```
movzx ecx, byte ptr [rcx-18h]
```

rcx里面保存着EPROCESS的首地址，减去18h，可以看到是对象头的TypeIndex字段



![image-20250807164955479](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164955479.png)

```
shr rax, 8
movzx eax, al
```

它将rax右移8位以后，取最低的一个字节。rax是对象头的首地址，我们看到本进程的对象头地址右移8位以后取最低一个字节也就是30h

![image-20250807164724726](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807164724726.png)

```
movzx ecx, byte ptr cs:ObHeaderCookie
```

取系统代码段的ObHeaderCookie的第一个字节，我们看到是35h

![image-20250807165058821](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807165058821.png)



```
lea rcx, ObTypeIndexTale
mov rax, [rcx+rax*8]
```

获取类型表，然后取对应的类型到rax中，这也就表明，此时已经解密成功，解密的值放在rax中。



计算一下  

rcx = eprocess rax = objecthead

eax = 30h  ecx_1 = 2 ecx_2 = 35h 

其中， Win10下

>### 1. **RCX / RAX（64位）**
>
>- **RCX**（64位）：完整的 64 位寄存器。
>- **RAX**（64位）：完整的 64 位累加器寄存器。
>
>### 2. **ECX / EAX（32位）**
>
>- **ECX**（32位）：`RCX` 的低 32 位。
>- **EAX**（32位）：`RAX` 的低 32 位。
>
>### 3. **CX / AX（16位）**
>
>- **CX**（16位）：`ECX` 的低 16 位（即 `RCX` 的 16-31 位）。
>- **AX**（16位）：`EAX` 的低 16 位（即 `RAX` 的 16-31 位）

```
xor rax, rcx
```

它们两个异或，其实就是eax与ecx的异或，因为他们是在同一个进程结构里面，两个相差的大小为一个头的大小30h

30h  ^2h ^  35h = 7这才是正确的索引值

![image-20250807171105842](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807171105842.png)

可以看到，它是进程句柄

![image-20250807171126219](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807171126219.png)



作业：

1.遍历全局句柄表

2.通过句柄表实现进程的保护

例如 我们取一个我们要保护的进程PID7884

计算 7884 / 4 =1971   1971/256 = 7  1971 % 256 = 179

![image-20250807172230968](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172230968.png)

在全局句柄表里面找到该句柄以后，将其置为0

![image-20250807172354931](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172354931.png)

![image-20250807172420638](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172420638.png)

此时我们发现从任务管理器中无法关闭进程

![image-20250807172427349](./%E5%8F%A5%E6%9F%84%E8%A1%A8.assets/image-20250807172427349.png)

由于许多API调用进程都需要通过句柄来实现，因此，我们在全局句柄表中删除或者修改为别的进程的句柄表，都可以实现保护的作用。