# 驱动









## VS2019环境配置

对于单纯的驱动程序(.sys)来说，运行在哪个平台都是适用的，但若是debug环境的话就会有版本限制，vs2022以上，没有Win32的debug环境，因此，编写驱动最好用2019

- 将配置类型改为Driver，默认情况下，生成的Driver项目其配置类型就是Driver，但若修改，就会发现无法再次在下拉框里面选择Driver选项，**此时可以手动输入Driver**

![image-20250712105529231](./驱动.assets/image-20250712105529231.png)

在创建一个.c文件以后，才会出现C/C++的一个选项。

![image-20250712105925030](./驱动.assets/image-20250712105925030.png)



输入驱动程序的入口格式，并编译，发现报错，缺少库，以及默认情况下驱动是用于开发嵌入式软件的，因此，我们需要关闭部分选项。

![image-20250712110025235](./驱动.assets/image-20250712110025235.png)

![image-20250712110718987](./驱动.assets/image-20250712110718987.png)

`DbgPrintEx`作用类似于C里面的printf.



注意在搜索栏里面搜索SP（Spectre Mitigation）

![image-20250712110158959](./驱动.assets/image-20250712110158959.png)



![image-20250712110219685](./驱动.assets/image-20250712110219685.png)

![image-20250712110240379](./驱动.assets/image-20250712110240379.png)



![image-20250712110254280](./驱动.assets/image-20250712110254280.png)



![image-20250712110312090](./驱动.assets/image-20250712110312090.png)





![image-20250712110325869](./驱动.assets/image-20250712110325869.png)



![image-20250712110341324](./驱动.assets/image-20250712110341324.png)



生成sys成功，将sys放入虚拟机中，打开DebugView，关闭选项

![image-20250712110419533](./驱动.assets/image-20250712110419533.png)

打开驱动管理.exe，成功执行

![image-20250712110509342](./驱动.assets/image-20250712110509342.png)



## 驱动程序入口

在标准的C里面，Main函数是带有三个参数的，包括命令个数，命令字符串，环境。在默认情况下是可以没有参数的。

但是驱动的程序入口的两个参数是必须的



在Windows中每一个驱动，都有一个驱动对象，有没有真实的物理设备没有关系

将驱动编译为.sys才是DriverEntry 这个入口点，如果编译为.dll运行的话 是可以没有驱动对象的。

![image-20250712112221950](./驱动.assets/image-20250712112221950.png)



.dll 不能直接加载驱动，它能在A驱动引用了B.dll中的函数的时候，如果B.dll没有被加载，才会被动的被加载进去，而.sys能够主动的去加载驱动



PUNICODE_STRING 是在内核态下常用的传递字符串参数的数据结构。在内核态下，传递字符串的时候，通常不会传字面量"123"，或者是用指针char* ，而是传入这样一个完整的数据结构体。

![image-20250712112836542](./驱动.assets/image-20250712112836542.png)

![image-20250712113412436](./驱动.assets/image-20250712113412436.png)

通常，一个字符串在末尾时会多保存一个结束符\0，如果没有这个结束符，例如，将一个int类型，强制转为字符串去打印，**由于没有这个结束符，就会打印乱码**。

而在内核态下，**这样操作很有可能会导致蓝屏**，因此，**会使用一个变量来记录当前字符串的长度**。避免读取内存的时候产生溢出。这样，**在读取的时候就不需要关注字符串是否要以零结尾，而只用关注字符串的长度，根据长度就可以取到字符串。**

注意，字符串的长度其含义是字符串所占的字节数，而不是字符串字符的个数，也就是说当用宽字符来存储时L"1"，其字符串长度为两字节，而如果是窄字符"1"，其字符串长度为一字节.

![image-20250712115112535](./驱动.assets/image-20250712115112535.png)



`PUNICODE_STRING pRegUn` 参数含义：传入驱动路径

DbgBreakPoint() 下断点

![image-20250712115333778](./驱动.assets/image-20250712115333778.png)



修改了以后，重新载入。

![image-20250712122109943](./驱动.assets/image-20250712122109943.png)

在Windbg下成功捕获断点

![image-20250712122155434](./驱动.assets/image-20250712122155434.png)

`dt pRegUn`可以解析一下这个结构体，能够看到在其Buffer部分有一段地址，该地址以REGISTRY开头，表明这是一个注册表结构。

![image-20250712122253161](./驱动.assets/image-20250712122253161.png)

`regedit`命令查看注册表

根据路径可以查看到注册表地址，在对应的注册表下面有一个ImagePath，可以查看sys表

![image-20250712120304694](./驱动.assets/image-20250712120304694.png)

- type = 1 代表驱动
- start 代表以什么方式启动
  - 0、1、2 代表开机自启
  - 0 在bios的时候就启动
  - 1 在Windows的加载界面启动
  - 2 登录用户后启动

由于**加载驱动与组相关**，那么在注册表这里修改Start，是没有用的。

查找组加载顺序列表：

找到一个带有Group的注册表，复制里面的数据，去查找，能够找到GroupOrderList，这样一个列表，里面存放着所有的启动顺序

![image-20250712122449953](./驱动.assets/image-20250712122449953.png)

在这个加载列表里面可以认为是一组启动优先级，例如一个注册表的Group值属于Base 那么就要比Boot Bus Extender 的驱动加载要早。

![image-20250712122611283](./驱动.assets/image-20250712122611283.png)

如果在同一组下，Start 为0的要比Start为1、2的要早。

如果是同组，同start的情况下，那么注册表的排列顺序就是执行的顺序，在Windows下的命名，数字开头的永远比字母开头的排列在前面，因此数字要比字母的注册表启动得快(360的软件命名，在这里体现出其流氓本质)。

验证：

在驱动部分新增一项Group，注意其值为REG_SZ，否则不会生效，将组改为Boot Bus Extender，再将Start改为1。重新启动。

![image-20250712123157410](./驱动.assets/image-20250712123157410.png)

Windbg成功捕获断点，表明开机启动成功。

![image-20250712123339296](./驱动.assets/image-20250712123339296.png)

那么怎么样能够使得同组同Start的情况下，字母命名要比数字命名快呢？

我们可以将GroupList里面的注册表复制一份，然后删除，自己添加一份注册表然后插入原本的注册表，这样就使得我们手动添加的组在所有组的前面，这样就可以让自己的驱动组优先级最高。

**简而言之就是自己手动添加一个组，将本身的组优先级再调高一点，可以保证本身的程序优先级最高**。并且，如果将驱动加载以后，用驱动（零环）去修改组注册表是永远不会出发杀毒软件，或者是微软的Defender程序的，而如果用（三环）去修改，很有可能会被拦截。

tips:

> 病毒的编写逻辑：
>
> 1.加载完驱动后隐藏
>
> 2.删除注册表，以及驱动本身
>
> 3.注册关机回调，写回注册表

> 程序的注册步骤，本质上来讲就是将我们编写的驱动写入到注册表里面，因此这一步是可以我们手动来完成的，直接在注册表里面创建一个键，将我们驱动的路径写入进去。
>
> ![image-20250712123908370](./驱动.assets/image-20250712123908370.png)
>
> 而运行，就是将服务启动
>
> API启动方式：API调用NtLoadDriver
>
> 服务启动方式：StartService  == （命令行启动方式）net start day01(注册表键)
>
> 



`PDRIVER_OBJECT pDriver`驱动对象结构

![image-20250712124814514](./驱动.assets/image-20250712124814514.png)

type用于区分对象类型

type = 4 就是驱动对象

type = 3就是设备对象



一个驱动有了设备才会便于去调用，反之，如果没有那么是很难去调用到的

这里的设备本质上来说是Windows提供的一个通信方式

通过设备读取设备信息。

DeviceObject 设备信息，可以用于绑定物理设备

Flags 驱动运行时产生的报错信息等

DriverStrart  运行时驱动模块位置

DriverExtension.ServiceKeyName 这里的名字是注册表键的名字，而不是显示的名字即

类似于`REGISTRY\MACHINE\HARIWARE\Service\day01` 这样的一个名字，注册表所在文件夹的名字

![image-20250712125736234](./驱动.assets/image-20250712125736234.png)

DriverName 驱动名字，便于通过API查找驱动对象

HardwareDatabase 硬件数据库

FastIoDispatch 用于快速调用

DriverInit 驱动入口点地址

可以看到，实际生成程序的时候，并不是直接运行程序的Main函数，系统对其进行了部分的封装，进行部分安全措施的保护后，才跳转到我们的Main函数。

![image-20250712130106625](./驱动.assets/image-20250712130106625.png)

DriverUnload 卸载函数的回调

MajorFuncion  IO 对象的回调



## 变量类型

`int -> INT`

`unsigned int = UINT`

`char->CHAR`

`long->LONG`

`unsigned long = ULONG`

`short->SHORT`

`wchar == SHORT`

`void -> VOID`

`ULONG64`

`LONG64`

`UINT_PTR` 类似一个宏，当在不同的环境下，例如x32位下就是一个32bit的类型。做x32与x64兼容的程序可以用这个。



RtlUnicodeStringToAnsiString



NTSTATUS 4B的数字  即错误码的数字，用于监测调用函数API是否成功。其本质就是判断，函数返回的状态值是否大于零，大于零表示成功加载。

![image-20250712131118455](./驱动.assets/image-20250712131118455.png)



.CPP与.C

由于驱动对入口程序有严格的命名要求，因此，如果是.cpp文件，在编译的时候会将我们的函数名字编译为`DroverEntry@upDriverUNXXXXXx...`

此时，对于驱动程序就会编译不过，因为它不能找到我们的程序入口地址。

解决的方法有

指定编译的程序入口名

![image-20250712133347760](./驱动.assets/image-20250712133347760.png)

添加关键字`extern "C"` ，在驱动里面对这部分关键字也进行了封装`EXTERN_C`

![image-20250712133311226](./驱动.assets/image-20250712133311226.png)

![image-20250712133501680](./驱动.assets/image-20250712133501680.png)

![image-20250712133435889](./驱动.assets/image-20250712133435889.png)



## 字符串

- unicode 宽字符
-  ascll-code 窄字符

在驱动下面，一些标C的字符串操作函数还是可以用的，例如`strcat`，对于ACll-CODE，大部分的函数是可以用的，但对于UNICODE 只有部分可用。

### 初始化字符串

- Unicode

调用API`RtlInitUnicodeString` 其本质上就是给字符串结构体的三个值赋值

```\
name.Length = wcslen(L"1111111") * 2; //宽字符一个字符占2字节
name.Buffer = L"111111";
name.MaximumLength = wcslen(L"1111111") * 2;
```

![image-20250713105251519](./驱动.assets/image-20250713105251519.png)

- ASCICODE

可以看到 ANSI_STRING 本质上是STRING的别名

![image-20250713105552811](./驱动.assets/image-20250713105552811.png)

那么调用API`RtlINitAnsiString`与`RtlInitString`是相同的作用

![image-20250713105624998](./驱动.assets/image-20250713105624998.png)

tips:

在查看一些陌生的API的时候，可以看一下参数的前缀，例如\_Out_ 就代表这个参数用来保存输出的数据，\_IN_就代表这个参数需要用户提供给API，\_OPT\_代表option，可选择的，也就是用户可以选择是否提供，如果不提供就输入NULL。

那么对于_In\_opt\_这样的组合，就表明是用户可选提供输入参数

![image-20250713105826440](./驱动.assets/image-20250713105826440.png)

### 窄字符转宽字符

调用API`RtlAnsiStringToUnicodeString()`

可以看到这个函数的返回值是NTSTATUS，也就是说可以通过返回值查看是否调用API成功。

前两个\_When_ 可以看成是一个宏，该两个宏是简单描述这个函数是干什么用的，

`DestinationString`即用于保存转换后的字符串，`SourceString`就是源字符串 最后的`AllocateDestinationString`是确认由用户自己分配，还是系统根据SourceString的大小来分配一块内存，用于保存转换后的值。如果用户传入的DestinationString已经分配过一块内存了，那么可以选择FALSE，反之，想要系统进行分配则选择TRUE，并且，需要手动对这块内存进行释放。

![image-20250713111646225](./驱动.assets/image-20250713111646225.png)

![image-20250713111540026](./驱动.assets/image-20250713111540026.png)

由于在一般情况下，我们编写的函数并不知道用户传入的字符串有多大，分配的内存是否合理，因此，可以选择让系统帮助我们进行分配。

![image-20250713111527092](./驱动.assets/image-20250713111527092.png)

注意，name这个变量结构是没有给分配内存的，因此，当我们传入到转换字符的API以后，系统分配的内存就会自动赋值给name.Buffer 里面

`%wZ` 是用于打印宽字符格式的（UNICODE），如果是窄字符格式（ANSI）那么就用`%Z`

在虚拟机下加载驱动以后，成功打印。

![image-20250713111402261](./驱动.assets/image-20250713111402261.png)

释放内存

`RtlFreeUnicodeString` 释放内存，但并不是释放name这个完整的结构体，而是释放其Buffer部分。

![image-20250713112931115](./驱动.assets/image-20250713112931115.png)



### 字符串的比较

在C语言下的一些API是可以使用的但可能在驱动下对一些API进行了封装，导致名称上有部分不同

```
_stricmp()
strcmp()
strstr()
wcscmp()
_WCSicmp()
```

- 全等比较

`RtlCompareUnicodeString`

注意这里是LONG类型，其用法与标准C下的比较是一样的，如果是零就代表两个字符串相同，如果大于零，就代表String1要长一些，如果小于零，就代表String2要长一些。

CaseInSensitive

- True 忽略大小写
- False 严格比较，不忽略大小写

![image-20250713114007357](./驱动.assets/image-20250713114007357.png)

- 前缀比较

![image-20250713120643181](./驱动.assets/image-20250713120643181.png)

在微软的官方有对应的文档，可以看到是判断String1是否是String2的前缀。同理，CaseInSensitive，是否忽略大小写。实际运用中可以用来判断是在哪一个盘符下。![image-20250713120713616](./驱动.assets/image-20250713120713616.png)

包含匹配，这个API可以用于判断后缀，判断是什么类型的文件格式

![image-20250713120912861](./驱动.assets/image-20250713120912861.png)

![image-20250713121217375](./驱动.assets/image-20250713121217375.png)

### 格式化

`sprintf()` `swprintf()` 可用

需要引入头文件#inlcude<ntstrsafe.h>，才可以引入纯内核态下的API

`RtlStringCbPrintfA` 格式化为窄字符

`RtlStringCbPrintfW` 格式化为宽字符

两个API都可以用于字符串的拼接，但在格式化的时候需要注意解析的格式，例如窄字符解析为窄字符，那么对应着就是`%s`。宽字符解析为窄字符可以用`%S`。

窄字符解析为宽字符，可以用`L"%S"`

![image-20250713123757279](./驱动.assets/image-20250713123757279.png)



### 字符串转化为数字

C语言下的通常的无法使用`atoi64 _atoi64 atoi`







可以用_strtoui64()来转化，这种是对应于三环下的转化



零环下的转换有API 

`RtlUnicodeStringToInteger`

`RtlUnicodeStringToInt64`

在使用`RtlUnicodeStringToInt64`的时候，可以看到我们可以编译成功。

![image-20250713131352657](./驱动.assets/image-20250713131352657.png)

但在Win7x32下运行，就会报**一个找不到指定程序**的错误。

这个错误**表明用了一个高版本的API,但是在低版本下没有这个API，导致它加载不了驱动**。

例如，有部分API，在Win11的高版本SDK里面有这个API，但是在Win10下没有这个API。即编程的环境所使用的API可以通过，但是在低版本的系统里面，运行可能就会报错。

大多数情况下，该错误信息都是这种原因，并且，编译器不会报错，所以很难排查是哪一个API用不了，所以开发环境和运行环境匹配是很重要的一件事。

![image-20250713130908735](./驱动.assets/image-20250713130908735.png)

因此，在使用API的时候，最好先看一下文档里面对系统的最低配置支持，即从哪一代系统开始

![image-20250713132909889](./驱动.assets/image-20250713132909889.png)

`RtlUnicodeStringToInteger`是低版本的API，并且高版本兼容。但是其由对无法解析的部分没有再次进行保存，因此，其功能没有三环下的c语言的解析功能强大



![image-20250713132825601](./驱动.assets/image-20250713132825601.png)

![image-20250713132931108](./驱动.assets/image-20250713132931108.png)

只能解析前面的数字

![image-20250713132718879](./驱动.assets/image-20250713132718879.png)

