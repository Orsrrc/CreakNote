# 驱动









## VS2019环境配置

对于单纯的驱动程序(.sys)来说，运行在哪个平台都是适用的，但若是debug环境的话就会有版本限制，vs2022以上，没有Win32的debug环境，因此，编写驱动最好用2019

- 将配置类型改为Driver，默认情况下，生成的Driver项目其配置类型就是Driver，但若修改，就会发现无法再次在下拉框里面选择Driver选项，**此时可以手动输入Driver**

![image-20250712105529231](./驱动.assets/image-20250712105529231.png)

在创建一个.c文件以后，才会出现C/C++的一个选项。

![image-20250712105925030](./驱动.assets/image-20250712105925030.png)



输入驱动程序的入口格式，并编译，发现报错，缺少库，以及默认情况下驱动是用于开发嵌入式软件的，因此，我们需要关闭部分选项。

![image-20250712110025235](./驱动.assets/image-20250712110025235.png)

![image-20250712110718987](./驱动.assets/image-20250712110718987.png)

`DbgPrintEx`作用类似于C里面的printf.



注意在搜索栏里面搜索SP（Spectre Mitigation）

![image-20250712110158959](./驱动.assets/image-20250712110158959.png)



![image-20250712110219685](./驱动.assets/image-20250712110219685.png)

![image-20250712110240379](./驱动.assets/image-20250712110240379.png)



![image-20250712110254280](./驱动.assets/image-20250712110254280.png)



![image-20250712110312090](./驱动.assets/image-20250712110312090.png)





![image-20250712110325869](./驱动.assets/image-20250712110325869.png)



![image-20250712110341324](./驱动.assets/image-20250712110341324.png)



生成sys成功，将sys放入虚拟机中，打开DebugView，关闭选项

![image-20250712110419533](./驱动.assets/image-20250712110419533.png)

打开驱动管理.exe，成功执行

![image-20250712110509342](./驱动.assets/image-20250712110509342.png)



## 驱动程序入口

在标准的C里面，Main函数是带有三个参数的，包括命令个数，命令字符串，环境。在默认情况下是可以没有参数的。

但是驱动的程序入口的两个参数是必须的



在Windows中每一个驱动，都有一个驱动对象，有没有真实的物理设备没有关系

将驱动编译为.sys才是DriverEntry 这个入口点，如果编译为.dll运行的话 是可以没有驱动对象的。

![image-20250712112221950](./驱动.assets/image-20250712112221950.png)



.dll 不能直接加载驱动，它能在A驱动引用了B.dll中的函数的时候，如果B.dll没有被加载，才会被动的被加载进去，而.sys能够主动的去加载驱动



PUNICODE_STRING 是在内核态下常用的传递字符串参数的数据结构。在内核态下，传递字符串的时候，通常不会传字面量"123"，或者是用指针char* ，而是传入这样一个完整的数据结构体。

![image-20250712112836542](./驱动.assets/image-20250712112836542.png)

![image-20250712113412436](./驱动.assets/image-20250712113412436.png)

通常，一个字符串在末尾时会多保存一个结束符\0，如果没有这个结束符，例如，将一个int类型，强制转为字符串去打印，**由于没有这个结束符，就会打印乱码**。

而在内核态下，**这样操作很有可能会导致蓝屏**，因此，**会使用一个变量来记录当前字符串的长度**。避免读取内存的时候产生溢出。这样，**在读取的时候就不需要关注字符串是否要以零结尾，而只用关注字符串的长度，根据长度就可以取到字符串。**

注意，字符串的长度其含义是字符串所占的字节数，而不是字符串字符的个数，也就是说当用宽字符来存储时L"1"，其字符串长度为两字节，而如果是窄字符"1"，其字符串长度为一字节.

![image-20250712115112535](./驱动.assets/image-20250712115112535.png)



`PUNICODE_STRING pRegUn` 参数含义：传入驱动路径

DbgBreakPoint() 下断点

![image-20250712115333778](./驱动.assets/image-20250712115333778.png)



修改了以后，重新载入。

![image-20250712122109943](./驱动.assets/image-20250712122109943.png)

在Windbg下成功捕获断点

![image-20250712122155434](./驱动.assets/image-20250712122155434.png)

`dt pRegUn`可以解析一下这个结构体，能够看到在其Buffer部分有一段地址，该地址以REGISTRY开头，表明这是一个注册表结构。

![image-20250712122253161](./驱动.assets/image-20250712122253161.png)

`regedit`命令查看注册表

根据路径可以查看到注册表地址，在对应的注册表下面有一个ImagePath，可以查看sys表

![image-20250712120304694](./驱动.assets/image-20250712120304694.png)

- type = 1 代表驱动
- start 代表以什么方式启动
  - 0、1、2 代表开机自启
  - 0 在bios的时候就启动
  - 1 在Windows的加载界面启动
  - 2 登录用户后启动

由于**加载驱动与组相关**，那么在注册表这里修改Start，是没有用的。

查找组加载顺序列表：

找到一个带有Group的注册表，复制里面的数据，去查找，能够找到GroupOrderList，这样一个列表，里面存放着所有的启动顺序

![image-20250712122449953](./驱动.assets/image-20250712122449953.png)

在这个加载列表里面可以认为是一组启动优先级，例如一个注册表的Group值属于Base 那么就要比Boot Bus Extender 的驱动加载要早。

![image-20250712122611283](./驱动.assets/image-20250712122611283.png)

如果在同一组下，Start 为0的要比Start为1、2的要早。

如果是同组，同start的情况下，那么注册表的排列顺序就是执行的顺序，在Windows下的命名，数字开头的永远比字母开头的排列在前面，因此数字要比字母的注册表启动得快(360的软件命名，在这里体现出其流氓本质)。

验证：

在驱动部分新增一项Group，注意其值为REG_SZ，否则不会生效，将组改为Boot Bus Extender，再将Start改为1。重新启动。

![image-20250712123157410](./驱动.assets/image-20250712123157410.png)

Windbg成功捕获断点，表明开机启动成功。

![image-20250712123339296](./驱动.assets/image-20250712123339296.png)

那么怎么样能够使得同组同Start的情况下，字母命名要比数字命名快呢？

我们可以将GroupList里面的注册表复制一份，然后删除，自己添加一份注册表然后插入原本的注册表，这样就使得我们手动添加的组在所有组的前面，这样就可以让自己的驱动组优先级最高。

**简而言之就是自己手动添加一个组，将本身的组优先级再调高一点，可以保证本身的程序优先级最高**。并且，如果将驱动加载以后，用驱动（零环）去修改组注册表是永远不会出发杀毒软件，或者是微软的Defender程序的，而如果用（三环）去修改，很有可能会被拦截。

tips:

> 病毒的编写逻辑：
>
> 1.加载完驱动后隐藏
>
> 2.删除注册表，以及驱动本身
>
> 3.注册关机回调，写回注册表

> 程序的注册步骤，本质上来讲就是将我们编写的驱动写入到注册表里面，因此这一步是可以我们手动来完成的，直接在注册表里面创建一个键，将我们驱动的路径写入进去。
>
> ![image-20250712123908370](./驱动.assets/image-20250712123908370.png)
>
> 而运行，就是将服务启动
>
> API启动方式：API调用NtLoadDriver
>
> 服务启动方式：StartService  == （命令行启动方式）net start day01(注册表键)
>
> 



`PDRIVER_OBJECT pDriver`驱动对象结构

![image-20250712124814514](./驱动.assets/image-20250712124814514.png)

type用于区分对象类型

type = 4 就是驱动对象

type = 3就是设备对象



一个驱动有了设备才会便于去调用，反之，如果没有那么是很难去调用到的

这里的设备本质上来说是Windows提供的一个通信方式

通过设备读取设备信息。

DeviceObject 设备信息，可以用于绑定物理设备

Flags 驱动运行时产生的报错信息等

DriverStrart  运行时驱动模块位置

DriverExtension.ServiceKeyName 这里的名字是注册表键的名字，而不是显示的名字即

类似于`REGISTRY\MACHINE\HARIWARE\Service\day01` 这样的一个名字，注册表所在文件夹的名字

![image-20250712125736234](./驱动.assets/image-20250712125736234.png)

DriverName 驱动名字，便于通过API查找驱动对象

HardwareDatabase 硬件数据库

FastIoDispatch 用于快速调用

DriverInit 驱动入口点地址

可以看到，实际生成程序的时候，并不是直接运行程序的Main函数，系统对其进行了部分的封装，进行部分安全措施的保护后，才跳转到我们的Main函数。

![image-20250712130106625](./驱动.assets/image-20250712130106625.png)

DriverUnload 卸载函数的回调

MajorFuncion  IO 对象的回调



## 变量类型

`int -> INT`

`unsigned int = UINT`

`char->CHAR`

`long->LONG`

`unsigned long = ULONG`

`short->SHORT`

`wchar == SHORT`

`void -> VOID`

`ULONG64`

`LONG64`

`UINT_PTR` 类似一个宏，当在不同的环境下，例如x32位下就是一个32bit的类型。做x32与x64兼容的程序可以用这个。



RtlUnicodeStringToAnsiString



NTSTATUS 4B的数字  即错误码的数字，用于监测调用函数API是否成功。其本质就是判断，函数返回的状态值是否大于零，大于零表示成功加载。

![image-20250712131118455](./驱动.assets/image-20250712131118455.png)



.CPP与.C

由于驱动对入口程序有严格的命名要求，因此，如果是.cpp文件，在编译的时候会将我们的函数名字编译为`DroverEntry@upDriverUNXXXXXx...`

此时，对于驱动程序就会编译不过，因为它不能找到我们的程序入口地址。

解决的方法有

指定编译的程序入口名

![image-20250712133347760](./驱动.assets/image-20250712133347760.png)

添加关键字`extern "C"` ，在驱动里面对这部分关键字也进行了封装`EXTERN_C`

![image-20250712133311226](./驱动.assets/image-20250712133311226.png)

![image-20250712133501680](./驱动.assets/image-20250712133501680.png)

![image-20250712133435889](./驱动.assets/image-20250712133435889.png)



## 字符串

- unicode 宽字符
-  ascll-code 窄字符

在驱动下面，一些标C的字符串操作函数还是可以用的，例如`strcat`，对于ACll-CODE，大部分的函数是可以用的，但对于UNICODE 只有部分可用。

### 初始化字符串

- Unicode

调用API`RtlInitUnicodeString` 其本质上就是给字符串结构体的三个值赋值

```\
name.Length = wcslen(L"1111111") * 2; //宽字符一个字符占2字节
name.Buffer = L"111111";
name.MaximumLength = wcslen(L"1111111") * 2;
```

![image-20250713105251519](./驱动.assets/image-20250713105251519.png)

- ASCICODE

可以看到 ANSI_STRING 本质上是STRING的别名

![image-20250713105552811](./驱动.assets/image-20250713105552811.png)

那么调用API`RtlINitAnsiString`与`RtlInitString`是相同的作用

![image-20250713105624998](./驱动.assets/image-20250713105624998.png)

tips:

在查看一些陌生的API的时候，可以看一下参数的前缀，例如\_Out_ 就代表这个参数用来保存输出的数据，\_IN_就代表这个参数需要用户提供给API，\_OPT\_代表option，可选择的，也就是用户可以选择是否提供，如果不提供就输入NULL。

那么对于_In\_opt\_这样的组合，就表明是用户可选提供输入参数

![image-20250713105826440](./驱动.assets/image-20250713105826440.png)

### 窄字符转宽字符

调用API`RtlAnsiStringToUnicodeString()`

可以看到这个函数的返回值是NTSTATUS，也就是说可以通过返回值查看是否调用API成功。

前两个\_When_ 可以看成是一个宏，该两个宏是简单描述这个函数是干什么用的，

`DestinationString`即用于保存转换后的字符串，`SourceString`就是源字符串 最后的`AllocateDestinationString`是确认由用户自己分配，还是系统根据SourceString的大小来分配一块内存，用于保存转换后的值。如果用户传入的DestinationString已经分配过一块内存了，那么可以选择FALSE，反之，想要系统进行分配则选择TRUE，并且，需要手动对这块内存进行释放。

![image-20250713111646225](./驱动.assets/image-20250713111646225.png)

![image-20250713111540026](./驱动.assets/image-20250713111540026.png)

由于在一般情况下，我们编写的函数并不知道用户传入的字符串有多大，分配的内存是否合理，因此，可以选择让系统帮助我们进行分配。

![image-20250713111527092](./驱动.assets/image-20250713111527092.png)

注意，name这个变量结构是没有给分配内存的，因此，当我们传入到转换字符的API以后，系统分配的内存就会自动赋值给name.Buffer 里面

`%wZ` 是用于打印宽字符格式的（UNICODE），如果是窄字符格式（ANSI）那么就用`%Z`

在虚拟机下加载驱动以后，成功打印。

![image-20250713111402261](./驱动.assets/image-20250713111402261.png)

释放内存

`RtlFreeUnicodeString` 释放内存，但并不是释放name这个完整的结构体，而是释放其Buffer部分。

![image-20250713112931115](./驱动.assets/image-20250713112931115.png)



### 字符串的比较

在C语言下的一些API是可以使用的但可能在驱动下对一些API进行了封装，导致名称上有部分不同

```
_stricmp()
strcmp()
strstr()
wcscmp()
_WCSicmp()
```

- 全等比较

`RtlCompareUnicodeString`

注意这里是LONG类型，其用法与标准C下的比较是一样的，如果是零就代表两个字符串相同，如果大于零，就代表String1要长一些，如果小于零，就代表String2要长一些。

CaseInSensitive

- True 忽略大小写
- False 严格比较，不忽略大小写

![image-20250713114007357](./驱动.assets/image-20250713114007357.png)

- 前缀比较

![image-20250713120643181](./驱动.assets/image-20250713120643181.png)

在微软的官方有对应的文档，可以看到是判断String1是否是String2的前缀。同理，CaseInSensitive，是否忽略大小写。实际运用中可以用来判断是在哪一个盘符下。![image-20250713120713616](./驱动.assets/image-20250713120713616.png)

包含匹配，这个API可以用于判断后缀，判断是什么类型的文件格式

![image-20250713120912861](./驱动.assets/image-20250713120912861.png)

![image-20250713121217375](./驱动.assets/image-20250713121217375.png)

### 格式化

`sprintf()` `swprintf()` 可用

需要引入头文件#inlcude<ntstrsafe.h>，才可以引入纯内核态下的API

`RtlStringCbPrintfA` 格式化为窄字符

`RtlStringCbPrintfW` 格式化为宽字符

两个API都可以用于字符串的拼接，但在格式化的时候需要注意解析的格式，例如窄字符解析为窄字符，那么对应着就是`%s`。宽字符解析为窄字符可以用`%S`。

窄字符解析为宽字符，可以用`L"%S"`

![image-20250713123757279](./驱动.assets/image-20250713123757279.png)



### 字符串转化为数字

C语言下的通常的无法使用`atoi64 _atoi64 atoi`

可以用_strtoui64()来转化，这种是对应于三环下的转化



零环下的转换有API 

`RtlUnicodeStringToInteger`

`RtlUnicodeStringToInt64`

在使用`RtlUnicodeStringToInt64`的时候，可以看到我们可以编译成功。

![image-20250713131352657](./驱动.assets/image-20250713131352657.png)

但在Win7x32下运行，就会报**一个找不到指定程序**的错误。

这个错误**表明用了一个高版本的API,但是在低版本下没有这个API，导致它加载不了驱动**。

例如，有部分API，在Win11的高版本SDK里面有这个API，但是在Win10下没有这个API。即编程的环境所使用的API可以通过，但是在低版本的系统里面，运行可能就会报错。

大多数情况下，该错误信息都是这种原因，并且，编译器不会报错，所以很难排查是哪一个API用不了，所以开发环境和运行环境匹配是很重要的一件事。

![image-20250713130908735](./驱动.assets/image-20250713130908735.png)

因此，在使用API的时候，最好先看一下文档里面对系统的最低配置支持，即从哪一代系统开始

![image-20250713132909889](./驱动.assets/image-20250713132909889.png)

`RtlUnicodeStringToInteger`是低版本的API，并且高版本兼容。但是其由对无法解析的部分没有再次进行保存，因此，其功能没有三环下的c语言的解析功能强大



![image-20250713132825601](./驱动.assets/image-20250713132825601.png)

![image-20250713132931108](./驱动.assets/image-20250713132931108.png)

只能解析前面的数字

![image-20250713132718879](./驱动.assets/image-20250713132718879.png)



## 断链

在高版本会PG，隐藏驱动不够彻底，仍有痕迹

- 遍历驱动 
- 隐藏驱动



### 驱动遍历

`vergilusproject.com/kernels` 该网站可以提供部分版本下，Windows支持的API的文档

![image-20250714160444016](./驱动.assets/image-20250714160444016.png)



在Wrk Project 中查询的结构与网站上提供的一个结构有两个变量不同

![image-20250714160104811](./驱动.assets/image-20250714160104811.png)



这里我们使用Wrk Project的结构，对于我们用不到的结构，但是编译器无法识别的，只需要保证其字节数是对的就可以了

![image-20250714155958980](./驱动.assets/image-20250714155958980.png)

![image-20250714160033677](./驱动.assets/image-20250714160033677.png)



编写驱动中打下断点，发现我们能从驱动的对象里面解析到驱动所在的链表地址，从这个地址我们能够遍历出系统中加载的驱动或进程信息。

![image-20250714162001431](./驱动.assets/image-20250714162001431.png)



![image-20250714162235068](./驱动.assets/image-20250714162235068.png)



可以看到该结构体的信息里面的FullDllName 是“”，表明这个是双向链表的表头

![image-20250714162307848](./驱动.assets/image-20250714162307848.png)

继续遍历链表下一项，发现是内核。

![image-20250714162608226](./驱动.assets/image-20250714162608226.png)

也就是说，我们从一个驱动程序出发，能够在零环权限下遍历所有的进程的信息。 



遍历完成后发现对链表头程序进行遍历的时候，其FullDllName字段为NULL，需要对其进行过滤

![image-20250714181418885](./驱动.assets/image-20250714181418885.png)

![image-20250714164502549](./驱动.assets/image-20250714164502549.png)

对双向链表的表头元素进行过滤。

在字符串结构体里边，如果其名字不为空，那么其长度必定大于零，因此可以将其进行过滤。

![image-20250714175457570](./驱动.assets/image-20250714175457570.png)

`.cls`可以进行将WinDbg进行清屏

### bug处理

当编译驱动的时候，如果遇到与驱动的.pdb文件相关的报错的时候。大概率是因为编译器想要重写.pdb文件，但是该文件不能删除，导致编译报错。在VS2019的版本中，重新生成解决方案能够解决。

![image-20250714175921205](./驱动.assets/image-20250714175921205.png)

在VS2019以下的版本中，有两种解决方式

- 重命名这个文件，使得编译器重写这个文件的时候其文件名不会被占用。

![image-20250714180906015](./驱动.assets/image-20250714180906015.png)







- 在WinDbg中使用.reload指令让系统将没有用的驱动程序进行删除。



### 驱动隐藏

调用API`RemoveEntryList`

![image-20250714181649261](./驱动.assets/image-20250714181649261.png)

可以查看到源码，发现其原理就是链表节点的删除。![image-20250714181723273](./驱动.assets/image-20250714181723273.png)

此时由于并没有完全隐藏，在PCHunter这个软件下依然可以扫描到驱动，但是可以发现是从驱动的链表里面删除了我们编写的驱动的节点的。

![image-20250714181955753](./驱动.assets/image-20250714181955753.png)

此时如果不还原，直接卸载我们的驱动会导致卡死。

在高版本下，如果我们在驱动的链表里面删除了驱动的节点，但是如果系统在扫描的过程中发现了我们的驱动，那么就会触发PG，系统蓝屏。其根本原理就是扫描到了DriverSection字段

我们直接将其置为NULL

![image-20250714182253395](./驱动.assets/image-20250714182253395.png)

运行后发现蓝屏



让WinDbg进行解析后，发现是MmFreeDriverInitiation这个函数中的一行报错。

![image-20250714182419823](./驱动.assets/image-20250714182419823.png)

打开ida，查看一下这个函数的反汇编。

找到导致蓝屏的代码。

![image-20250714175206292](./驱动.assets/image-20250714175206292.png)

发现是访问了edx+18h 这块内存出错。往上看发现没有关于edx这个寄存器的赋值，那么可能是传入进来的参数

我们可以选中函数名后按下x查看交叉引用，即查看有哪个函数调用了这个函数。

![image-20250714182854397](./驱动.assets/image-20250714182854397.png)



查看该函数返现对edx进行了赋值，但是这里并不知道esi的内容是什么，所以需要往上查看

![image-20250714182941468](./驱动.assets/image-20250714182941468.png)

查看到给esi赋值的语句后继续查看ebp寄存器的值

![image-20250714183037755](./驱动.assets/image-20250714183037755.png)

继续往上可以看到[ebp+var_88]，由于还有部分内容没有学习，所以直接查看一下这个函数的作用。

![image-20250714183301841](./驱动.assets/image-20250714183301841.png)

打开Wrk搜索该函数的结构

![image-20250714183507538](./驱动.assets/image-20250714183507538.png)



发现这里有一个类似于Windows句柄的一个机制，也就是拿到进程的句柄以后，可以得到进程的对象。

这里也类似，拿到驱动的句柄以后，可以返回驱动的对象。之后我们就可以知道，拿到驱动的对象之后，访问其初始地址的第18h的元素会报内存的错误，我们查看驱动对象的结构可以得到

![image-20250714183802250](./驱动.assets/image-20250714183802250.png)



也就是我们置为NULL的这一项，DriverSection，系统会拿出它并传递给函数。

![image-20250714183845150](./驱动.assets/image-20250714183845150.png)

简单来说就是，这个参数要被使用，但是由于我们直接将其置为NULL，导致访问这块内存出错。



那么现在就有个思路是，让系统访问完这个参数之后，再将其置为NULL，即让其延迟置为NULL。



- 内核态创建线程
  - `PsCreateSystemThread`

在内核态下，凡是以Ps开头的都是与进程或者线程相关。

![image-20250714191127092](./驱动.assets/image-20250714191127092.png)

![image-20250714191138133](./驱动.assets/image-20250714191138133.png)

线程的启动 在进程被创建之前，那么此时如果将驱动挂上去，就有两个情况，一种是线程启动的时间在系统读取变量的时候之后，那么就成功，反之，则蓝屏失败。

因此，我们需要在线程里面添加休眠函数。

`KeStallExecutionProcessor` 该函数API类似于执行多次pause，但其延时是纳秒级别的，无法延迟秒以上。

![image-20250714192915091](./驱动.assets/image-20250714192915091.png)

![image-20250714192925905](./驱动.assets/image-20250714192925905.png)



- 三环下，调用SleepEx(),有一个参数可以选择是否在未达到等待时间的时候中断睡眠

![image-20250714193043270](./驱动.assets/image-20250714193043270.png)

使用`KeDelayExecutionThread` 函数

![image-20250714193113036](./驱动.assets/image-20250714193113036.png)



其 MODE参数可以看到有三个

![image-20250714193129546](./驱动.assets/image-20250714193129546.png)

Alertable即是否可以在时间结束之前打断睡眠

PLARGE_INTERGER

![image-20250714193229026](./驱动.assets/image-20250714193229026.png)

发现是一个union变量类型，也就是说，我们选择哪一个数，其大小都是一样的，占四字节

![image-20250714193336827](./驱动.assets/image-20250714193336827.png)

当参数是正数时，其逻辑是当前时间的时间戳+延时时间 = 绝对时间，这个绝对时间中包含了年月日，即如果得到的绝对时间是当前系统的过去时间，那么就不会执行，如果是未来时间，则到达绝对时间后执行。

负数即为相对时间，其含义就是过多少秒以后执行。

函数的时间单位是纳秒级别的。

![image-20250714193757479](./驱动.assets/image-20250714193757479.png)



在线程中执行，成功隐藏，并且PCHunter未爆红，表**明其查找到断链的逻辑是遍历驱动链表，如果驱动链表中没有，但是存在DriverSection，那么即为隐藏进程。**

![image-20250714193826763](./驱动.assets/image-20250714193826763.png)

> 断链之后为什么PCHunter还能遍历编写驱动的驱动对象？

Windows 存在目录对象，其拿到目录对象以后可以拿到所有的驱动对象

![image-20250714194214739](./驱动.assets/image-20250714194214739.png)

Driver就是一个目录对象，可以根据偏移，遍历出所有的驱动对象。

而我们的断链只是隐藏了驱动链表文件，扫不到模块地址在哪里。



隐藏别的驱动

首先要得到驱动的驱动对象

调用API`ObReferenceObjectByName`

![image-20250714195654480](./驱动.assets/image-20250714195654480.png)



**这个函数的导出没有文档化，即函数没有被写入头文件，但是这个函数是存在，因此，我们在使用的时候需要声明一份。** 

注意，在声明的时候要加上EXTERN_C 避免函数名在文件为.cpp的时候编译出错

![image-20250714195819828](./驱动.assets/image-20250714195819828.png)



驱动对象是根据驱动注册的时候的命名来命名的，因此，我们根据目录对象来查找驱动对象的时候直接目录对象+驱动对象名即可。

OBJ_CASE_INSENSITIVE 对比字符串的时候不区分大小写

不创建线程，在主函数中进行隐藏

![image-20250714202326666](./驱动.assets/image-20250714202326666.png)

断链之后如果没有还原，那么卸载驱动会蓝屏，当然，隐藏驱动后无法从PCHunter里面卸载驱动。



蓝屏

![image-20250714202253128](./驱动.assets/image-20250714202253128.png)

是因为驱动对自身有保护，有自校验。

替换有自校验的驱动的DriverSection。

![image-20250714202443158](./驱动.assets/image-20250714202443158.png)

发现成功隐藏。这给我们过驱动的自校验一个思路：如果驱动不断的校验自己，那么可以给它一个假的DriverSection，这样的话就实现了驱动的隐藏，并且，让被隐藏的驱动本身认为自己是正确的。

![image-20250714202520508](./驱动.assets/image-20250714202520508.png)





字符串匹配

手动实现字符串的END功能

计算子串的长度，每次读出子串长度的字符，进行比较。

