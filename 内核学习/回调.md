# 回调

回调，意味着只要就的一个逻辑，系统监视着某件事是否发生，当发生了以后就调用某件事情进行处理。

进程的创建、句柄保护、注册表、线程的创建等都可以监视



进程、线程的监控 模块的加载

在内核态屏蔽监控



API：

`PsSetLoadImageNotifyRoutine`：检测模块的加载，例如加载一个.dll

`PsSetCreateThreadNotifyRoutine`：监控线程的加载

`PsSetCreateProcessNotifyRoutine`：监控进程的加载

![image-20250816123148004](./%E5%9B%9E%E8%B0%83.assets/image-20250816123148004.png)

`PsSetCreateProcessNotifyRoutineEx`:通过该函数可以实现对进程的拒绝加载，即将监控某一进程的时候，可以实现过滤加载。



## 进程回调

`PsSetCreateProcessNotifyRoutine`写法：

![image-20250816123750161](./%E5%9B%9E%E8%B0%83.assets/image-20250816123750161.png)

根据回调函数的原型（可以修改函数名，但回调函数的返回值与形参需要相同）进行编写我们自己的回调函数。



注册回调

![image-20250816123927079](./%E5%9B%9E%E8%B0%83.assets/image-20250816123927079.png)

这里等于注册了该函数两遍（实现时应该是对原本回调函数的覆盖），后面的标志位被修改。从而实现驱动在运行时回调函数不被删除，驱动卸载时回调被删除的效果。

回调函数的多次注册处理方式：

>1.**覆盖模式（大多数常见实现）​**​
>
>- **表现**：第二次注册会覆盖第一次的注册，最终只有最后一次注册生效。
>
>  **实现原理**：
>
>  - 回调通常以函数指针（或函数对象）的形式存储在某个数据结构（如哈希表、数组）中，键可能是事件类型或唯一标识符。
>  - 当重复注册时，系统会更新存储的指针/对象，直接替换旧值。
>
>### 2. **多次注册模式**
>
>- **表现**：每次注册都会保留，触发时回调会被调用多次。
>- 实现原理：
>  - 回调被存储在链表或数组中，允许重复条目。
>  - 触发时遍历所有注册的回调，依次执行
>
>### 3. **标志位修改（较少见）**
>
>- **表现**：重复注册仅修改内部状态（如启用/禁用标志），不覆盖回调本身。
>- 实现原理：
>  - 系统可能维护一个 `enabled` 标志，重复调用时仅更新标志位。
>  - 回调存储结构本身不变。



![image-20250816135852647](./%E5%9B%9E%E8%B0%83.assets/image-20250816135852647.png)



![image-20250816135614742](./%E5%9B%9E%E8%B0%83.assets/image-20250816135614742.png)



![image-20250816140038551](./%E5%9B%9E%E8%B0%83.assets/image-20250816140038551.png)



`PsSetCreateProcessNotifyRoutineEx`监控写法

同样，根据其回调函数的参数以及返回值要求，编写函数

![image-20250816140917582](./%E5%9B%9E%E8%B0%83.assets/image-20250816140917582.png)



![image-20250816141825267](./%E5%9B%9E%E8%B0%83.assets/image-20250816141825267.png)

通过CreationStatus，我们可以拒绝其打开进程。即通过CreationStatus可以进行过滤。

![image-20250816160023911](./%E5%9B%9E%E8%B0%83.assets/image-20250816160023911.png)

此时编译运行，由于API所需要的权限过高，导致系统不允许其注册。状态返回值是0xC0000022

![image-20250816150813858](./%E5%9B%9E%E8%B0%83.assets/image-20250816150813858.png)

通过IDA静态分析该函数，它底层调用的是别的函数

![image-20250816151019136](./%E5%9B%9E%E8%B0%83.assets/image-20250816151019136.png)

由于它返回的值是0xC0000022，因此我们需要去逆向这个返回值的代码，看看如何跳转到该代码区返回的。

对十进制数按下`H`可以看到它的十六进制数，发现其判断条件是一个函数，其函数名表示它是检查函数的标志位的。并且Flags影响其参数。这个Flags是从参数中传递出来的，而我们填入的`Remove`参数决定了标志位

![image-20250816151449585](./%E5%9B%9E%E8%B0%83.assets/image-20250816151449585.png)

![image-20250816151847279](./%E5%9B%9E%E8%B0%83.assets/image-20250816151847279.png)

![image-20250816153455186](./%E5%9B%9E%E8%B0%83.assets/image-20250816153455186.png)

![image-20250816153529425](./%E5%9B%9E%E8%B0%83.assets/image-20250816153529425.png)

我们在调用时，其参数选择的是False即传入的a2（flags）为2，那么v5就等于32，十六进制为0x20

进入到判断条件里面

![image-20250816155123898](./%E5%9B%9E%E8%B0%83.assets/image-20250816155123898.png)

由此，我们就有对应的解决方法

1.通过查找PsSetCreateProcessNotifyRoutineEx函数，我们自行调用其底层的函数`PspSetCreateProcessNotifyRoutine`，然后我们自己将Flags标志传入一个0，这样的话v5就是零，也就是我们穿传入检查函数的checkFlags为0。那么当函数存在其所属模块以后，由于先判断checkFlags，从而判断结果为true，返回1.

2.修改注册函数的`_KLDR_DATA_TABLE_ENTRY`，将它的Flags或上0x20，这样检测时，`v6->flags & checkFlags != 0`为真，成功注册



第二种写法：

将结构拷贝过来

```c++
typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	// ULONG padding on IA64
	PVOID GpValue;
	PVOID NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	// ULONG padding on IA64
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;
```

![image-20250816155820951](./%E5%9B%9E%E8%B0%83.assets/image-20250816155820951.png)



回调函数中通过CreateInfo，过滤进程打开

![image-20250816163247496](./%E5%9B%9E%E8%B0%83.assets/image-20250816163247496.png)

![image-20250816163254304](./%E5%9B%9E%E8%B0%83.assets/image-20250816163254304.png)

再次打开时，进程拒绝访问。

许多杀毒软件就是这样操作的，对进程的特征进行定义，然后传递到内核态去判断一下，如果满足某个病毒进程的特征，就拦截不允许运行。



> 进程创建的监控，可以拿到某些游戏进程的真实的CR3，因为其进程刚创建时，就会回调它。在该回调监控里面，我们拿到的CR3一定是最原始的CR3



## 线程回调

`PsSetCreateThreadNotifyRoutine`线程监控写法：

同样，我们按照其回调函数的要求编写函数

![image-20250816164213490](./%E5%9B%9E%E8%B0%83.assets/image-20250816164213490.png)

![image-20250816164411299](./%E5%9B%9E%E8%B0%83.assets/image-20250816164411299.png)

![image-20250816164131581](./%E5%9B%9E%E8%B0%83.assets/image-20250816164131581.png)



![image-20250816164229304](./%E5%9B%9E%E8%B0%83.assets/image-20250816164229304.png)









## 模块回调

`PsSetLoadImageNotifyRoutine`模块加载监控写法：

同理，找到其回调函数格式

![image-20250816165509604](./%E5%9B%9E%E8%B0%83.assets/image-20250816165509604.png)

![image-20250816165608955](./%E5%9B%9E%E8%B0%83.assets/image-20250816165608955.png)

![image-20250816165648932](./%E5%9B%9E%E8%B0%83.assets/image-20250816165648932.png)

注册以后，打开一个进程，可以看到其加载模块的信息

![image-20250816165659234](./%E5%9B%9E%E8%B0%83.assets/image-20250816165659234.png)

我们加载一个简单的驱动，可以看到它的PID是0。

**在对模块的监控里面。驱动加载返回的PID不是0就是4**

![image-20250816165734280](./%E5%9B%9E%E8%B0%83.assets/image-20250816165734280.png)



这是由于其底层调用的函数决定的。大多数驱动的加载调用的都是`NtLoadDriver`函数

![image-20250816165825444](./%E5%9B%9E%E8%B0%83.assets/image-20250816165825444.png)

![image-20250816165920533](./%E5%9B%9E%E8%B0%83.assets/image-20250816165920533.png)





![image-20250816170357537](./%E5%9B%9E%E8%B0%83.assets/image-20250816170357537.png)

这个加载队列本质上是一个线程池，当有非系统进程创建的时候，就让他在system线程里面跑一下

如果是system进程加载它是同步的，反之是异步的。

这种模块的检测，只针对文件。即如果使用内存加载，其没有文件存在，其本身就能绕过这类对文件的检查。



如果已知某一个检测模块，即打开进程以后，其需要加载检测模块去检测。那么我们通过模块检测函数，直接让它无法加载检测模块，或者不执行检测模块，就可以绕过进程的检测。

即检测到某一检测模块以后，我们写入入口点，或者编写代码，从而绕过检测

```
mov eax, 0xc0000001
ret
```

这个地方还可以dump，检测到该模块加载以后，由于我们一直模块的地址以及模块的大小，那么我们直接写文件就可以直接将其dump下去



模块的回调函数的运行契机是在修复完成后，执行入口点之前。

只有回调函数执行完成以后，才会执行入口点。所以在回调函数中将内存dump下来是可以的。



## 绕过回调

如何绕过拦截，即当进程加载的时候，关闭这个监控，当我的进程加载完成以后，再去打开该监控。



静态分析注册函数

在加载模块函数的注册函数里面，可以找到一个mask值，我们往上看其被调函数

![image-20250816173934538](./%E5%9B%9E%E8%B0%83.assets/image-20250816173934538.png)

可以看到，该mask值决定了当发生某一事件时，是否会调用其回调函数

![image-20250816174141453](./%E5%9B%9E%E8%B0%83.assets/image-20250816174141453.png)



同理，到了线程的创建回调函数中，我们也可以看到一个mask相关联的值为0x10和0x08

![image-20250816174253390](./%E5%9B%9E%E8%B0%83.assets/image-20250816174253390.png)

![image-20250816174412492](./%E5%9B%9E%E8%B0%83.assets/image-20250816174412492.png)



因此，我们只需要修改Mask值，将它的值变为0，之后所有的flag值与上其结果都为false，从而不再去调用回调函数。

## 句柄回调

只要是内核对象，都有其句柄的回调。即只要它是对象类型，就可以给它添加句柄的回调。

常用于对进程和线程的句柄进行保护

API:`ObRegisterCallbacks`

![image-20250817113239091](./%E5%9B%9E%E8%B0%83.assets/image-20250817113239091.png)

回调函数类型结构

![image-20250817113616681](./%E5%9B%9E%E8%B0%83.assets/image-20250817113616681.png)

先回调表示在操作前，后回调表示在操作后。即拦截打开句柄操作，在打开句柄之前调用先回调函数，打开句柄后调用后回调函数。

对象类型，指明了需要拦截的是进程句柄、线程句柄或者是事件句柄。

![image-20250817114245118](./%E5%9B%9E%E8%B0%83.assets/image-20250817114245118.png)

其中对于句柄的操作有两个，分别是打开句柄以及复制句柄。对句柄的复制大多的操作是将目标句柄复制到指定位置

![image-20250817114328688](./%E5%9B%9E%E8%B0%83.assets/image-20250817114328688.png)





用宏或者是函数，其值返回的都是0x100

![image-20250817114931552](./%E5%9B%9E%E8%B0%83.assets/image-20250817114931552.png)



![image-20250817113758290](./%E5%9B%9E%E8%B0%83.assets/image-20250817113758290.png)



同样，按照其回调函数的参数格式编写回调函数

![image-20250817115238323](./%E5%9B%9E%E8%B0%83.assets/image-20250817115238323.png)

其中RegistrationContext为注册时传入的参数，如果传入时为NULL，那么这里回调函数拿到的参数也为NULL。

`OB_PRE_IOERATION_INFORMATION`结构：

![image-20250817135348363](./%E5%9B%9E%E8%B0%83.assets/image-20250817135348363.png)

对于是否为内核句柄的判断，其实质上就是判断是内核打开的句柄还是三环打开的句柄。

内核打开句柄需要指定对应对象属性里面的attribute属性为内核打开。内核句柄通常是system句柄表里面的句柄。

`Object`打开的对象

`ObjectType`对象类型，由于该API没有区分线程对象还是进程对象，因此可以通过该属性进行区分。

`CallContext`传递参数，如果在先回调部分绑定了一块内存，那么在后回调函数中可以拿到这块内存的指针。

可以看到，在先回调中对这个参数的描述为`_Out_`，到了后回调中为`_In_`

![image-20250817140535815](./%E5%9B%9E%E8%B0%83.assets/image-20250817140535815.png)

`Parameters`参数

该结构是一个联合体，具体使用哪一部分的结构，取决于拦截到的句柄操作事件。

例如拦截到打开句柄，就调用第一个反之就调用第二个。

![image-20250817140838918](./%E5%9B%9E%E8%B0%83.assets/image-20250817140838918.png)

`OB_PRE_OPERATION_PARAMETERS`结构

在打开句柄的回调函数中，可以修改赋予该句柄的权限。即如果它请求全部权限，那么可以在回调函数中给它改成单一权限。

![image-20250817141706469](./%E5%9B%9E%E8%B0%83.assets/image-20250817141706469.png)

同样，句柄的回调注册也存在地址的校验，因此我们需要绕过校验。

![image-20250817115638165](./%E5%9B%9E%E8%B0%83.assets/image-20250817115638165.png)

注意，前回调和后回调至少存在一个，不能两个都没有。

![image-20250817120105703](./%E5%9B%9E%E8%B0%83.assets/image-20250817120105703.png)

接受时也是二级指针，因此不需要对类型进行转换。

![image-20250817120128347](./%E5%9B%9E%E8%B0%83.assets/image-20250817120128347.png)

![image-20250817115835289](./%E5%9B%9E%E8%B0%83.assets/image-20250817115835289.png)

驱动卸载时，卸载回调。

![image-20250817115937099](./%E5%9B%9E%E8%B0%83.assets/image-20250817115937099.png)

句柄保护先回调写法，注意，PsGetProcessImageFileName需要进行声明。

![image-20250817143641260](./%E5%9B%9E%E8%B0%83.assets/image-20250817143641260.png)

我们只处理了打开句柄时的情况。对于dump句柄时，我们虽然没有特殊处理，但由于联合体结构是共享同一块内存，因此联合体中我们修改打开句柄的DesiredAccess为0时，dump句柄结构中拿到的DesiredAccess也是0

```c++
union MyUnion {
    struct {
        int x;
        int y;
    } A;
    struct {
        int x;
        int y;
        int z;
    } B;
};

MyUnion u;
u.A.x = 1;
u.A.y = 2;
```

>在这种情况下：
>
>1. 由于A和B共享同一块内存，且它们的x和y成员在内存中的位置相同
>2. 当你给u.A.x和u.A.y赋值后，u.B.x和u.B.y的值也会被相应地改变
>3. 因此，u.B.x的值会是1，u.B.y的值会是2
>
>这是因为联合体的所有成员都是从同一内存地址开始的，A和B中的x和y在内存中是对齐的。当你通过A修改x和y时，通过B拿到的也是同样的一块内存数据。



一旦句柄被保护了以后，就没有图标了

![image-20250817144905876](./%E5%9B%9E%E8%B0%83.assets/image-20250817144905876.png)

这样的保护容易被扫描发现

![image-20250817145627137](./%E5%9B%9E%E8%B0%83.assets/image-20250817145627137.png)



在64位下，可以利用其参数来实现隐藏

64 位下的调用约定，如果没有浮点的话

rcx rdx r8 r9

分别存放第1 2 3 4 个参数

那么我们在注册回调的时候，可以找一个会执行jmp rcx 指令的系统模块（可以看到在扫描的过程中如果是系统模块没有爆红，意味着系统模块对句柄进行操作不会被检测到），注册对应指令的硬编码，然后rcx里面存放的是我原本的回调函数的地址，这样就实现了隐藏。



我们要在模块中搜索特征码，而不是在某一指定位置进行搜索。

这里用的是火哥的代码，可以后续自己实现或者用别人的

search.h

```c++
#pragma once
#include <ntifs.h>

ULONG_PTR QuerySysModule(char * MoudleName, _Out_opt_ ULONG_PTR * module); //查询模块

ULONG_PTR searchNtCode(char * code, int offset);//搜索Nt模块

ULONG_PTR searchCode(char * moduleName, char * segmentName, char * code, int offset);

ULONG_PTR searchCodeByModule(ULONG64 dllBase, char* segmentName, char* code, int offset);

```

Search.cpp

```c++

#include "Search.h"
#include <ntimage.h>


typedef struct _FindCode
{
	UCHAR code[0x200];
	ULONG len;
	int offset;
	ULONG lastAddressOffset;
}FindCode, * PFindCode;


NTSTATUS MmCopyVirtualMemory(
	IN PEPROCESS FromProcess,
	IN CONST VOID *FromAddress,
	IN PEPROCESS ToProcess,
	OUT PVOID ToAddress,
	IN SIZE_T BufferSize,
	IN KPROCESSOR_MODE PreviousMode,
	OUT PSIZE_T NumberOfBytesCopied
);


EXTERN_C NTSTATUS NTAPI ZwQuerySystemInformation(
	__in ULONG SystemInformationClass,
	__out_bcount_opt(SystemInformationLength) PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
);


typedef struct _RTL_PROCESS_MODULE_INFORMATION1 {
	HANDLE Section;                 // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION1, *PRTL_PROCESS_MODULE_INFORMATION1;

typedef struct _RTL_PROCESS_MODULES1 {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION1 Modules[1];
} RTL_PROCESS_MODULES1, *PRTL_PROCESS_MODULES1;

UCHAR charToHex(UCHAR * ch)
{
	unsigned char temps[2] = { 0 };
	for (int i = 0; i < 2; i++)
	{
		if (ch[i] >= '0' && ch[i] <= '9')
		{
			temps[i] = (ch[i] - '0');
		}
		else if (ch[i] >= 'A' && ch[i] <= 'F')
		{
			temps[i] = (ch[i] - 'A') + 0xA;
		}
		else if (ch[i] >= 'a' && ch[i] <= 'f')
		{
			temps[i] = (ch[i] - 'a') + 0xA;
		}
	}
	return ((temps[0] << 4) & 0xf0) | (temps[1] & 0xf);
}


void initFindCodeStruct(PFindCode findCode, PCHAR code, ULONG_PTR offset, ULONG_PTR lastAddrOffset)
{

	memset(findCode, 0, sizeof(FindCode));

	findCode->lastAddressOffset = lastAddrOffset;
	findCode->offset = offset;

	PCHAR pTemp = code;
	ULONG_PTR i = 0;
	for (i = 0; *pTemp != '\0'; i++)
	{
		if (*pTemp == '*' || *pTemp == '?')
		{
			findCode->code[i] = *pTemp;
			pTemp++;
			continue;
		}

		findCode->code[i] = charToHex(pTemp);
		pTemp += 2;

	}

	findCode->len = i;
}


ULONG_PTR findAddressByCode(ULONG_PTR beginAddr, ULONG_PTR endAddr, PFindCode  findCode, ULONG numbers)
{
	ULONG64 j = 0;
	LARGE_INTEGER rtna = { 0 };

	for (ULONG_PTR i = beginAddr; i <= endAddr; i++)
	{
		if (!MmIsAddressValid((PVOID)i))
		{
			i = i & (~0xfff) + PAGE_SIZE - 1;
			continue;
		}

		

		for (j = 0; j < numbers; j++)
		{
			FindCode  fc = findCode[j];
			ULONG_PTR tempAddress = i;

			UCHAR * code = (UCHAR *)(tempAddress + fc.offset);
			BOOLEAN isFlags = FALSE;

			for (ULONG_PTR k = 0; k < fc.len; k++)
			{
				if (!MmIsAddressValid((PVOID)(code + k)))
				{
					isFlags = TRUE;
					break;
				}

				if (fc.code[k] == '*' || fc.code[k] == '?') continue;

				if (code[k] != fc.code[k])
				{
					isFlags = TRUE;
					break;
				}
			}

			if (isFlags) break;

		}

		if (j == numbers)
		{
			rtna.QuadPart = i;
			rtna.LowPart += findCode[0].lastAddressOffset;
			break;
		}

	}

	return rtna.QuadPart;
}

char * CharToUper(char * wstr, BOOLEAN isAllocateMemory)
{
	char * ret = NULL;

	if (isAllocateMemory)
	{
		int len = strlen(wstr) + 2;
		ret = ExAllocatePool(PagedPool, len);
		memset(ret, 0, len);
		memcpy(ret, wstr, len - 2);
	}
	else
	{
		ret = wstr;
	}

	_strupr(ret);

	return ret;
}

ULONG_PTR QuerySysModule(char * MoudleName, _Out_opt_ ULONG_PTR * module)
{
	RTL_PROCESS_MODULES1 info;
	ULONG retPro = NULL;
	ULONG_PTR moduleSize = 0;

	NTSTATUS ststas = ZwQuerySystemInformation(11, &info, sizeof(info), &retPro);
	char * moduleUper = CharToUper(MoudleName, TRUE);

	if (ststas == STATUS_INFO_LENGTH_MISMATCH)
	{
		ULONG len = retPro + sizeof(RTL_PROCESS_MODULES1);
		PRTL_PROCESS_MODULES1 mem = (PRTL_PROCESS_MODULES1)ExAllocatePool(PagedPool, len);
		memset(mem, 0, len);
		ststas = ZwQuerySystemInformation(11, mem, len, &retPro);

		if (!NT_SUCCESS(ststas))
		{
			ExFreePool(moduleUper);
			ExFreePool(mem);
			return 0;
		}
		if (strstr(MoudleName, "ntkrnlpa.exe") || strstr(MoudleName, "ntoskrnl.exe"))
		{
			PRTL_PROCESS_MODULE_INFORMATION1 ModuleInfo = &(mem->Modules[0]);
			*module = ModuleInfo->ImageBase;
			moduleSize = ModuleInfo->ImageSize;
		}
		else
		{
			for (int i = 0; i < mem->NumberOfModules; i++)
			{
				PRTL_PROCESS_MODULE_INFORMATION1 processModule = &mem->Modules[i];
				CharToUper(processModule->FullPathName, FALSE);
				if (strstr(processModule->FullPathName, moduleUper))
				{
					if (module)
					{
						*module = processModule->ImageBase;

					}

					moduleSize = processModule->ImageSize;

					break;
				}

			}
		}

		ExFreePool(mem);
	}


	ExFreePool(moduleUper);
	return moduleSize;
}


ULONG_PTR searchNtCode(char * code,int offset)
{
	FindCode fs[1] = { 0 };
	initFindCodeStruct(&fs[0], code, 0, offset);


	SIZE_T moduleBase = 0;
	ULONG size = QuerySysModule("ntoskrnl.exe", &moduleBase);


	ULONG_PTR func = findAddressByCode(moduleBase, size + moduleBase, fs, 1);

	return func;
}

ULONG_PTR searchCode(char * moduleName, char * segmentName, char * code, int offset)
{
	FindCode fs[1] = { 0 };
	initFindCodeStruct(&fs[0], code, 0, offset);
	SIZE_T moduleBase = 0;
	ULONG size = QuerySysModule(moduleName, &moduleBase);

	if (!moduleBase)
	{
		return 0;
	}


	PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)moduleBase;

	PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)((PUCHAR)moduleBase + pDos->e_lfanew);

	PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNts);

	PIMAGE_SECTION_HEADER pTemp = NULL;

	for (int i = 0; i < pNts->FileHeader.NumberOfSections; i++)
	{
		char bufName[9] = {0};
		memcpy(bufName, pSection->Name, 8);
		if (_stricmp(bufName, segmentName) == 0)
		{
			pTemp = pSection;
			break;
		}
		pSection++;
	}

	if (pTemp)
	{
		moduleBase = pSection->VirtualAddress + moduleBase;
		size = pSection->SizeOfRawData;
	}

	PVOID mem = ExAllocatePool(NonPagedPool, size);
	SIZE_T retSize = 0;
	MmCopyVirtualMemory(IoGetCurrentProcess(), moduleBase, IoGetCurrentProcess(), mem, size, KernelMode, &retSize);
	
	ULONG_PTR func = findAddressByCode(moduleBase, size + moduleBase, fs, 1);
	ExFreePool(mem);
	return func;
}

ULONG_PTR searchCodeByModule(ULONG64 dllBase, char* segmentName, char* code, int offset)
{
	FindCode fs[1] = { 0 };
	initFindCodeStruct(&fs[0], code, 0, offset);
	SIZE_T moduleBase = dllBase;
	SIZE_T size = 0;
	if (!moduleBase)
	{
		return 0;
	}

	PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)moduleBase;

	PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)((PUCHAR)moduleBase + pDos->e_lfanew);

	PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNts);

	PIMAGE_SECTION_HEADER pTemp = NULL;

	for (int i = 0; i < pNts->FileHeader.NumberOfSections; i++)
	{
		char bufName[9] = { 0 };
		memcpy(bufName, pSection->Name, 8);
		if (_stricmp(bufName, segmentName) == 0)
		{
			pTemp = pSection;
			break;
		}
		pSection++;
	}

	if (pTemp)
	{

		moduleBase = pSection->VirtualAddress + moduleBase;
		size = pSection->SizeOfRawData;
	}

	PVOID mem = ExAllocatePool(NonPagedPool, size);
	SIZE_T retSize = 0;
	MmCopyVirtualMemory(IoGetCurrentProcess(), moduleBase, IoGetCurrentProcess(), mem, size, KernelMode, &retSize);

	ULONG_PTR func = findAddressByCode(moduleBase, size + moduleBase, fs, 1);
	ExFreePool(mem);
	return func;
}
```

## 隐藏模块

打开反汇编，看到jmp rcx的硬编码为`FF E1`。我们调用火哥的函数，在模块中搜索这个硬编码。

![image-20250817151749874](./%E5%9B%9E%E8%B0%83.assets/image-20250817151749874.png)



由于我们注册函数时会校验模块，而我们之前修改的flag是我们自己的模块，现在要通过http来实现隐藏，因此我们需要修改http的flag，使其能够绕过检测。

要拿到flag，我们就需要获取到对应的对象

![image-20250817152547705](./%E5%9B%9E%E8%B0%83.assets/image-20250817152547705.png)



![image-20250817153621182](./%E5%9B%9E%E8%B0%83.assets/image-20250817153621182.png)

![image-20250817153704418](./%E5%9B%9E%E8%B0%83.assets/image-20250817153704418.png)

成功注册函数，实现保护。

![image-20250817153829371](./%E5%9B%9E%E8%B0%83.assets/image-20250817153829371.png)

打开检测工具发现任然爆红，但可以看到以及成功的隐藏成HTTP驱动，那么该工具很有可能检测其是否为进程类型而爆红，因此我们可以伪装成NT模块

![image-20250817154121995](./%E5%9B%9E%E8%B0%83.assets/image-20250817154121995.png)

```
ULONG_PTR jmpRcxAddr = searchNtCode("FFE1", 0);
```

```c++
ULONG_PTR jmpRcxAddr = searchNtCode("FFE1", 0);

		DbgPrintEx(77, 0, "[db]:jmpRcxAddr = %llx\r\n", jmpRcxAddr);

		OB_OPERATION_REGISTRATION callinfo;


		OB_CALLBACK_REGISTRATION obcallbackInfo = { 0 };

		obcallbackInfo.Version = ObGetFilterVersion();
		obcallbackInfo.RegistrationContext = preCallback;//  NULL;
		obcallbackInfo.OperationRegistrationCount = 1;
		RtlInitUnicodeString(&obcallbackInfo.Altitude, L"12345");
		obcallbackInfo.OperationRegistration = &callinfo;

		callinfo.ObjectType = PsProcessType;
		callinfo.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
		callinfo.PreOperation = jmpRcxAddr;//preCallback;
		callinfo.PostOperation = NULL;

		NTSTATUS st = ObRegisterCallbacks(&obcallbackInfo, &hRegObjCallback);

		DbgPrintEx(77, 0, "[db]:%x\r\n", st);
```

nt模块没有驱动对象，无法通过之前修改flag的方式来绕过检测

![image-20250817154540490](./%E5%9B%9E%E8%B0%83.assets/image-20250817154540490.png)

方法一：我们需要对检测函数HOOK，当注册完函数以后还原

在静态分析`PspSetCreateProcessNotifyRoutine`时，我们可以看到它的检测函数`MmVerifyCallbackFunction`，因此寻找特征码，其中`74`作特征码，74的下一行为e8即为我们想要查找的函数。

![image-20250817155716577](./%E5%9B%9E%E8%B0%83.assets/image-20250817155716577.png)

这样做需要对版本进行兼容，因为不同版本找到它的特征码可能不同。



方法二：在驱动的链表里面我们可以找到ntos的进程结构，在那个里面直接修改

遍历链表查找nt模块，查找到以后直接将其flags部分或上0x20，绕过检测。

```c
PKLDR_DATA_TABLE_ENTRY ldr = (PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection;
	ldr->Flags |= 0x20;

	PLIST_ENTRY pNext = &ldr->InLoadOrderLinks;
	PLIST_ENTRY pTemp = pNext;
	
	UNICODE_STRING unName;
	RtlInitUnicodeString(&unName, L"ntoskrnl.exe");

	do
	{
		PKLDR_DATA_TABLE_ENTRY temp = (PKLDR_DATA_TABLE_ENTRY)pNext;



		if (temp->BaseDllName.Length && MmIsAddressValid(temp->BaseDllName.Buffer))
		{
			if (RtlCompareUnicodeString(&temp->BaseDllName, &unName, TRUE) == 0)
			{
				temp->Flags |= 0x20;
				break;
			}

			DbgPrintEx(77, 0, "[db]:%wZ\r\n", &temp->BaseDllName);
		}

		pNext = pNext->Flink;

	} while (pNext != pTemp);
```

成功注册

![image-20250817161031531](./%E5%9B%9E%E8%B0%83.assets/image-20250817161031531.png)

发现该工具可以检测到jmp rcx

这样就需要将jmp rcx构造复杂一些。

![image-20250817161118214](./%E5%9B%9E%E8%B0%83.assets/image-20250817161118214.png)

但在PCHunter中已经检测不到了

![image-20250817161322645](./%E5%9B%9E%E8%B0%83.assets/image-20250817161322645.png)

完整代码

```c++
#include <ntifs.h>
#include "Search.h"

HANDLE hRegObjCallback = NULL;


typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	// ULONG padding on IA64
	PVOID GpValue;
	PVOID NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	// ULONG padding on IA64
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

EXTERN_C NTSTATUS ObReferenceObjectByName(
	__in PUNICODE_STRING ObjectName,
	__in ULONG Attributes,
	__in_opt PACCESS_STATE AccessState,
	__in_opt ACCESS_MASK DesiredAccess,
	__in POBJECT_TYPE ObjectType,
	__in KPROCESSOR_MODE AccessMode,
	__inout_opt PVOID ParseContext,
	__out PVOID* Object
);
EXTERN_C POBJECT_TYPE* IoDriverObjectType;

PCHAR PsGetProcessImageFileName(PEPROCESS Process);

OB_PREOP_CALLBACK_STATUS preCallback(
	_In_ PVOID RegistrationContext,
	_Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
	PEPROCESS Process = (PEPROCESS)OperationInformation->Object;

	PEPROCESS currentProcess = IoGetCurrentProcess();   //OpenProcess

	if (Process != currentProcess)
	{
		PUCHAR srcName = PsGetProcessImageFileName(Process);

		if (_stricmp(srcName, "dwm.exe") == 0)
		{
			OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = 0;
		}
	}


	return OB_PREOP_SUCCESS;
}

VOID DriverUnload(_In_ struct _DRIVER_OBJECT* DriverObject)
{
	if(hRegObjCallback) ObUnRegisterCallbacks(hRegObjCallback);
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pRegUn)
{
	PKLDR_DATA_TABLE_ENTRY ldr = (PKLDR_DATA_TABLE_ENTRY)pDriver->DriverSection;
	ldr->Flags |= 0x20;

	PLIST_ENTRY pNext = &ldr->InLoadOrderLinks;
	PLIST_ENTRY pTemp = pNext;
	
	UNICODE_STRING unName;
	RtlInitUnicodeString(&unName, L"ntoskrnl.exe");

	do
	{
		PKLDR_DATA_TABLE_ENTRY temp = (PKLDR_DATA_TABLE_ENTRY)pNext;



		if (temp->BaseDllName.Length && MmIsAddressValid(temp->BaseDllName.Buffer))
		{
			if (RtlCompareUnicodeString(&temp->BaseDllName, &unName, TRUE) == 0)
			{
				temp->Flags |= 0x20;
				break;
			}

			DbgPrintEx(77, 0, "[db]:%wZ\r\n", &temp->BaseDllName);
		}

		pNext = pNext->Flink;

	} while (pNext != pTemp);



	//return STATUS_UNSUCCESSFUL;

	//UNICODE_STRING unName = { 0 };
	//RtlInitUnicodeString(&unName, L"\\driver\\http");
	//PDRIVER_OBJECT pFindObject = 0;
	//NTSTATUS st = ObReferenceObjectByName(&unName, OBJ_CASE_INSENSITIVE, NULL, NULL, *IoDriverObjectType, KernelMode, NULL, &pFindObject);
	//
	//if (NT_SUCCESS(st))
	{
		//ldr = (PKLDR_DATA_TABLE_ENTRY)pFindObject->DriverSection;
		//ldr->Flags |= 0x20;
		//
		//ObDereferenceObject(pFindObject);

		ULONG_PTR jmpRcxAddr = searchNtCode("FFE1", 0);

		DbgPrintEx(77, 0, "[db]:jmpRcxAddr = %llx\r\n", jmpRcxAddr);

		OB_OPERATION_REGISTRATION callinfo;


		OB_CALLBACK_REGISTRATION obcallbackInfo = { 0 };

		obcallbackInfo.Version = ObGetFilterVersion();
		obcallbackInfo.RegistrationContext = preCallback;//  NULL;
		obcallbackInfo.OperationRegistrationCount = 1;
		RtlInitUnicodeString(&obcallbackInfo.Altitude, L"12345");
		obcallbackInfo.OperationRegistration = &callinfo;

		callinfo.ObjectType = PsProcessType;
		callinfo.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
		callinfo.PreOperation = jmpRcxAddr;//preCallback;
		callinfo.PostOperation = NULL;

		NTSTATUS st = ObRegisterCallbacks(&obcallbackInfo, &hRegObjCallback);

		DbgPrintEx(77, 0, "[db]:%x\r\n", st);

	}


	
	pDriver->DriverUnload = DriverUnload;

	return STATUS_SUCCESS;
}

```

> 作业：
>
> 分析注册完了以后，注册函数返回的数据结构

## 句柄解除破图标

分析`ObRegisterCallbacks`函数所返回的 `PVOID *RegistrationHandle`参数

这个参数本质上是一个对象，我们可以去查看一下它的地址

单从数据的角度上来说，有两个字节为0x0100，还有两个字节是0x0001，那么我们可以猜测，这里是我们给出的版本号以及注册的个数

![image-20250818131957718](./%E5%9B%9E%E8%B0%83.assets/image-20250818131957718.png)

在其结构上，我们也可以看到这两个参数是连在一起的。

![image-20250818131655191](./%E5%9B%9E%E8%B0%83.assets/image-20250818131655191.png)

在version和count前面为了字节对其（64位地址，八字节对其），因此填充了4个字节。后面是我们传递给注册函数的回调函数地址。但我们传递给其注册的函数地址是jmp rcx， 但查看汇编时并不是，而是我们真正的回调函数，因此这里是

`RegistrationContext`，其值为我们传递的先回调函数地址。

接着，对于形如`0x000a000a`（并不是指值为0x000a而是说类似单个十六进制数的结构），其内容大多是Unicode，它的值代表了字符所占的字节长度。

![image-20250818132105543](./%E5%9B%9E%E8%B0%83.assets/image-20250818132105543.png)

我们在传递时将`Altitude`参数设置为12345，并且是宽字符格式，对应着就是十个字节。即0xa。为了验证，我们可以将后面的地址复制下来，用指令du查看对应的字符。

![image-20250818132544233](./%E5%9B%9E%E8%B0%83.assets/image-20250818132544233.png)

该地址刚好是结构结束后的首地址，其内容为12345

![image-20250818142416210](./%E5%9B%9E%E8%B0%83.assets/image-20250818142416210.png)

接着我们可以看到有一个两个相同的数据，这种结构我们可以猜测其为一个双向链表（其首尾地址都相同）

![image-20250818134731797](./%E5%9B%9E%E8%B0%83.assets/image-20250818134731797.png)

为了验证，我们可以查看一下该地址。发现`LIST_ENTRY`的值刚好指向双向链表的地址`fffff8a0 00e369e0`，表明该地方为双向链表地址

![image-20250818135130102](./%E5%9B%9E%E8%B0%83.assets/image-20250818135130102.png)

接着往下，我们可以看到有1h以及3h，这里的1h很有可能是count，表明我们前面逆向的那个count是错误的，我们暂时先不管，看3h

![image-20250818135519107](./%E5%9B%9E%E8%B0%83.assets/image-20250818135519107.png)

我们在选择拦截的句柄操作时传递的是或结构，结果为3h。那么这里就是拦截的类型。后面跟着的是一个地址，可以看到他为传回的对象的首地址，表明其保存了一个指向自己的指针。

![image-20250818135353346](./%E5%9B%9E%E8%B0%83.assets/image-20250818135353346.png)

接着的下面的地址值，我们看到其为对象类型结构地址。

![image-20250818140005934](./%E5%9B%9E%E8%B0%83.assets/image-20250818140005934.png)

后面的为函数地址，即我们传递给注册函数的函数地址

![image-20250818142037282](./%E5%9B%9E%E8%B0%83.assets/image-20250818142037282.png)

在后面是两个零，表示该结构结束。注意，我们只看到了先回调函数的地址，由于我们没有传入后回调函数的地址，因此为NULL。那么后回调函数地址应该就是紧接着先回调函数的后面的地址

那么大致上该结构的组成，我们就逆向出来了。

![image-20250818142846259](./%E5%9B%9E%E8%B0%83.assets/image-20250818142846259.png)

因此，我们拿到链表的地址以后，减去32字节就是完整的数据结构。

由此，我们能拿到完整的注册函数的返回结构，我们就可以反向的去找到该保护回调函数，然后替换其回调函数或者在函数中插入一个c0000003更甚者我们将其卸载掉.

判断某一回调函数的所属模块，进而看到其所属的驱动。如果是没有模块的我们就可以去判断它的硬编码。

例如如果是通过跳转jmp rcx 实现模块的隐藏，我们可以看其硬编码的情况，来拿到对应的真实的函数地址。

因此破图标的方式一：遍历进程的回调对象，替换函数或者打上补丁。

第二种方式为优先级：利用海拔越低，回调时优先级越低的机制。让保护模块，先保护句柄。我们在注册一个自己的模块，将优先级调低，在补上打开句柄的权限，就可以实现保护句柄的解除。

我们保持保护模块运行，然后编写一个低优先级的回调函数，由此可以补上对应的权限。

![image-20250818144341478](./%E5%9B%9E%E8%B0%83.assets/image-20250818144341478.png)

可以看到，保护模块失效。

![image-20250818144319382](./%E5%9B%9E%E8%B0%83.assets/image-20250818144319382.png)

方式三：利用对象类型标志，让回调不触发。

在对象结构中有一个TypeInfo属性，再往下看可以看到有`SupportsObjectCallbacks`，表明它基于一类对象类型来触发回调。由此我们就可以修改它的值，让它遇到某一类型时不再触发回调。

![image-20250818145304511](./%E5%9B%9E%E8%B0%83.assets/image-20250818145304511.png)

![image-20250818145246869](./%E5%9B%9E%E8%B0%83.assets/image-20250818145246869.png)

验证，该位的低字节为0x70，往后数两个字节的最高位为1，那么就修改其值为0.

![image-20250818145900498](./%E5%9B%9E%E8%B0%83.assets/image-20250818145900498.png)

再次打开，可以看到成功保护，其回调不生效。

![image-20250818150126778](./%E5%9B%9E%E8%B0%83.assets/image-20250818150126778.png)

这种方法有一定的弊端，即对于线程和进程对象类型，它是被PG（Protective Guarding）保护的，因此，我们只能暂时的进行修改，即我们要打开某一进程，先关闭回调触发，打开以后再回复，绕过对句柄的保护，而不能长期生效。

对于文件、事件、设备、驱动对象，修改它不会PG。

方式四：利用对象类型权限算法

对于对象类型，它的算法如下

`PROCESS_ALL_ACCESS & ValidAccessMask | RetainAccess`

那么如果我们将RetatinAccess的值变为PROCESS_ALL_ACCESS 的值，那么不论我们申请什么类型，最终拿到的都是全权限。

![image-20250818153845804](./%E5%9B%9E%E8%B0%83.assets/image-20250818153845804.png)

## 防止句柄降权

我们上述的操作只能破图标，如果进程在运行过程中执行了句柄降权的操作，那么我们在绕过初次打开句柄后由于句柄降权，又会限制我们打开进程句柄的权限。

过句柄降权

方式一：遍历句柄，提权。即句柄降权的相反的操作。

方式二：遍历句柄表，找到被打开的对象，创建一块内存大小约为(0x2000)复制对象，替换句柄内的该对象

例如我们要防止降权的目标进程为dwm.exe

于是我们申请(ExAllocatePool)一块内存，然后将系统对象复制过来

将这块内存的CR3，改为dwm对象地址的CR3

在win10下由于其对象地址是加密过的

于是我们将申请的内存地址左移16位以后或上dwm对象地址的低三位

并且修改权限。

由于我们创建的是一块假句柄，因此需要给该句柄的权限加上不可关闭，避免某些时候系统关闭句柄以后导致蓝屏。

于是，在内存里面，原本的指向dwm对象地址的位置，指向了我们申请的那块内存的地址，但那块地址里面的CR3于dwm对象的CR3相同，于是乎最终打开的还是dwm.exe，但是我们在外面表现的是打开所申请内存的地址。



![image-20250818155945566](./%E5%9B%9E%E8%B0%83.assets/image-20250818155945566.png)

注意，在复制的过程中，需要将地址的vadroot值相同，否则在高版本的Windows上由于其地址不同，最终很有可能导致出错

在保险一点，将安全工具里面的进程句柄抹掉，然后将进程保护起来，防止安全工具在枚举进程的时候找到你

过掉回调后，如果再想降低权限，需要在内核遍历进程以后，拿到私有句柄表才行。

