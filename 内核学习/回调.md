# 回调



回调，意味着只要就的一个逻辑，系统监视着某件事是否发生，当发生了以后就调用某件事情进行处理。

进程的创建、句柄保护、注册表、线程的创建等都可以监视



进程、线程的监控 模块的加载

在内核态屏蔽监控



API：

`PsSetLoadImageNotifyRoutine`：检测模块的加载，例如加载一个.dll

`PsSetCreateThreadNotifyRoutine`：监控线程的加载

`PsSetCreateProcessNotifyRoutine`：监控进程的加载

![image-20250816123148004](./%E5%9B%9E%E8%B0%83.assets/image-20250816123148004.png)

`PsSetCreateProcessNotifyRoutineEx`:通过该函数可以实现对进程的拒绝加载，即将监控某一进程的时候，可以实现过滤加载。



`PsSetCreateThreadNotifyRoutine`监控写法：

![image-20250816123750161](./%E5%9B%9E%E8%B0%83.assets/image-20250816123750161.png)

根据回调函数的原型（可以修改函数名，但回调函数的返回值与形参需要相同）进行编写我们自己的回调函数。



注册回调

![image-20250816123927079](./%E5%9B%9E%E8%B0%83.assets/image-20250816123927079.png)

这里等于注册了该函数两遍（实现时应该是对原本回调函数的覆盖），后面的标志位被修改。从而实现驱动在运行时回调函数不被删除，驱动卸载时回调被删除的效果。

回调函数的多次注册处理方式：

>1.**覆盖模式（大多数常见实现）​**​
>
>- **表现**：第二次注册会覆盖第一次的注册，最终只有最后一次注册生效。
>
>  **实现原理**：
>
>  - 回调通常以函数指针（或函数对象）的形式存储在某个数据结构（如哈希表、数组）中，键可能是事件类型或唯一标识符。
>  - 当重复注册时，系统会更新存储的指针/对象，直接替换旧值。
>
>### 2. **多次注册模式**
>
>- **表现**：每次注册都会保留，触发时回调会被调用多次。
>- 实现原理：
>  - 回调被存储在链表或数组中，允许重复条目。
>  - 触发时遍历所有注册的回调，依次执行
>
>### 3. **标志位修改（较少见）**
>
>- **表现**：重复注册仅修改内部状态（如启用/禁用标志），不覆盖回调本身。
>- 实现原理：
>  - 系统可能维护一个 `enabled` 标志，重复调用时仅更新标志位。
>  - 回调存储结构本身不变。



![image-20250816135852647](./%E5%9B%9E%E8%B0%83.assets/image-20250816135852647.png)



![image-20250816135614742](./%E5%9B%9E%E8%B0%83.assets/image-20250816135614742.png)



![image-20250816140038551](./%E5%9B%9E%E8%B0%83.assets/image-20250816140038551.png)



`PsSetCreateProcessNotifyRoutineEx`监控写法

同样，根据其回调函数的参数以及返回值要求，编写函数

![image-20250816140917582](./%E5%9B%9E%E8%B0%83.assets/image-20250816140917582.png)



![image-20250816141825267](./%E5%9B%9E%E8%B0%83.assets/image-20250816141825267.png)

通过CreationStatus，我们可以拒绝其打开进程。即通过CreationStatus可以进行过滤。

![image-20250816160023911](./%E5%9B%9E%E8%B0%83.assets/image-20250816160023911.png)

此时编译运行，由于API所需要的权限过高，导致系统不允许其注册。状态返回值是0xC0000022

![image-20250816150813858](./%E5%9B%9E%E8%B0%83.assets/image-20250816150813858.png)

通过IDA静态分析该函数，它底层调用的是别的函数

![image-20250816151019136](./%E5%9B%9E%E8%B0%83.assets/image-20250816151019136.png)

由于它返回的值是0xC0000022，因此我们需要去逆向这个返回值的代码，看看如何跳转到该代码区返回的。

对十进制数按下`H`可以看到它的十六进制数，发现其判断条件是一个函数，其函数名表示它是检查函数的标志位的。并且Flags影响其参数。这个Flags是从参数中传递出来的，而我们填入的`Remove`参数决定了标志位

![image-20250816151449585](./%E5%9B%9E%E8%B0%83.assets/image-20250816151449585.png)

![image-20250816151847279](./%E5%9B%9E%E8%B0%83.assets/image-20250816151847279.png)

![image-20250816153455186](./%E5%9B%9E%E8%B0%83.assets/image-20250816153455186.png)

![image-20250816153529425](./%E5%9B%9E%E8%B0%83.assets/image-20250816153529425.png)

我们在调用时，其参数选择的是False即传入的a2（flags）为2，那么v5就等于32，十六进制为0x20

进入到判断条件里面

![image-20250816155123898](./%E5%9B%9E%E8%B0%83.assets/image-20250816155123898.png)

由此，我们就有对应的解决方法

1.通过查找PsSetCreateProcessNotifyRoutineEx函数，我们自行调用其底层的函数`PspSetCreateProcessNotifyRoutine`，然后我们自己将Flags标志传入一个0，这样的话v5就是零，也就是我们穿传入检查函数的checkFlags为0。那么当函数存在其所属模块以后，由于先判断checkFlags，从而判断结果为true，返回1.

2.修改注册函数的`_KLDR_DATA_TABLE_ENTRY`，将它的Flags或上0x20，这样检测时，`v6->flags & checkFlags != 0`为真，成功注册



第二种写法：

将结构拷贝过来

```c++
typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	// ULONG padding on IA64
	PVOID GpValue;
	PVOID NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	// ULONG padding on IA64
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;
```

![image-20250816155820951](./%E5%9B%9E%E8%B0%83.assets/image-20250816155820951.png)



回调函数中通过CreateInfo，过滤进程打开

![image-20250816163247496](./%E5%9B%9E%E8%B0%83.assets/image-20250816163247496.png)

![image-20250816163254304](./%E5%9B%9E%E8%B0%83.assets/image-20250816163254304.png)

再次打开时，进程拒绝访问。

许多杀毒软件就是这样操作的，对进程的特征进行定义，然后传递到内核态去判断一下，如果满足某个病毒进程的特征，就拦截不允许运行。



> 进程创建的监控，可以拿到某些游戏进程的真实的CR3，因为其进程刚创建时，就会回调它。在该回调监控里面，我们拿到的CR3一定是最原始的CR3





`PsSetCreateThreadNotifyRoutine`线程监控写法：

同样，我们按照其回调函数的要求编写函数

![image-20250816164213490](./%E5%9B%9E%E8%B0%83.assets/image-20250816164213490.png)

![image-20250816164411299](./%E5%9B%9E%E8%B0%83.assets/image-20250816164411299.png)

![image-20250816164131581](./%E5%9B%9E%E8%B0%83.assets/image-20250816164131581.png)



![image-20250816164229304](./%E5%9B%9E%E8%B0%83.assets/image-20250816164229304.png)











`PsSetLoadImageNotifyRoutine`模块加载监控写法：

同理，找到其回调函数格式

![image-20250816165509604](./%E5%9B%9E%E8%B0%83.assets/image-20250816165509604.png)

![image-20250816165608955](./%E5%9B%9E%E8%B0%83.assets/image-20250816165608955.png)

![image-20250816165648932](./%E5%9B%9E%E8%B0%83.assets/image-20250816165648932.png)

注册以后，打开一个进程，可以看到其加载模块的信息

![image-20250816165659234](./%E5%9B%9E%E8%B0%83.assets/image-20250816165659234.png)

我们加载一个简单的驱动，可以看到它的PID是0。

**在对模块的监控里面。驱动加载返回的PID不是0就是4**

![image-20250816165734280](./%E5%9B%9E%E8%B0%83.assets/image-20250816165734280.png)



这是由于其底层调用的函数决定的。大多数驱动的加载调用的都是`NtLoadDriver`函数

![image-20250816165825444](./%E5%9B%9E%E8%B0%83.assets/image-20250816165825444.png)

![image-20250816165920533](./%E5%9B%9E%E8%B0%83.assets/image-20250816165920533.png)





![image-20250816170357537](./%E5%9B%9E%E8%B0%83.assets/image-20250816170357537.png)

这个加载队列本质上是一个线程池，当有非系统进程创建的时候，就让他在system线程里面跑一下

如果是system进程加载它是同步的，反之是异步的。

这种模块的检测，只针对文件。即如果使用内存加载，其没有文件存在，其本身就能绕过这类对文件的检查。



如果已知某一个检测模块，即打开进程以后，其需要加载检测模块去检测。那么我们通过模块检测函数，直接让它无法加载检测模块，或者不执行检测模块，就可以绕过进程的检测。

即检测到某一检测模块以后，我们写入入口点，或者编写代码，从而绕过检测

```
mov eax, 0xc0000001
ret
```

这个地方还可以dump，检测到该模块加载以后，由于我们一直模块的地址以及模块的大小，那么我们直接写文件就可以直接将其dump下去



模块的回调函数的运行契机是在修复完成后，执行入口点之前。

只有回调函数执行完成以后，才会执行入口点。所以在回调函数中将内存dump下来是可以的。



如何绕过拦截，即当进程加载的时候，关闭这个监控，当我的进程加载完成以后，再去打开该监控。





静态分析注册函数

在加载模块函数的注册函数里面，可以找到一个mask值，我们往上看其被调函数

![image-20250816173934538](./%E5%9B%9E%E8%B0%83.assets/image-20250816173934538.png)

可以看到，该mask值决定了当发生某一事件时，是否会调用其回调函数

![image-20250816174141453](./%E5%9B%9E%E8%B0%83.assets/image-20250816174141453.png)





同理，到了线程的创建回调函数中，我们也可以看到一个mask想关联的值为0x10和0x08

![image-20250816174253390](./%E5%9B%9E%E8%B0%83.assets/image-20250816174253390.png)

![image-20250816174412492](./%E5%9B%9E%E8%B0%83.assets/image-20250816174412492.png)



因此，我们只需要修改Mask值，将它的值变为0，之后所有的flag值与上其结果都为false，从而不再去调用回调函数。