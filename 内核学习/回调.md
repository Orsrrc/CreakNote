# 回调



回调，意味着只要就的一个逻辑，系统监视着某件事是否发生，当发生了以后就调用某件事情进行处理。

进程的创建、句柄保护、注册表、线程的创建等都可以监视



进程、线程的监控 模块的加载

在内核态屏蔽监控



API：

`PsSetLoadImageNotifyRoutine`：检测模块的加载，例如加载一个.dll

`PsSetCreateThreadNotifyRoutine`：监控线程的加载

`PsSetCreateProcessNotifyRoutine`：监控进程的加载

![image-20250816123148004](./%E5%9B%9E%E8%B0%83.assets/image-20250816123148004.png)

`PsSetCreateProcessNotifyRoutineEx`:通过该函数可以实现对进程的拒绝加载，即将监控某一进程的时候，可以实现过滤加载。



`PsSetCreateThreadNotifyRoutine`监控写法：

![image-20250816123750161](./%E5%9B%9E%E8%B0%83.assets/image-20250816123750161.png)

根据回调函数的原型（可以修改函数名，但回调函数的返回值与形参需要相同）进行编写我们自己的回调函数。



注册回调

![image-20250816123927079](./%E5%9B%9E%E8%B0%83.assets/image-20250816123927079.png)

这里等于注册了该函数两遍（实现时应该是对原本回调函数的覆盖），后面的标志位被修改。从而实现驱动在运行时回调函数不被删除，驱动卸载时回调被删除的效果。

回调函数的多次注册处理方式：

>1.**覆盖模式（大多数常见实现）​**​
>
>- **表现**：第二次注册会覆盖第一次的注册，最终只有最后一次注册生效。
>
>  **实现原理**：
>
>  - 回调通常以函数指针（或函数对象）的形式存储在某个数据结构（如哈希表、数组）中，键可能是事件类型或唯一标识符。
>  - 当重复注册时，系统会更新存储的指针/对象，直接替换旧值。
>
>### 2. **多次注册模式**
>
>- **表现**：每次注册都会保留，触发时回调会被调用多次。
>- 实现原理：
>  - 回调被存储在链表或数组中，允许重复条目。
>  - 触发时遍历所有注册的回调，依次执行
>
>### 3. **标志位修改（较少见）**
>
>- **表现**：重复注册仅修改内部状态（如启用/禁用标志），不覆盖回调本身。
>- 实现原理：
>  - 系统可能维护一个 `enabled` 标志，重复调用时仅更新标志位。
>  - 回调存储结构本身不变。



![image-20250816135852647](./%E5%9B%9E%E8%B0%83.assets/image-20250816135852647.png)



![image-20250816135614742](./%E5%9B%9E%E8%B0%83.assets/image-20250816135614742.png)



![image-20250816140038551](./%E5%9B%9E%E8%B0%83.assets/image-20250816140038551.png)



`PsSetCreateProcessNotifyRoutineEx`监控写法

同样，根据其回调函数的参数以及返回值要求，编写函数

![image-20250816140917582](./%E5%9B%9E%E8%B0%83.assets/image-20250816140917582.png)



![image-20250816141825267](./%E5%9B%9E%E8%B0%83.assets/image-20250816141825267.png)