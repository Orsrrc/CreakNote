# 系统调用

-------------

注入时通过系统调用绕过一些钩子

深入理解 操作系统 R3->R0->R3 这个过程

## 基本概念

在三环开发的一个程序，必然会调用部分的系统级API，这部分系统API保存在内核部分。一个EXE里面包含了内核文件

在Win7以前是kernel32，当exe文件想要调用系统API的时候，就去调用kernel.dll，然后通过kermel访问该系统API所在的模块.dll，去内核里面查询这个函数API。

例如，exe想要访问OpenProcess，那么从Kernel32中去查询kernel.OpenProcess，拿到所在的dll，然后再去调用ntdll.OpenProcess，此时就进入了内核。在内核中有一张系统调用表SSDT，这个表里面存储了系统调用函数的入口地址。

从三环到内核去查找系统调用时，会传一个索引，去找到这个系统调用。

调用一个函数，它需要三个要素，分别是函数名、返回值、参数个数。

由此我们可以看到，如果有一张函数表，就必定会有对应的参数个数表。根据这个参数个数表才可以知道，调用函数需要从堆栈里面拿出几个字节，否则调用一定不会成功。

到了Win7以上系统，它为了兼容以前编写的程序，所以在exe调用kernel32这一步没有变，它在下面加了一层KernelBase.dll，也就是，**exe调用kernel32了以后**，**Kernel32**不直接去访问API所在的DLL，而是**调用KernelBase.dll，然后再去访问系统调用所在的DLL**。

![image-20250727153842952](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727153842952.png)

验证：

![image-20250727161143411](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727161143411.png)

![image-20250727161218207](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727161218207.png)

打开OD动态的运行跟进

函数入口：

![image-20250727162453115](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727162453115.png)

可以看到，在汇编代码层面，CALL调用函数以后，进入到了kernel32里面，在Kernel32中jmp到了kernelBase里面

![image-20250727162535454](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727162535454.png)

到了KernelBase里面以后，又会跳转到ntdll里面去执行一个ntdll.ZwOpenProcess这样一个函数

![image-20250727162905482](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727162905482.png)

在ntdll里面调用函数时，压入了两个参数，一个就是索引值占一字节，然后将一个地址压入edx，在call edx。那就代表这个地址就是一个函数的地址。

![image-20250727163035480](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727163035480.png)

进入到函数里面以后可以看到它调用了一个`sysenter`的一个指令，在Intel的用户开发手册上面可以看到这个指令的作用。

![image-20250727163349189](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727163349189.png)

可以看到`sysenter`指令与`SYSEXIT`指令是成对出现的一个指令。

![image-20250727163440096](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727163440096.png)

将Win7的内核文件拷贝出来，静态分析Kernel32、KernelBase、ntdll

![image-20250727164005345](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727164005345.png)

放到ida里面去进行逆向，找到OpenProcess函数。

![image-20250727164723379](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727164723379.png)

在导出表里面我们可看到，这个OpenProcess来自一个API-MS-Win-xxx的一个模块，这与我们**动态调试时，看到的内存跳转的模块不同。**

![image-20250727164824259](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727164824259.png)

该模块并不存在，其**实际含义是一个快捷方式，指向KernelBase**。



## 静态分析

Kernel32的OpenProcess函数。

可以看到是一段无用的代码，我们接着看KernaklBase里面的代码

![image-20250727171736242](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727171736242.png)

KernelBase.dll中的OpenProcess

调用时传入三个参数

![image-20250727171959476](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727171959476.png)

在往下一层调用的时候需要四个参数

![image-20250727172135428](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727172135428.png)

`esi edi edx ebx`这类寄存器叫做非易变寄存器，顾名思义，其值在函数执行完成以后通常是不会改变的。因此，在一些函数的汇编代码里面通常可以看到将非易变寄存器的值压入栈中进行保存，然后在函数返回之前还原。

由于先前已经进行了保存，因此，使用的时候就可以当做通用寄存器使用，存储任意的数据。

![image-20250727174240383](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727174240383.png)

获取传入的参数

传入的参数放在堆栈之中，可以看到，它在函数开头在堆栈里面压入了一个ebp。

分析一下堆栈，可以看到，原本从CALL调用KernalBase.Process，堆栈里面会存放ret地址，然后想要取到传入的参数1，就需要读取4个字节。在一开始压入一个ebp以后，**栈顶指针esp往上4字节，拿到参数一由4字节变为八字节**。

![image-20250727172745537](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727172745537.png)

通过上面的符号内容注释，或者选中符号按下C键还原为十六进制数，我们可看到，类似[ebp+dwProcessId]这样的取值，即为取到对应的传入参数的数据。

![image-20250727180213480](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727180213480.png)

![image-20250727171542704](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727171542704.png)

紧接着，可以看到开辟了一块内存空间，存放了一个八字节的临时变量`_CLIENT_ID`，这个变量为了调用函数而封装。

`_CLIENT_ID`其对应于一个结构，这个结构里面存放着进程和线程的ID，在调用句柄的时候，我们需要用到进程ID，以及调用线程ID

![image-20250727173432037](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727173432037.png)

```
neg eax
sbb eax, eax
and eax,2
```

对于这样形式的汇编代码，其逻辑就是一个三元表达式类似于`1>2?1:0`。`neg`指令，表示取补码。即将寄存器里面的值取其补码后放回。

![image-20250727173602508](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727173602508.png)

![image-20250727173331681](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727173331681.png)

可以看到这里的bInheritHandle其值为2或者0，对应着句柄是否可继承，是一个flag。

调用系统API的时候，通常会认为是通过内核对象来调用，因此，由于ntdll需要传入ObjectAttributes，这个结构，而这个结构并不是从kernal32传入的，所以额外需要打包一整个结构传入。

![image-20250727173853829](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727173853829.png)

当我们没有汇编代码的符号的时候，在这里看到的就是一串十六进制数。那么我们很难判断出这里是否有ClientId这样一个结构

对于这样一种形式的汇编代码其大概率就是给一个结构赋值。由于esi是一个非易变寄存器，将其赋值给一个结构，那么大概率是给这个结构置空。

![image-20250727174625472](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727174625472.png)

可以看到，在没有符号的时候，但看一句`mov[ebp-4],esi`很难判断这里究竟是不是一个结构，但多个指令为一段连续的内存空间赋值，就可以判断出这里是给一个结构初始化。

在调用NtOpenProcess的时候需要4个参数，那么在上面的汇编代码里面一定已经完成了4个参数的压入。

![image-20250727182559752](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727182559752.png)

在看不到源码，并且没有符号的一个情况下，我们如果也想调用NtOpenProcess这个函数，就只能去试错，因为我们只知道传入4个参数，但是参数的大小并不知道。假设，我们按照该函数的调用方法压入四个参数，但是由于不知道clientId占8个字节，只传入4个字节，最后不成功，只能继续检查，然后尝试传入8个字节的指针，继续尝试调用。即不知道具体的函数调用方法的时候，只能通过枚举所有的可能来一步一步尝试，别无他法。

> 由于我们分析的是系统内核代码，因此，可以从Wrk中看到源码，可以看到，除了传入的三个参数外，KernalBase内部封装了ObjectAttributes参数给NtOpenProcess。![image-20250727174940549](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727174940549.png)
>
> `_CLIENT_ID`其内部保存了进程ID和线程ID，与我们静态分析的结果一致
>
> ![image-20250727175044466](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727175044466.png)

该函数本质上，将现有的参数封装为4个参数，然后调用NtProcess。

接着分析ntdll

可以看到，在kernalBase里面，其调用的时候的函数名是NtOpenProcess，但在ntdll中我们搜索不到这个函数。

我们搜索OpenProcess，可以看到有两个函数NtOpenProcess 和ZwOpenProcess，

![image-20250727184057655](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727184057655.png)

跟进观察可以看到，其本质上一个函数导出了两个函数名，在三环下调用的时候，由于两个函数所指向的函数地址相同，因此，都可以用于调用。

![image-20250727184133157](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727184133157.png)

在ntdll中可以看到，eax = 0xBE，edx = 0x7FFE0300h，这个地址实际上是一个`_KUSER_SHARED_DATA`结构的地址，这个地址三环和零环共享的一个结构，即在三环和零环下访问不同的虚拟地址，但其实际的物理页是同一个。

![image-20250727184307887](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727184307887.png)

这里需要记住的是OpenProcess的ID是0xBE，以及edx里面保存着三环的堆栈，即edx = esp。

![image-20250727190534904](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727190534904.png)

验证：

![image-20250727185210850](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727185210850.png)

由于我们在通过int 3进行中断，此时，中断的是system进程，它没有三环的环境，因此我们切换到一个有三环环境的进程。任意查询一个进程的ID，然后通过`.process /i `指令附加到上面，由于我们无法直接查询到进程，那么`.process`后面不跟选项，通过其报错信息可以看到我们目前所在的进程，表明我们切换进程环境成功。

![image-20250727185402056](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727185402056.png)

紧接着我们来解析一下该结构表，0x300表示一个偏移，我们将偏移减去然后拿到函数的入口地址

![image-20250727185651842](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727185651842.png)

查看函数的汇编代码，可以看到这与我们动态调试时其调用的函数是同一个。

![image-20250727185750508](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727185750508.png)

> 我们是否可以HOOK住这张表里面的函数，从而达到执行我们自己代码的目的？
>
> 首先，在三环下我们可以看到，该结构所在的物理页是不可写的，其次当修改了表中的函数时，所有进程的系统调用都会调用到我们的HOOK函数里面。
>
> 在零环下，该页是可写的。
>
> ![image-20250727185925328](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727185925328.png)
>
> 假设，我们单独给进程一个物理页，让其余进程走原本的表，目标进程走我们的表，那么在HOOK某一函数的时候，其余的函数也需要去修改。例如，里面一些获取时间的函数，由于物理页的修改，导致其获取时间失败，最终，对于游戏进程等等，如果时间不同步，那么执行对应的恶意代码也就没有意义了。
>
> ![image-20250727190141124](./%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.assets/image-20250727190141124.png)