# 101012页

## 101012的含义

这里的数字代表一种线性地址的划分方式，在32bit系统下，取前10bit 中10bit  后12bit  对应于**101012**。

Win7所采用的默认方式2 9 9 12，**29912**也即为将地址拆为4部分。而64bit系统里面呢，采用的是9 9 9 9 12，即**999912**对应于将地址拆为五部分。

对于一个线性地址，例如，假设有一串字符串，其线性地址为`0x12345678`，汇编代码`mov eax, dword ptr ds:[0x12345678]`，思考，系统是如何读到这块线性地址的物理页拿到其物理地址和数据返回给客户的？

现手动模拟一下，首先用CE，查找这段字符串的线性地址。

![image-20250703113111388](./%E9%A1%B5.assets/image-20250703113111388.png)

根据窗口查找该进程，并点击open打开进程。其本质是拿到该窗口的句柄(handle)，拿到窗口句柄以后，再求出窗口句柄的进程ID，然后再打开该进程，返回其进程句柄，有了这个进程句柄之后，就可以通过其读写函数，跨进程读写。

![image-20250703114039720](./%E9%A1%B5.assets/image-20250703114039720.png)

打开Setting，勾选这几个选项

![image-20250703115254237](./%E9%A1%B5.assets/image-20250703115254237.png)

勾选UTF-16 勾选以后呢，搜索就是按照Unicode来搜索的，否则就是默认按照ASCII码来搜索。

![image-20250703115348516](./%E9%A1%B5.assets/image-20250703115348516.png)

对于不匹配的地址，删去。

![image-20250703115524733](./%E9%A1%B5.assets/image-20250703115524733.png)

现在想要精确的找到该字符串地址有两种方法，一是修改exe中字符串的值，查看CE里面数据的变化，当然，多数情况下，比较核心部分的数据地址exe是不会让你修改的，对于游戏部分，可以玩家自行的控制掉血条等方法。第二呢就是从CE里面来修改Value部分的值。

![image-20250703115546258](./%E9%A1%B5.assets/image-20250703115546258.png)

在CE中修改的部分，在文本文档中也修改了，表明该地址就是字符串的线性地址。

![image-20250703120111317](./%E9%A1%B5.assets/image-20250703120111317.png)

软件方面，windows是通过进程的PID来区分一个进程的，而在硬件方面，英特尔通过不同的CR3来确认不同的内存区域的。

CR3代表进程的物理地址的启始。

在windbg中找到进程的CR3，在Windbg中就是进程的DirBase字段

![image-20250703121733634](./%E9%A1%B5.assets/image-20250703121733634.png)

根据101012划分规则，可以将字符串的地址0x0044E130 进行划分   低12bit对应于0x130    中10bit 将0x0044E进行拆分，变为      00 0100 1110~b~ ，高10bit对应于      0000 0000 01~b~ 补全为16进制即为   0x001  0x04E  **这两个值便是索引值**，即**在101012下  32bit地址中前10bit 中10bit对应于索引值**，拿到这个索引值以后，在101012下，索引值代表个数，而一个个数的单位为4Byte，也即是，拿到索引值之后，对应部分的索引值应该乘以4，这里便是0x001\*4、0x04E\*4。

## 英特尔的寻址方式

`d`指令查看的是虚拟地址 `!d`查看的是物理地址，下面演示的是英特尔是如何通过CR3计算出物理地址的，首先是读取进程CR3，然后进程CR3+前10bit索引值*4  `!dd 69ef0000+1*4`

![image-20250703123855411](./%E9%A1%B5.assets/image-20250703123855411.png)

得到的首地址的四个字节后  抹去后12位  即6a4d0867->6a4d0000，然后将线性地址的中10bit的索引值拿过来*4，

得`!dd 6a4d0000+04e*4`

![image-20250703124702610](./%E9%A1%B5.assets/image-20250703124702610.png)

在将前4字节拿过来同样抹去低12bit 6997b867->6997b000，得到的值加上线性地址的后12bit，这里的12bit不用乘以4得`!dd 6997b000+130`

![image-20250703124858045](./%E9%A1%B5.assets/image-20250703124858045.png)

这样就从物理地址获取到字符串的值。

![image-20250703125113274](./%E9%A1%B5.assets/image-20250703125113274.png)

在保护模式下，为了将进程进行隔离，同一个虚拟地址，在不同的进程下的值是不一样的，所以，CPU不能直接读取虚拟地址来获取数据。

在101012中，前10bit叫做PDE（Page Dir Element），即页目录号，中间10bit叫做PTE（Page Table Element ），即页表号，后12bit叫页内偏移。在**101012下，CR3叫页目录表**。**在101012下，一个CR3里面最多有4096/4 = 1024个PDE，一个进程的内存大小最大为1024(页目录数)\*1024(页表数)\*4096(一个页表大小)Byte =  4GB**

> 为什么页内偏移是12bit呢?
>
> 在电脑端，一个页表的大小是4096Byte，对应于2^12^，刚好是12bit，也就是说，**12bit可以在一个页的大小内进行寻址。**

> 为什么页目录号的地址以及页表号的地址要乘以4呢？
>
> ![image-20250703132237594](./%E9%A1%B5.assets/image-20250703132237594.png)
>
> 一个页目录表，里面的元素都是PDE，而在32bit系统下，在没有开启PAE的情况下，**默认用于识别地址的总线长度为32bit**，也即是用于识别地址的总线共有32根，**那么一个PDE的最大长度也就只有32bit，对应4字节**，因此，**在查找页目录号，页表号的时候需要乘以4**，得到对应PDE、PTE的首地址，而对应的页内偏移就只用在查询到目标地址所在的那一物理页里面进行相加即可。

![image-20250703134549362](./%E9%A1%B5.assets/image-20250703134549362.png)

**注意，逻辑上相邻，物理上并不一定相邻。**两个PDE，在PDT上相邻，但他们所指向的页表不一定相邻，同理，两个PTE在PTT表上相邻，但它们所指向的物理内存空间不一定相邻。

32bit线性地址的划分

![image-20250703140529503](./%E9%A1%B5.assets/image-20250703140529503.png)

## 页目录地址的划分

> 在101012下的地址划分，没有区分代码段和数据段，也即为，该页地址划分中，没有执行位，或者说判断是否可执行的权限。因此，**只要是内存，在101012下，就可以被执行。**这也导致了可以通过堆栈，可以修改返回值，跳转到恶意的堆栈内存区域执行。在该环境下，Windows里面的页表属性是无意义的，它只能知道是否可读可写。

那么，在寻找物理地址的时候，为什么要将PDE的地址的低12位置为0呢？

![image-20250703142227722](./%E9%A1%B5.assets/image-20250703142227722.png)

对于PDE和PTE的划分，可以看到低12bit都是用于描述该段的信息的。

### P位

Present表示是否有效，PDE.P=1表示该页目录表有效，反之，表示该页目录表无效。当PDE.P= 0 即页目录表无效的时候，其地址指向的PET无效或者是不存在。

所以，在**整个查找的过程中，只获取每个页的基址部分，后面的12位由虚拟地址来提供**。

#### 验证P位

![image-20250703145604113](./%E9%A1%B5.assets/image-20250703145604113.png)

运行以后，得到x的线性地址0x1187000，对其进行划分00 0000 0100   01 1000 0111 0x000

在Windbg中将x所在的内存页的p位改为无效，看是否还能读取到x的值

![image-20250703145635225](./%E9%A1%B5.assets/image-20250703145635225.png)

找到进程的CR3

![image-20250703145857572](./%E9%A1%B5.assets/image-20250703145857572.png)

找到x的页地址，且x的偏移为0，也就是页的首地址里面放的就是x的值

![image-20250703145918741](./%E9%A1%B5.assets/image-20250703145918741.png)

找到x的物理地址

![image-20250703150034475](./%E9%A1%B5.assets/image-20250703150034475.png)

将x所在的页的p位改为0

![image-20250703150224628](./%E9%A1%B5.assets/image-20250703150224628.png)

![image-20250703150241490](./%E9%A1%B5.assets/image-20250703150241490.png)

> 缓存:
> 由于CPU提前读取了代码，将代码的数据等放入了流寄存器里面，因此呢，在代码执行到读取x的值的时候，是可以打印出来的，但CPU去访问这段内存页的时候，会报错，并且，如果这段内存页还有别的系统进程再使用的话，那很容易蓝屏。

![image-20250703150603024](./%E9%A1%B5.assets/image-20250703150603024.png)

![image-20250703150608954](./%E9%A1%B5.assets/image-20250703150608954.png)

可以看到，程序可以正确打印，但是调试器中报错。

### R/W位

即读写权限位，当R/W = 0 的时候，代表这个段是只读的，R/W = 1的时候代表是可写的

当硬件的读写权限和软件读写权限相冲突的时候，例如，Windows下，这页是可写的，但是，在其R/W是为0，代表只读的，那就会冲突，但以硬件层面为准，Windows下只是一个模拟的状态。在软件层面的页表的权限和硬件层面的页表权限没有太大的关联。

![image-20250704110912174](./%E9%A1%B5.assets/image-20250704110912174.png)

对于R/W位，**只有PDE和PTE中的R/W位都为1，才代表PTE所指向的那一页是可读可写的**，否则，是不可以写的，只可以读的。

#### 验证R/W

```c
char *str = "abc";
str[0] = 'A';
```

修改abc所在的这块内存的第一个字节的时候会报错，这是因为**字符串字面量**在编译时会被放入只读数据段(.rodata段）该内存区域由操作系统标记为**只读**（Read-Only），物理存储通常位于程序的代码段或嵌入式系统的FLASH中。

此时

- 操作系统层面：只读段受内存管理单元（MMU）保护，尝试写入会触发SIGSEGV等信号，导致程序崩溃。

- 硬件层面：**CPU的页表项**中设置只读标志位（RW=0），任何修改请求会被拦截。

若需可修改的字符串，应使用**字符数组**：

```c
char str[] = "abc"; // 栈上分配可修改的数组
str[0] = 'c';      // 合法操作
```

此时字符串在栈或堆中（可写），而非只读区。

![image-20250704120153863](./%E9%A1%B5.assets/image-20250704120153863.png)

尝试修改字面量的R/W值，对其进行修改。

![image-20250704120302453](./%E9%A1%B5.assets/image-20250704120302453.png)

将虚拟地址按照101012进行划分有，2(0000 0010)  375(11 0x75)  ( 7B8)，找到进程的CR3进行查找

![image-20250704120805277](./%E9%A1%B5.assets/image-20250704120805277.png)

将PTE的R/W位改为1

![image-20250704121450340](./%E9%A1%B5.assets/image-20250704121450340.png)

在运行程序的时候，需要等一会，让系统将缓存刷新一下。

![image-20250704121517027](./%E9%A1%B5.assets/image-20250704121517027.png)

程序不再报错，写入成功。

![image-20250704121541254](./%E9%A1%B5.assets/image-20250704121541254.png)

> 那么系统是怎么知道这一块内存是不可写的呢，换句话说，系统是如何实现当有程序修改一块字面量的时候，报错的呢？
>
> 系统检测到字面量的时候，会将这块区域，编译到.rdata区。上面代码中的str只是保存了该字符串地址的引用而已。最终，系统将.rdata区整一块的区域的内存属性设置为只读的，最终导致修改的时候是报错。
>
> 因此，对于一个可执行文件里面的各种区域，例如**代码区，数据区等等其最终的实现方式都是编译器编译到不同的区域，在将这块内存区域的属性设置为只读、可写可读等等。**

将可执行文件放到小辣椒(CFF Explore VII)中

查看.data段于.rdata段，将.rdata段的字符特称修改为.data段的字符特征进行保存。

![image-20250704131820849](./%E9%A1%B5.assets/image-20250704131820849.png)

![image-20250704131921707](./%E9%A1%B5.assets/image-20250704131921707.png)

### U/S位

user/supervisor，即权限位置，U/S = 0表示特权用户可访问，U/S = 1表示普通用户可访问。

- 访问（u/s = 0）特权区地址

![image-20250704134001660](./%E9%A1%B5.assets/image-20250704134001660.png)

访问内存出错

![image-20250704134038778](./%E9%A1%B5.assets/image-20250704134038778.png)

将gdt表的虚拟地址进行划分，找到物理内存中的gdt表。

其中，GDT表所在的页的PDT 为0018a063 对应于0011即，u/s位为0.

![image-20250704134641810](./%E9%A1%B5.assets/image-20250704134641810.png)

现在将gdt表所在的页表中的u/s位改为1，修改对应的pde和pte，的u/s位

![image-20250704140415857](./%E9%A1%B5.assets/image-20250704140415857.png)

![image-20250704140521876](./%E9%A1%B5.assets/image-20250704140521876.png)

注意，需要将对应的g位置零，否则该页目录表会一直存在缓存里面，那么程序读取读取的就一直是在缓存里面的页目录表数据，不会更新。

![image-20250704140744891](./%E9%A1%B5.assets/image-20250704140744891.png)

同样，在运行程序的时候，切换一下进程，刷新缓存，程序继续运行，没有报错。访问成功，可以观察到gdt表的首地址的段描述符为0，因此这里打印的是零，表明访问成功。

![image-20250704140912030](./%E9%A1%B5.assets/image-20250704140912030.png)

### A位

accessed位，当该页被读取过（访问过），这页就会置为一。系统不会读取三环信息。

> 蜜罐Demo
>
> ![image-20250704142506592](./%E9%A1%B5.assets/image-20250704142506592.png)
>
> 共享内存不检测A位，检测映射区域的内存的A位，使用的时候，不读普通内存（蜜罐内存）的数据，只读写共享内存区域，然后共享内存中的数据写入到蜜罐内存中。
>
> 由于共享内存的地址不是从**基址+偏移地址**这样转移过来的。所以当有别人访问的时候，会去访问我们的蜜罐内存，A位置为1，攻击者掉入蜜罐。
>
> 如何破局？
>
> 手动的取出物理地址，映射读。其原理是，将这块物理地址映射出来以后（0x12345），让另一个地址也指向它，这样A与B指向同一块内存，但是读取B，修改的是B的A位，而不是A的A位（被检测的）
>
> ![image-20250704143703689](./%E9%A1%B5.assets/image-20250704143703689.png)



### D位

dirty 脏位，看是否被写过。注意PDE是没有脏位的，PTE有脏位，但通常由于有数据的校验，所以通常是不会去写入，或者说写入错误数据被校验修改回来的情况。





## 共享内存

如果进程A与进程B，使用了同一块内存，这块内存就叫共享内存，可以利用这个机制进行数据的传输。

现定义一个指针，在内存层面将其指向x的物理地址，看能否读出x的值

![image-20250703150747142](./%E9%A1%B5.assets/image-20250703150747142.png)

同理，找到进程的CR3，并打印x的地址，进行划分

![image-20250703150927927](./%E9%A1%B5.assets/image-20250703150927927.png)

![image-20250703151300417](./%E9%A1%B5.assets/image-20250703151300417.png)

由于a指针里面存的是0，也就是PDT表的第0号PDE，可以看到第零号PDE的页目录段里面是没有挂页的，我们将x所在的页地址挂到零号PDE的页目录里面。

![image-20250703152453496](./%E9%A1%B5.assets/image-20250703152453496.png)

成功访问。注意，这里需要多等一会或者打开几个进程，让缓存刷新一下，不然就会打印缓存里面的a指针所指地址的值。

![image-20250703152522679](./%E9%A1%B5.assets/image-20250703152522679.png)

## 申请内存

malloc不申请内存，除非申请的内存值特别大。

VirtualAlloc申请内存。观察，申请内存的时候，是否真的有对应的物理地址。

![image-20250704145753385](./%E9%A1%B5.assets/image-20250704145753385.png)

![image-20250704150051550](./%E9%A1%B5.assets/image-20250704150051550.png)

划分得到  00  0D 000。

![image-20250704145946370](./%E9%A1%B5.assets/image-20250704145946370.png)

可以观察到申请的这块内存的PDE是空的。即按照提交的方式申请内存，在没有初始化的时候，这块内存还是不存在的，即没有真正的物理地址。

> Windows内存的管理，是懒加载方式。也就说，在申请内存了以后，Windows提供的线性地址的物理地址是不存在的，只有当真正去访问的时候，产生了缺页异常，才会去看之前这块虚拟地址是否申请过，如果虚拟地址申请过，并且属性是对应的，才会去挂上物理页，此时这块内存才叫真正的申请了。

观察初始化以后的这块内存是否挂上页，成功申请。在写驱动的时候，要注意这个细节。

![image-20250704150950913](./%E9%A1%B5.assets/image-20250704150950913.png)

