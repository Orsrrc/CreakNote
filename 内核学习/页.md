# 101012页

## 101012的含义

这里的数字代表一种线性地址的划分方式，在32bit系统下，取前10bit 中10bit  后12bit  对应于**101012**。

Win7所采用的默认方式2 9 9 12，**29912**也即为将地址拆为4部分。而64bit系统里面呢，采用的是9 9 9 9 12，即**999912**对应于将地址拆为五部分。

对于一个线性地址，例如，假设有一串字符串，其线性地址为`0x12345678`，汇编代码`mov eax, dword ptr ds:[0x12345678]`，思考，系统是如何读到这块线性地址的物理页拿到其物理地址和数据返回给客户的？

现手动模拟一下，首先用CE，查找这段字符串的线性地址。

![image-20250703113111388](./%E9%A1%B5.assets/image-20250703113111388.png)

根据窗口查找该进程，并点击open打开进程。其本质是拿到该窗口的句柄(handle)，拿到窗口句柄以后，再求出窗口句柄的进程ID，然后再打开该进程，返回其进程句柄，有了这个进程句柄之后，就可以通过其读写函数，跨进程读写。

![image-20250703114039720](./%E9%A1%B5.assets/image-20250703114039720.png)

打开Setting，勾选这几个选项

![image-20250703115254237](./%E9%A1%B5.assets/image-20250703115254237.png)

勾选UTF-16 勾选以后呢，搜索就是按照Unicode来搜索的，否则就是默认按照ASCII码来搜索。

![image-20250703115348516](./%E9%A1%B5.assets/image-20250703115348516.png)

对于不匹配的地址，删去。

![image-20250703115524733](./%E9%A1%B5.assets/image-20250703115524733.png)

现在想要精确的找到该字符串地址有两种方法，一是修改exe中字符串的值，查看CE里面数据的变化，当然，多数情况下，比较核心部分的数据地址exe是不会让你修改的，对于游戏部分，可以玩家自行的控制掉血条等方法。第二呢就是从CE里面来修改Value部分的值。

![image-20250703115546258](./%E9%A1%B5.assets/image-20250703115546258.png)

在CE中修改的部分，在文本文档中也修改了，表明该地址就是字符串的线性地址。

![image-20250703120111317](./%E9%A1%B5.assets/image-20250703120111317.png)

软件方面，windows是通过进程的PID来区分一个进程的，而在硬件方面，英特尔通过不同的CR3来确认不同的内存区域的。

CR3代表进程的物理地址的启始。

在windbg中找到进程的CR3，在Windbg中就是进程的DirBase字段

![image-20250703121733634](./%E9%A1%B5.assets/image-20250703121733634.png)

根据101012划分规则，可以将字符串的地址0x0044E130 进行划分   低12bit对应于0x130    中10bit 将0x0044E进行拆分，变为      00 0100 1110~b~ ，高10bit对应于      0000 0000 01~b~ 补全为16进制即为   0x001  0x04E  **这两个值便是索引值**，即**在101012下  32bit地址中前10bit 中10bit对应于索引值**，拿到这个索引值以后，在101012下，索引值代表个数，而一个个数的单位为4Byte，也即是，拿到索引值之后，对应部分的索引值应该乘以4，这里便是0x001\*4、0x04E\*4。

## 英特尔的寻址方式

`d`指令查看的是虚拟地址 `!d`查看的是物理地址，下面演示的是英特尔是如何通过CR3计算出物理地址的，首先是读取进程CR3，然后进程CR3+前10bit索引值*4  `!dd 69ef0000+1*4`

![image-20250703123855411](./%E9%A1%B5.assets/image-20250703123855411.png)

得到的首地址的四个字节后  抹去后12位  即6a4d0867->6a4d0000，然后将线性地址的中10bit的索引值拿过来*4，

得`!dd 6a4d0000+04e*4`

![image-20250703124702610](./%E9%A1%B5.assets/image-20250703124702610.png)

在将前4字节拿过来同样抹去低12bit 6997b867->6997b000，得到的值加上线性地址的后12bit，这里的12bit不用乘以4得`!dd 6997b000+130`

![image-20250703124858045](./%E9%A1%B5.assets/image-20250703124858045.png)

这样就从物理地址获取到字符串的值。

![image-20250703125113274](./%E9%A1%B5.assets/image-20250703125113274.png)

在保护模式下，为了将进程进行隔离，同一个虚拟地址，在不同的进程下的值是不一样的，所以，CPU不能直接读取虚拟地址来获取数据。

在101012中，前10bit叫做PDE（Page Dir Element），即页目录号，中间10bit叫做PTE（Page Table Element ），即页表号，后12bit叫页内偏移。在**101012下，CR3叫页目录表**。**在101012下，一个CR3里面最多有4096/4 = 1024个PDE，一个进程的内存大小最大为1024(页目录数)\*1024(页表数)\*4096(一个页表大小)Byte =  4GB**

> 为什么页内偏移是12bit呢?
>
> 在电脑端，一个页表的大小是4096Byte，对应于2^12^，刚好是12bit，也就是说，**12bit可以在一个页的大小内进行寻址。**

> 为什么页目录号的地址以及页表号的地址要乘以4呢？
>
> ![image-20250703132237594](./%E9%A1%B5.assets/image-20250703132237594.png)
>
> 一个页目录表，里面的元素都是PDE，而在32bit系统下，在没有开启PAE的情况下，**默认用于识别地址的总线长度为32bit**，也即是用于识别地址的总线共有32根，**那么一个PDE的最大长度也就只有32bit，对应4字节**，因此，**在查找页目录号，页表号的时候需要乘以4**，得到对应PDE、PTE的首地址，而对应的页内偏移就只用在查询到目标地址所在的那一物理页里面进行相加即可。

![image-20250703134549362](./%E9%A1%B5.assets/image-20250703134549362.png)

**注意，逻辑上相邻，物理上并不一定相邻。**两个PDE，在PDT上相邻，但他们所指向的页表不一定相邻，同理，两个PTE在PTT表上相邻，但它们所指向的物理内存空间不一定相邻。

32bit线性地址的划分

![image-20250703140529503](./%E9%A1%B5.assets/image-20250703140529503.png)

## 页目录地址的划分

那么，在寻找物理地址的时候，为什么要将PDE的地址的低12位置为0呢？

![image-20250703142227722](./%E9%A1%B5.assets/image-20250703142227722.png)

对于PDE和PTE的划分，可以看到低12bit都是用于描述该段的信息的。

### P位

Present表示是否有效，PDE.P=1表示该页目录表有效，反之，表示该页目录表无效。当PDE.P= 0 即页目录表无效的时候，其地址指向的PET无效或者是不存在。

所以，在**整个查找的过程中，只获取每个页的基址部分，后面的12位由虚拟地址来提供**。

#### 验证P位

![image-20250703145604113](./%E9%A1%B5.assets/image-20250703145604113.png)

运行以后，得到x的线性地址0x1187000，对其进行划分00 0000 0100   01 1000 0111 0x000

在Windbg中将x所在的内存页的p位改为无效，看是否还能读取到x的值

![image-20250703145635225](./%E9%A1%B5.assets/image-20250703145635225.png)

找到进程的CR3

![image-20250703145857572](./%E9%A1%B5.assets/image-20250703145857572.png)

找到x的页地址，且x的偏移为0，也就是页的首地址里面放的就是x的值

![image-20250703145918741](./%E9%A1%B5.assets/image-20250703145918741.png)

找到x的物理地址

![image-20250703150034475](./%E9%A1%B5.assets/image-20250703150034475.png)

将x所在的页的p位改为0

![image-20250703150224628](./%E9%A1%B5.assets/image-20250703150224628.png)

![image-20250703150241490](./%E9%A1%B5.assets/image-20250703150241490.png)

> 缓存:
> 由于CPU提前读取了代码，将代码的数据等放入了流寄存器里面，因此呢，在代码执行到读取x的值的时候，是可以打印出来的，但CPU去访问这段内存页的时候，会报错，并且，如果这段内存页还有别的系统进程再使用的话，那很容易蓝屏。

![image-20250703150603024](./%E9%A1%B5.assets/image-20250703150603024.png)

![image-20250703150608954](./%E9%A1%B5.assets/image-20250703150608954.png)

可以看到，程序可以正确打印，但是调试器中报错。



## 共享内存

如果进程A与进程B，使用了同一块内存，这块内存就叫共享内存，可以利用这个机制进行数据的传输。

现定义一个指针，在内存层面将其指向x的物理地址，看能否读出x的值

![image-20250703150747142](./%E9%A1%B5.assets/image-20250703150747142.png)

同理，找到进程的CR3，并打印x的地址，进行划分

![image-20250703150927927](./%E9%A1%B5.assets/image-20250703150927927.png)

![image-20250703151300417](./%E9%A1%B5.assets/image-20250703151300417.png)

由于a指针里面存的是0，也就是PDT表的第0号PDE，可以看到第零号PDE的页目录段里面是没有挂页的，我们将x所在的页地址挂到零号PDE的页目录里面。

![image-20250703152453496](./%E9%A1%B5.assets/image-20250703152453496.png)

成功访问。注意，这里需要多等一会或者打开几个进程，让缓存刷新一下，不然就会打印缓存里面的a指针所指地址的值。

![image-20250703152522679](./%E9%A1%B5.assets/image-20250703152522679.png)