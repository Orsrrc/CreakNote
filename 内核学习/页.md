# 101012页

## 101012的含义

这里的数字代表一种线性地址的划分方式，在32bit系统下，取前10bit 中10bit  后12bit  对应于**101012**。

Win7所采用的默认方式2 9 9 12，**29912**也即为将地址拆为4部分。而64bit系统里面呢，采用的是9 9 9 9 12，即**999912**对应于将地址拆为五部分。

对于一个线性地址，例如，假设有一串字符串，其线性地址为`0x12345678`，汇编代码`mov eax, dword ptr ds:[0x12345678]`，思考，系统是如何读到这块线性地址的物理页拿到其物理地址和数据返回给客户的？

现手动模拟一下，首先用CE，查找这段字符串的线性地址。

![image-20250703113111388](./%E9%A1%B5.assets/image-20250703113111388.png)

根据窗口查找该进程，并点击open打开进程。其本质是拿到该窗口的句柄(handle)，拿到窗口句柄以后，再求出窗口句柄的进程ID，然后再打开该进程，返回其进程句柄，有了这个进程句柄之后，就可以通过其读写函数，跨进程读写。

![image-20250703114039720](./%E9%A1%B5.assets/image-20250703114039720.png)

打开Setting，勾选这几个选项

![image-20250703115254237](./%E9%A1%B5.assets/image-20250703115254237.png)

勾选UTF-16 勾选以后呢，搜索就是按照Unicode来搜索的，否则就是默认按照ASCII码来搜索。

![image-20250703115348516](./%E9%A1%B5.assets/image-20250703115348516.png)

对于不匹配的地址，删去。

![image-20250703115524733](./%E9%A1%B5.assets/image-20250703115524733.png)

现在想要精确的找到该字符串地址有两种方法，一是修改exe中字符串的值，查看CE里面数据的变化，当然，多数情况下，比较核心部分的数据地址exe是不会让你修改的，对于游戏部分，可以玩家自行的控制掉血条等方法。第二呢就是从CE里面来修改Value部分的值。

![image-20250703115546258](./%E9%A1%B5.assets/image-20250703115546258.png)

在CE中修改的部分，在文本文档中也修改了，表明该地址就是字符串的线性地址。

![image-20250703120111317](./%E9%A1%B5.assets/image-20250703120111317.png)

软件方面，windows是通过进程的PID来区分一个进程的，而在硬件方面，英特尔通过不同的CR3来确认不同的内存区域的。

CR3代表进程的物理地址的启始。

在windbg中找到进程的CR3，在Windbg中就是进程的DirBase字段

![image-20250703121733634](./%E9%A1%B5.assets/image-20250703121733634.png)

根据101012划分规则，可以将字符串的地址0x0044E130 进行划分   低12bit对应于0x130    中10bit 将0x0044E进行拆分，变为      00 0100 1110~b~ ，高10bit对应于      0000 0000 01~b~ 补全为16进制即为   0x001  0x04E  **这两个值便是索引值**，即**在101012下  32bit地址中前10bit 中10bit对应于索引值**，拿到这个索引值以后，在101012下，索引值代表个数，而一个个数的单位为4Byte，也即是，拿到索引值之后，对应部分的索引值应该乘以4，这里便是0x001\*4、0x04E\*4。

## 英特尔的寻址方式

`d`指令查看的是虚拟地址 `!d`查看的是物理地址，下面演示的是英特尔是如何通过CR3计算出物理地址的，首先是读取进程CR3，然后进程CR3+前10bit索引值*4  `!dd 69ef0000+1*4`

![image-20250703123855411](./%E9%A1%B5.assets/image-20250703123855411.png)

得到的首地址的四个字节后  抹去后12位  即6a4d0867->6a4d0000，然后将线性地址的中10bit的索引值拿过来*4，

得`!dd 6a4d0000+04e*4`

![image-20250703124702610](./%E9%A1%B5.assets/image-20250703124702610.png)

在将前4字节拿过来同样抹去低12bit 6997b867->6997b000，得到的值加上线性地址的后12bit，这里的12bit不用乘以4得`!dd 6997b000+130`

![image-20250703124858045](./%E9%A1%B5.assets/image-20250703124858045.png)

这样就从物理地址获取到字符串的值。

![image-20250703125113274](./%E9%A1%B5.assets/image-20250703125113274.png)

在保护模式下，为了将进程进行隔离，同一个虚拟地址，在不同的进程下的值是不一样的，所以，CPU不能直接读取虚拟地址来获取数据。

在101012中，前10bit叫做PDE（Page Dir Element），即页目录号，中间10bit叫做PTE（Page Table Element ），即页表号，后12bit叫页内偏移。在**101012下，CR3叫页目录表**。**在101012下，一个CR3里面最多有4096/4 = 1024个PDE，一个进程的内存大小最大为1024(页目录数)\*1024(页表数)\*4096(一个页表大小)Byte =  4GB**

> 为什么页内偏移是12bit呢?
>
> 在电脑端，一个页表的大小是4096Byte，对应于2^12^，刚好是12bit，也就是说，**12bit可以在一个页的大小内进行寻址。**

> 为什么页目录号的地址以及页表号的地址要乘以4呢？
>
> ![image-20250703132237594](./%E9%A1%B5.assets/image-20250703132237594.png)
>
> 一个页目录表，里面的元素都是PDE，而在32bit系统下，在没有开启PAE的情况下，**默认用于识别地址的总线长度为32bit**，也即是用于识别地址的总线共有32根，**那么一个PDE的最大长度也就只有32bit，对应4字节**，因此，**在查找页目录号，页表号的时候需要乘以4**，得到对应PDE、PTE的首地址，而对应的页内偏移就只用在查询到目标地址所在的那一物理页里面进行相加即可。

![image-20250703134549362](./%E9%A1%B5.assets/image-20250703134549362.png)

**注意，逻辑上相邻，物理上并不一定相邻。**两个PDE，在PDT上相邻，但他们所指向的页表不一定相邻，同理，两个PTE在PTT表上相邻，但它们所指向的物理内存空间不一定相邻。

32bit线性地址的划分

![image-20250703140529503](./%E9%A1%B5.assets/image-20250703140529503.png)

## 页目录地址的划分

> 在101012下的地址划分，没有区分代码段和数据段，也即为，该页地址划分中，没有执行位，或者说判断是否可执行的权限。因此，**只要是内存，在101012下，就可以被执行。**这也导致了可以通过堆栈，可以修改返回值，跳转到恶意的堆栈内存区域执行。在该环境下，Windows里面的页表属性是无意义的，它只能知道是否可读可写。

那么，在寻找物理地址的时候，为什么要将PDE的地址的低12位置为0呢？

![image-20250703142227722](./%E9%A1%B5.assets/image-20250703142227722.png)

对于PDE和PTE的划分，可以看到低12bit都是用于描述该段的信息的。

### P位

Present表示是否有效，PDE.P=1表示该页目录表有效，反之，表示该页目录表无效。当PDE.P= 0 即页目录表无效的时候，其地址指向的PET无效或者是不存在。

所以，在**整个查找的过程中，只获取每个页的基址部分，后面的12位由虚拟地址来提供**。

#### 验证P位

![image-20250703145604113](./%E9%A1%B5.assets/image-20250703145604113.png)

运行以后，得到x的线性地址0x1187000，对其进行划分00 0000 0100   01 1000 0111 0x000

在Windbg中将x所在的内存页的p位改为无效，看是否还能读取到x的值

![image-20250703145635225](./%E9%A1%B5.assets/image-20250703145635225.png)

找到进程的CR3

![image-20250703145857572](./%E9%A1%B5.assets/image-20250703145857572.png)

找到x的页地址，且x的偏移为0，也就是页的首地址里面放的就是x的值

![image-20250703145918741](./%E9%A1%B5.assets/image-20250703145918741.png)

找到x的物理地址

![image-20250703150034475](./%E9%A1%B5.assets/image-20250703150034475.png)

将x所在的页的p位改为0

![image-20250703150224628](./%E9%A1%B5.assets/image-20250703150224628.png)

![image-20250703150241490](./%E9%A1%B5.assets/image-20250703150241490.png)

> 缓存:
> 由于CPU提前读取了代码，将代码的数据等放入了流寄存器里面，因此呢，在代码执行到读取x的值的时候，是可以打印出来的，但CPU去访问这段内存页的时候，会报错，并且，如果这段内存页还有别的系统进程再使用的话，那很容易蓝屏。

![image-20250703150603024](./%E9%A1%B5.assets/image-20250703150603024.png)

![image-20250703150608954](./%E9%A1%B5.assets/image-20250703150608954.png)

可以看到，程序可以正确打印，但是调试器中报错。

### R/W位

即读写权限位，当R/W = 0 的时候，代表这个段是只读的，R/W = 1的时候代表是可写的

当硬件的读写权限和软件读写权限相冲突的时候，例如，Windows下，这页是可写的，但是，在其R/W是为0，代表只读的，那就会冲突，但以硬件层面为准，Windows下只是一个模拟的状态。在软件层面的页表的权限和硬件层面的页表权限没有太大的关联。

![image-20250704110912174](./%E9%A1%B5.assets/image-20250704110912174.png)

对于R/W位，**只有PDE和PTE中的R/W位都为1，才代表PTE所指向的那一页是可读可写的**，否则，是不可以写的，只可以读的。

#### 验证R/W

```c
char *str = "abc";
str[0] = 'A';
```

修改abc所在的这块内存的第一个字节的时候会报错，这是因为**字符串字面量**在编译时会被放入只读数据段(.rodata段）该内存区域由操作系统标记为**只读**（Read-Only），物理存储通常位于程序的代码段或嵌入式系统的FLASH中。

此时

- 操作系统层面：只读段受内存管理单元（MMU）保护，尝试写入会触发SIGSEGV等信号，导致程序崩溃。

- 硬件层面：**CPU的页表项**中设置只读标志位（RW=0），任何修改请求会被拦截。

若需可修改的字符串，应使用**字符数组**：

```c
char str[] = "abc"; // 栈上分配可修改的数组
str[0] = 'c';      // 合法操作
```

此时字符串在栈或堆中（可写），而非只读区。

![image-20250704120153863](./%E9%A1%B5.assets/image-20250704120153863.png)

尝试修改字面量的R/W值，对其进行修改。

![image-20250704120302453](./%E9%A1%B5.assets/image-20250704120302453.png)

将虚拟地址按照101012进行划分有，2(0000 0010)  375(11 0x75)  ( 7B8)，找到进程的CR3进行查找

![image-20250704120805277](./%E9%A1%B5.assets/image-20250704120805277.png)

将PTE的R/W位改为1

![image-20250704121450340](./%E9%A1%B5.assets/image-20250704121450340.png)

在运行程序的时候，需要等一会，让系统将缓存刷新一下。

![image-20250704121517027](./%E9%A1%B5.assets/image-20250704121517027.png)

程序不再报错，写入成功。

![image-20250704121541254](./%E9%A1%B5.assets/image-20250704121541254.png)

> 那么系统是怎么知道这一块内存是不可写的呢，换句话说，系统是如何实现当有程序修改一块字面量的时候，报错的呢？
>
> 系统检测到字面量的时候，会将这块区域，编译到.rdata区。上面代码中的str只是保存了该字符串地址的引用而已。最终，系统将.rdata区整一块的区域的内存属性设置为只读的，最终导致修改的时候是报错。
>
> 因此，对于一个可执行文件里面的各种区域，例如**代码区，数据区等等其最终的实现方式都是编译器编译到不同的区域，在将这块内存区域的属性设置为只读、可写可读等等。**

将可执行文件放到小辣椒(CFF Explore VII)中

查看.data段于.rdata段，将.rdata段的字符特称修改为.data段的字符特征进行保存。

![image-20250704131820849](./%E9%A1%B5.assets/image-20250704131820849.png)

![image-20250704131921707](./%E9%A1%B5.assets/image-20250704131921707.png)

### U/S位

user/supervisor，即权限位置，U/S = 0表示特权用户可访问，U/S = 1表示普通用户可访问。

- 访问（u/s = 0）特权区地址

![image-20250704134001660](./%E9%A1%B5.assets/image-20250704134001660.png)

访问内存出错

![image-20250704134038778](./%E9%A1%B5.assets/image-20250704134038778.png)

将gdt表的虚拟地址进行划分，找到物理内存中的gdt表。

其中，GDT表所在的页的PDT 为0018a063 对应于0011即，u/s位为0.

![image-20250704134641810](./%E9%A1%B5.assets/image-20250704134641810.png)

现在将gdt表所在的页表中的u/s位改为1，修改对应的pde和pte，的u/s位

![image-20250704140415857](./%E9%A1%B5.assets/image-20250704140415857.png)

![image-20250704140521876](./%E9%A1%B5.assets/image-20250704140521876.png)

注意，需要将对应的g位置零，否则该页目录表会一直存在缓存里面，那么程序读取读取的就一直是在缓存里面的页目录表数据，不会更新。

![image-20250704140744891](./%E9%A1%B5.assets/image-20250704140744891.png)

同样，在运行程序的时候，切换一下进程，刷新缓存，程序继续运行，没有报错。访问成功，可以观察到gdt表的首地址的段描述符为0，因此这里打印的是零，表明访问成功。

![image-20250704140912030](./%E9%A1%B5.assets/image-20250704140912030.png)

### A位

accessed位，当该页被读取过（访问过），这页就会置为一。系统不会读取三环信息。

> 蜜罐Demo
>
> ![image-20250704142506592](./%E9%A1%B5.assets/image-20250704142506592.png)
>
> 共享内存不检测A位，检测映射区域的内存的A位，使用的时候，不读普通内存（蜜罐内存）的数据，只读写共享内存区域，然后共享内存中的数据写入到蜜罐内存中。
>
> 由于共享内存的地址不是从**基址+偏移地址**这样转移过来的。所以当有别人访问的时候，会去访问我们的蜜罐内存，A位置为1，攻击者掉入蜜罐。
>
> 如何破局？
>
> 手动的取出物理地址，映射读。其原理是，将这块物理地址映射出来以后（0x12345），让另一个地址也指向它，这样A与B指向同一块内存，但是读取B，修改的是B的A位，而不是A的A位（被检测的）
>
> ![image-20250704143703689](./%E9%A1%B5.assets/image-20250704143703689.png)



### D位

dirty 脏位，看是否被写过。注意PDE是没有脏位的，PTE有脏位，但通常由于有数据的校验，所以通常是不会去写入，或者说写入错误数据被校验修改回来的情况。



### PS位

当PDE的PS位为1时，代表这是一个大页，一个小页就是普通的页，为4K。而当PS位为1时，在101012分页下，只有PDI，**后面的22位全部是页内偏移**，那么一大页就有2^22^B = 4MB。



### 缓存 



在将虚拟地址转换为物理地址的过程中，会经过多次运算，当系统中的进程过多了以后，一秒内可能会有多次访存，这会给CPU造成很大的负担，因此，通过缓存来对进程访存进行优化。

在CPU内部集成了一块MMU(Memory manager unit)内存管理单元，这个部件不参与运算器内部的算术运算，专门用于寻址管理。



#### TLB(快表)

- 全称叫页表缓存
  - 其作用是快速的将虚拟地址转换为物理地址
    - 依据是时间局部性（同一块内存，在短时间内可能重复访问）

存储页帧和页头的关系

- 页头（**页号**）
  - 虚拟地址在分页时不包含页内偏移的部分叫做页头
    - 例如，0x12345678 其页头为0x12345
- 页帧
  - 将页号转换为物理地址即为页帧，也可以看成是物理地址的页号部分



TLB中的存储格式：

- 这部分是逆向猜测而来，Windows并没有显式的在开发手册里面写出来

| 虚拟地址 | 物理地址 | 属性 | PCID | G    |
| -------- | -------- | ---- | ---- | ---- |



- PCID
  - 在CPU中提供了根据CR3来刷新缓存的一个机制
- G位是单独存放在末尾还是在属性部分是不得而知的
  - G位为1的时候，普通的刷新是不会成功的





当得到进程的CR3以后，先查找TLB，看里面是否有对应到物理地址的映射。如果没有就查慢表，并将该虚拟地址到物理地址的映射存入到TLB中。

获取到物理地址以后，通过物理地址+偏移得到方式得到主存地址。

得到主存的物理地址以后，先去访问cache，因特尔下的cache分为L1、L2、L3三级cache，**离CPU的物理核越近，对应的cache就越快，容量就越小。**

从L1出发，如果没有找到目标物理地址，就查询L2，没有命中就接着找L3，L3的设计最初是用于多个内核共享数据的。

如果多级Cache都没有命中的话，就去内存里面拿数据，根据换页规则看是否要将该内存数据调入Cache中。

L1换下来的数据，大概率会存储在L2中依次类推，直到将它换回到物理内存中。

![image-20250709131056412](./页.assets/image-20250709131056412.png)



![image-20250709132022451](./页.assets/image-20250709132022451.png)



![image-20250709132032391](./页.assets/image-20250709132032391.png)

##### PCD位

- Page-level cache disable

页层级缓存关闭，即当PCD位为1，就没有页层级缓存。也就是不会将这一PTE的内容写到缓存里面去。

##### PWT

- Page-level write-through 
- 直写还是回写

![image-20250709133210952](./页.assets/image-20250709133210952.png)

- WB
  - write back 回写
    - CPU将数据写入到多级缓存里面，当该缓存要被换出的时候才写入主存中
- WC
  - write combine 写延迟
    - CPU即不写入缓存也不写入内存，而是单独写入一个缓冲区，当缓冲区满或者有指令要求时，才将这块缓冲区刷到缓存里面。
- WT
  - write through 直写  
    - 写入缓存并写入主存
- WP
  - wirte protect 写保护
    - 写位的保护
- UC
  - 强无缓存（Uncacheable）
    - 没有读写缓存 直接主存
- UC-
  - 弱无缓存（Uncache），但是允许修改PAT位，让其变换类型
  - 默认的缓存类型
    - PAT位默认为零，是否置一由PCD和PWT来决定

##### MSR寄存器

一组和**CPU核无关**的寄存器，它是CPU额外设置策略用的

核相关寄存器（GDTR、通用寄存器组、标志寄存器）

rdmsr

```
mov ecx,寄存器编号
返回的结果
eax保存l4 低4字节
edx保存h4 高4字节
```

wdmsr

```
mov ecx,寄存器编号
mov eax,l4 低4字节
mov edx,h4 高4字节
```



![image-20250709140222185](./页.assets/image-20250709140222185.png)

在调试器里面看msr

![image-20250709141228282](./页.assets/image-20250709141228282.png)



![image-20250709141324063](./页.assets/image-20250709141324063.png)

再查找元素可以看到是06H WriteBack(WB)

![image-20250709141505156](./页.assets/image-20250709141505156.png)

读出MSR之后，看页表的位

若PAT = 0， PCD = 0 PWT = 0

则为零号元素

对应msr的值来看，零号对应0x06即为WB类型

可以发现刚好对应上Windows的MSR类型

![image-20250709142948511](./页.assets/image-20250709142948511.png)

> PAT、PCD、PWT 这几个属性与子表的属性是或的关系
>
> 例如:
>
> PDE.PCD = 1
>
> PTE.PCD = 0
>
> 那么细分到页，还是没有缓存的
>
> 这里用或的关系不好理解，其实就是PDE和PTE在这几个属性上可以不同，一般而言是大表影响小表，例如PDE.PCD = 0 PTE.PCD = 1那么影响的就只是单独的一个PTE而不影响整个大的PTT里面的其他PTE，当PDE.PCD = 0时 其余的PTE.PCD可以等于1或者等于0.
>
> 而对于R/W U/S P 等等 是且的关系
>
> 也就是PDE.P = 0 那么就不用看对应的PTE了，因为PDE是无效的那么PTE肯定也是无效的



##### TLB的个数

TLB最少有4张

对应与大小页与代码/数据段

首先

由于页分为大页和小页，那么在虚拟地址转换为物理地址的时候就不可能统一的去转换

因为大小页的页内偏移是不同的

例如，在101012下，大页的页内偏移占22位，小页的页内偏移占12位。

因此，对于TLB就需要对大页和小页进行分类

其次，对于不同的区域进行分类，代码区域和数据区域的TLB也进行了分类

那么TLB最少就有 大页的数据/代码TLB 小页的数据/代码TLB 共4张。



##### 验证

定义全局变量 y1 y2

申请2段内存，进行挂页

x1 = 0x100

x2 = 0x200

让0地址 = x1 的PTE

y1  = 读0地址的内容



0 地址 = x2 的pte

y2 = 0地址的内容



正常来说，如果没有缓存存在的话

y1 = 100 y2 = 200

但是由于有缓存存在 

导致第二次读的时候是缓存里面的内容

导致结果为y1 = 100 y2 = 100



![image-20250710120308491](./页.assets/image-20250710120308491.png)

构建调用门

![image-20250710120857003](./页.assets/image-20250710120857003.png)

![image-20250710120937334](./页.assets/image-20250710120937334.png)







![image-20250710120542921](./页.assets/image-20250710120542921.png)

![image-20250710120750612](./页.assets/image-20250710120750612.png)





写入到gdt表中

![image-20250710121012051](./页.assets/image-20250710121012051.png)



初始化x1、x2的地址时将0x100、0x200放入到内存中，因此这里读出0x100表明访问内存成功

![image-20250710121304977](./页.assets/image-20250710121304977.png)



![image-20250710121501960](./页.assets/image-20250710121501960.png)

单步调试的时候，FS的值可能被刷掉了，重新运行执行，程序不报错

表明缓存是存在的

![image-20250710122645637](./页.assets/image-20250710122645637.png)



我们在挂完x2的页之后，重新给CR3赋值，当然CR3的值是不变的，但是，当有给CR3赋值这个操作之后，就会将缓存进行刷新，结果正确。

![image-20250710123337156](./页.assets/image-20250710123337156.png)



```
mov eax,cr3
mov cr3, eax
```

由于监测到cr3的变动，会刷掉进程的所有缓存。



##### G位

![image-20250710125057859](./页.assets/image-20250710125057859.png)

- 在挂x1之前，将g位置为1。

或上0x100，由于g位为第8位，所以or 0x100 对于or的逻辑，一定有第8位为1。

![image-20250710125308876](./页.assets/image-20250710125308876.png)

发现置了g位之后，缓存不再刷新。

![image-20250710125641009](./页.assets/image-20250710125641009.png)

这意味着，g位置为1以后，该页常驻缓存。普通的刷新是刷不掉的。

因特尔提供了专门的，将单独的一条缓存置为无效的，也就是可以单独的刷掉一条缓存。

invlpg 指令就是专门用来刷掉常住地址的。给出一个虚拟地址以后，回去找到这块地址的页头，将TLB中这个页映射关系给刷掉。

```
invlpg 虚拟地址
```

![image-20250710130255844](./页.assets/image-20250710130255844.png)

还有一个方法是关闭全局缓存，这个全局缓存类似一个总的开关，表明是否有全局缓存。

![image-20250710131432890](./页.assets/image-20250710131432890.png)

如果全局缓存存在，设置g位才有效，否则是无效的。



##### Page fault HOOK

当产生缺页异常的时候，Page Falut 会捕获这个异常进行中断处理。与页相关的错误都是这个中断去进行处理。

由于小页分为数据TLB 和 指令TLB，由数据和指令是分开的，在逻辑上也就意味值执行和读写  是分开的。

假设有一块进程A内存，我们在进程里面hook，那可以被监测到。因此，先申请一块内存页B。将A的内存内容，复制到B中，并且在B中写一段HOOK代码。

将B页的PTE替换到A进程里面。然后通过类似shellcode一样的代码，在B页里面执行一段ret语句，这样B页就被加载到指令TLB中。

在A进程中，将原本的PTE换回来，并且读取一下旧的PTE，这样旧的PTE就会被加载到数据TLB中。

这样就实现了**执行和读写的分离**，即执行的是页B，读写读的是正确的PTE，这样就保证了进程A的执行，也实现了HOOK的执行，并且单纯的扫描进程A，无法查看到任何的HOOK代码。

**HOOK PF的作用**就是，我们可以在**进程A中，将页的P位置为0，这样就会产生缺页**，HOOK PF以后，可以将B重新挂到TLB中，以及A的读取。否则，TLB并不是专属于一个进程的TLB，那么当多进程，多线程环境下，很有可能会刷掉TLB里面的缓存，将PF HOOK 住以后，才能够保证复制页B能够实现常驻内存的一个效果，执行进程A时，会附加着执行进程B

![image-20250710152549959](./页.assets/image-20250710152549959.png)

想要hook pf 需要在x86 且在win10以下版本。



## 共享内存

如果进程A与进程B，使用了同一块内存，这块内存就叫共享内存，可以利用这个机制进行数据的传输。

现定义一个指针，在内存层面将其指向x的物理地址，看能否读出x的值

![image-20250703150747142](./%E9%A1%B5.assets/image-20250703150747142.png)

同理，找到进程的CR3，并打印x的地址，进行划分

![image-20250703150927927](./%E9%A1%B5.assets/image-20250703150927927.png)

![image-20250703151300417](./%E9%A1%B5.assets/image-20250703151300417.png)

由于a指针里面存的是0，也就是PDT表的第0号PDE，可以看到第零号PDE的页目录段里面是没有挂页的，我们将x所在的页地址挂到零号PDE的页目录里面。

![image-20250703152453496](./%E9%A1%B5.assets/image-20250703152453496.png)

成功访问。注意，这里需要多等一会或者打开几个进程，让缓存刷新一下，不然就会打印缓存里面的a指针所指地址的值。

![image-20250703152522679](./%E9%A1%B5.assets/image-20250703152522679.png)

## 申请内存

malloc不申请内存，除非申请的内存值特别大。

VirtualAlloc申请内存。观察，申请内存的时候，是否真的有对应的物理地址。

![image-20250704145753385](./%E9%A1%B5.assets/image-20250704145753385.png)

![image-20250704150051550](./%E9%A1%B5.assets/image-20250704150051550.png)

划分得到  00  0D 000。

![image-20250704145946370](./%E9%A1%B5.assets/image-20250704145946370.png)

可以观察到申请的这块内存的PDE是空的。即按照提交的方式申请内存，在没有初始化的时候，这块内存还是不存在的，即没有真正的物理地址。

> Windows内存的管理，是懒加载方式。也就说，在申请内存了以后，Windows提供的线性地址的物理地址是不存在的，只有当真正去访问的时候，产生了缺页异常，才会去看之前这块虚拟地址是否申请过，如果虚拟地址申请过，并且属性是对应的，才会去挂上物理页，此时这块内存才叫真正的申请了。

**观察初始化以后的这块内存是否挂上页，成功申请**。在写驱动的时候，要特别注意这个细节。

![image-20250704150950913](./%E9%A1%B5.assets/image-20250704150950913.png)

验证  打开运行两次同一份exe文件，观察里面的线性地址所指向的物理地址是否相同

## 页表基址

由于Windows操作系统本身是没有办法去操作物理地址的，但是，Windows又需要对进程内存进行管理，最终的实现方式是构建一个虚拟地址进行管理，然后映射到物理地址上去。

**Windows在实模式下就对一块内存区域进行了区段的划分**

- 不同的用户登录的时候，用户名是不一样的，对应的会话进程是不一样的。例如，一号用户连接进来就是1，二号用户连接进来就是2。
- 池的概念就是里面有很多可以反复用的，已经分配好了的内存页，有进程申请的时候就从池里面拿出内存页分配出去。

![image-20250706112944745](./页.assets/image-20250706112944745.png)

由于从实模式跳到保护模式的时候，不存在虚拟内存，而在实模式的时候先将内存进行映射，因此，在实模式下，可以将物理地址当成虚拟地址来用，一旦跳转到system进程下就会将区段划分，划分好了以后，又需要对三环的进程、内核等进行管理，此时在保护模式下，无法访问物理地址，最终的实现是对页表进行划分。

![image-20250706121310199](./页.assets/image-20250706121310199.png)

在101012下，每个进程的，**将一些共用的内存（大小2GB）映射到这块内存中**，

Windows/Linux等系统将**高2GB虚拟地址（0x80000000–0xFFFFFFFF）保留给内核**。

`0xC0000000~0xc0300000`这块虚拟地址作为专门的页表，称为**管理页表**，位于内核空间中部，用于集中映射所有页表（共1024个页表，占4MB空间：`1024页表 × 4KB = 4MB`）。

共用代表着大部分进程的这块内存区域里面的数据都是一样的。但在这块共用的内存区域里面，又有部分内存是每个进程都不同的。

> 如果每个进程的这张表都是一样的，那就不存在进程的隔离，每个进程都可以看成是相同的进程。

而这些所谓的共用的内存，其实就是Windows一开始划分好了的区段里面的内存地址，这块内存会映射到进程的管理页表里面。

而每个进程对Windows划分好的会话内存池（session）的映射也是不一样的，对于部分与UI无关的进程（例如服务性进程、system进程），就不会映射到进程的管理页表里面 。

> 总结：
>
> 管理页表管理着一个进程的所有内存，在管理页表中，有部分内存，是根据进程的需要映射进来的。

引入基址之后，对于进程的PDT表和PTE表的访问就可以通过基址+偏移个数*4来进行访问

![image-20250706124213088](./页.assets/image-20250706124213088.png)

101012管理页表的大小：

 1024（PDE个数）*1024（PTE个数）\*4（每一项PTE、PDE的大小） = 4MB 

即在101012分页方式下，4MB可以用来管理4GB（1024 \* 1024 * 4096）的内存大小

**cr3里面存放的是PDT表的首地址。**

在读取数据的时候，地址后面跟上L1代表看一个，这里的1是16进制。之前说过，一个PDT表为一页的大小(4KB)，一个PDE有4B，那么一个PDT表有1024个PDE，这里想要查询1024个元素，转化为16进制为0x400，对应于L400。

![image-20250706101011131](./页.assets/image-20250706101011131.png)

这个cr3表里面，cr3自己本身也有一项存放在里面

查询类似0x00185000的一个一项，最后12bit为属性位，前面为地址位。因此，找到前20bit为0x00185的即可。

![image-20250706101818117](./页.assets/image-20250706101818117.png)

这表明，**cr3是存放在PDT表中的某一项**，我们可以用这一项，来求出PDE和PTE的基址。 

### 101012PDE、PTE基址的计算算法

注意，**这里说的基址是PDT表和PTT表的首地址即虚拟地址**，下面的计算即围绕着，从虚拟地址(页基址)进行计算，看从虚拟地址计算得到的虚拟地址内存数据和从物理地址获取的内存数据是否相同。

首先，找到CR3所在项的地址185c00，用该地址减去cr3里面存放的PDT表的首地址，得到**偏移C00**，将该偏移除以4，有0xC00 / 4 = 300 这里得到的是一个索引值，有了这个**索引值**之后，

##### 计算PTE的基址（PTT表的首地址）：

在101012下，由最后的页内偏移和页表号（中间10bit和最后12bit）

将索引值左移22位，**得到的16进制值即为PTE的基址（虚拟地址）**。

在101012下，PTE的基址被映射到固定线性地址**0xC0000000**

![image-20250706103056792](./页.assets/image-20250706103056792.png)

#### 计算PDE的基址(PDT表的首地址)：

在101012下，由页内偏移占12bit

将索引值（0xC00 / 4 = 300 ）左移12位得到索引偏移值。

**PDE的基址为PTE的基址加上计算来的索引偏移值的结果。**

在101012下，PDE的基址被映射到固定线性地址**0xC0300000**

![image-20250706103938351](./页.assets/image-20250706103938351.png)

伪代码形式

![image-20250706105146572](./页.assets/image-20250706105146572.png)

**这就是Win10、11的页表基址浮动原理，当系统将cr3的值放在PDT表的不同位置，那么一开始得到的偏移值就不同，对应于后面所求得的所有的数据都是浮动的。**对应的效果就是每次重启的时候，系统将cr3进行了随机化，随机放在某一位置，使得PTE和PDE的基址的位置都不一样。101012没有这一个机制。

验证

查看计算出来的PDE基址的内容与CR3里面存放的PDT表的首地址的内容。

![image-20250706110823421](./页.assets/image-20250706110823421.png)

相同，表明计算得来的地址是对的.

### 验证Windows7下的管理页表的机制

在Windows7下找到两个文件ntoskrnl.exe ntkrnlpa.exe，然后用ida打开。

- ntoskrnl.exe是101012分页
- ntkrnlpa.exe是299912分页 其后缀pa 是pae的简写

![image-20250706130153436](./页.assets/image-20250706130153436.png)

下载好符号后打开struct 结构窗口，按insert键。

`!PTE`后跟虚拟地址

可以查看虚拟地址对应的PDE和PTE在的地址

![image-20250708112802751](./页.assets/image-20250708112802751.png)

### IDA的使用![image-20250706130521827](./页.assets/image-20250706130521827.png)

![image-20250706130605042](./页.assets/image-20250706130605042.png)

在弹窗中输入_KPCR![image-20250706130701570](./页.assets/image-20250706130701570.png)

如果能够成功导入，且SIZEOF >= 0x3000表明符号下载完全![image-20250706130902325](./页.assets/image-20250706130902325.png)

打开IDA View 窗口 可以看到一个代码的流程框，ctrl + 滚轮 可以放大缩小，按下空格可以在流程框和反汇编的窗口间进行切换窗口。

![image-20250706131130913](./页.assets/image-20250706131130913.png)

IDA View-A（代码流程/反汇编窗口） Hex Veiw(16进制窗口) Struct(结构体窗口)Enuw（枚举窗口）、Import（导入表）、Export（导出表）。

<img src="./页.assets/image-20250706131658736.png" alt="image-20250706131658736" style="zoom:200%;" />

在左边的函数框部分按下ctrl + f 查找mmisaddressValid函数，**其作用是判断该地址是否挂物理页，如果存在，则是有效地址，反之，则无效。**

![image-20250706132632598](./页.assets/image-20250706132632598.png)

##### 注释与注解

`;`用来给一个函数段 汇编代码段 添加注解

`shift + ; `用来给一句汇编代码添加注释

![image-20250706133759664](./页.assets/image-20250706133759664.png)

对与函数的注解，可以在有别的函数调用这个函数的时候看到这段注解。按`x`查看函数的交叉引用。即有哪一个函数调用了这个函数。

![image-20250706134007529](./页.assets/image-20250706134007529.png)

![image-20250706133952002](./页.assets/image-20250706133952002.png)

> Windows的补丁：
>
> 可以看到，在函数段与函数段之间有几个空白的汇编段，**如果Windows在外面打上了补丁，那么从函数的第一个句话上面可以跳转到空白汇编段，再从该汇编段跳转到补丁代码。**如果没有打补丁，那么这句话就是无意义的。

![image-20250706134159168](./页.assets/image-20250706134159168.png)

### 地址重命名

对一段地址进行重命名按`N`键

![image-20250708132711495](./页.assets/image-20250708132711495.png)

### mmisaddressValid函数汇编分析

```
push ebp
mov ebp,esp   保存环境
mov ecx,[ebp+VirualAddress] ;按R可以看到VirualAddress的字节数 按C恢复
call _MiIsAddressValid@8;
```

| ebp(旧)  | esp(ebp 新)    |
| :------: | -------------- |
| 返回地址 | ebp+4          |
|  参数1   | 目标地址 ebp+8 |

![image-20250706143636019](./页.assets/image-20250706143636019.png)

这里的调用函数的要求是@8 也就是需要传入两个参数，但是在看调用函数的堆栈里面，我们发现它只压入了一个，这应该是IDA的一个bug。观察跳转函数，发现汇编代码里面也只用到了ecx里面的参数。

![image-20250706153547686](./页.assets/image-20250706153547686.png)

```
			mov eax, ecx
            shr eax, 14h
            and eax, FFCh
            sub eax, 3FD0000h
            mov eax, [eax]
            test al, 1
            jnz short loc_489BB0

loc_489BAD:
			xor al, al
			retn
```

``` 
			shr eax, 14h
            and eax,FFCh
            sub eax, 3FD0000h
            mov eax, [eax]
```

`shr eax, 14h`右移 14h = 20 位，**在逻辑上就是取地址的高10位**。

`and eax,FFCh`去掉末尾的两位，计算PDE的索引。

> 这里与上0xFFC的效果，与手算划分101012的情况是一样的
>
> 例如对于地址0x12345678 化成二进制是  0001 0010 0011 0100 0101 0110 0111 1000
>
> 按照10 10 12划分就是
>
> PDI = 0000  0100 1000 = 48
>
> 0x48 * 4 = 0x120
>
> 而0x123&0xFFC = 0x120

`sub eax, 0x3FD00000 `  将`0x3FD00000`变为其**符号位取反的补码**，简单来说就是将该汇编语句变为加法来运算，可以发现-(0x3FD00000) == +(C030 0000)  这里的值刚好就是前面说的算法中**PDE的基址**。用该基址加上求得的PDE的索引值，得到目标PDE的地址，取出其PDE，放入eax中。

`test al,1`

- **逻辑操作**：`test` 指令对两个操作数执行按位与（AND）运算，但**不保存结果**，仅根据结果设置标志寄存器。
- al 为ax的最低8bit
- 运算方法 ax的低8bit与0x01进行AND与运算，也就是判断ax的最低位P位是否为1
- 结果
  - 零标志（ZF）：
    - **ZF = 1**：按位与结果为 0（即 `al` 的最低位为 0）。
    - **ZF = 0**：按位与结果非 0（即 `al` 的最低位为 1）。
  - 符号标志（SF）：根据结果的最高位设置（若结果最高位为 1 则 SF = 1，否则为 0）。由于测试的是最低位，此场景下 SF 通常为 0。

`jnz short loc_489BB0`

- `jnz` 即if (not zf)  jmp
- 后面的是跳转地址

如果jnz没有跳转，那么就是顺序执行下面的语句，前面的loc_489BAD只是一个标签，不代表一个专属的跳转区域。

跳转的逻辑是，如果P位为0，则代表页无效，那么就直接返回，否则接着判断PTE.![image-20250706155347596](./页.assets/image-20250706155347596.png)

```
loc_489BB0:
			test al,al
			jns short loc_489BB7
			mov al, 1
			retn
```

`test al, al`

al与al进行且运算，结果为al本身，但会更新SF、ZF等标志位

这里al为八(0~7)位，与运算按照最高位设置SF

- SF = 1 即第7位为1
- SF = 0 即第7位为0

观察PDE的第7位为PS（Page Size）位，该位表示该PDE是否直接指向一个内存区域

![image-20250703142227722](./%E9%A1%B5.assets/image-20250703142227722.png)

`jns short loc_489BB7`

- if(!SF) jmp
  - 即是PS = 1 不跳转
  - PS = 0 跳转

同理，若jmp不跳转的话，继续执行下面的语句![image-20250706161535269](./页.assets/image-20250706161535269.png)

```
loc_489BB7:
			shr ecx, 0Ah
			and ecx, 3FFFFCh
			sub ecx, 40000000h
			mov eax, [ecx]
			test al, 1
			jz   short loc_489BAD
			and al, 80h
			cmp al, 80h
			setnz al
			retn
```

```
			shr ecx, 0Ah
			and ecx, 3FFFFCh
			sub ecx, 40000000h
			mov eax, [ecx]
```

将ecx右移10位 & 0x3FFFFC

同理  假设线性地址位(0x12345678 >> A) & 0x3FFFFC  = 0x48D14

0x40000000的相反数的补码 = 0xC000 0000 为PTE的基址映射 

0xC000 0000 + 0x48D14 = 0xC004 8D14

为其PTE地址。

![image-20250706201540379](./页.assets/image-20250706201540379.png)

```
			test al, 1
			jz   short loc_489BAD
			and al, 80h
			cmp al, 80h
			setnz al
			retn
```

`test al, 1`同样的 判断P位是否为1，如果无效就返回0。

与80h相与，即只保留PTE地址的第7位（PAT）位

再与80h相减（cmp 的逻辑是相减）

对应的ZF进行修改

- ZF = 1 PTE的第7位为1
- ZF = 0 PTE的第7位为0

setnz al;  将ZF位取反后的值赋给al。

![image-20250706200139747](./页.assets/image-20250706200139747.png)

按照Windows的算法进行验证

gdt表的地址为0x80b99000 

 \>\>0x14 = 80B

80B&FFC = 808

那么其PDE = PDE.base + 808

![image-20250706202318910](./页.assets/image-20250706202318910.png)

0x80b99000 \>\>A = 202E64

202E64 & 3FFFFC = 202E64

那么PTE = PTE.base + 202E64

![image-20250706202544129](./页.assets/image-20250706202544129.png)

在用物理地址进行计算

取出PDI、PIT并分别乘以4，

CR3 + PDI*4 = PDE

CR3 + PTI*4 = PTE



![image-20250706203025795](./页.assets/image-20250706203025795.png)

结果相同，表明计算结果正确。

![image-20250706164847845](./页.assets/image-20250706164847845.png)

##### 漏洞

在一些游戏或者一些安全工具里面，会遍历进程的管理页表，从头遍历到尾，看里面是否有危险代码。

而在遍历进程的管理页表之前，就需要先去调用API去探测一下这个页能否读，这个页是否有效，如果这个页不能读或者无效的话，那么监测的时候读取，监测的那一方就会蓝屏，因此，当编写了一段危险代码以后。可以将对应的PTE的第7位（PAT）位，置为1，代表是，那么就可以绕过监管。

![image-20250706201540379](./页.assets/image-20250706201540379.png)

`cmp al,80h` 这里，当求出PTE以后，将对应的PAT位置为1，结果为0，ZF=1,返回的时候al就等0，无效，可以，API对应返回无效，遍历管理页表的时候就可以绕过这块内存。





### 零地址执行

零地址上挂页，这里零地址的含义就是页表基址，或者说PTT的第一个PTE。

执行一段Shellcode 这个shellcode本质上是一个弹窗，用调用门来操作，而不用驱动来操作。



构建ShellCode

```Shell
push 0
push 0
push 0
push 0
mov eax,0x12345678;messagebox函数地址
call eax
retn
```

由于**系统的调用是内平衡**，所以直接retn即可，不用手动对堆栈进行清空

点击二进制复制

![image-20250707121626494](./页.assets/image-20250707121626494.png)

得到的二进制数据，将其格式改为c语言里面的格式

![image-20250707123842041](./页.assets/image-20250707123842041.png)

将CALL后面的调用地址改为调用的函数地址。

![image-20250707123820381](./页.assets/image-20250707123820381.png)



![image-20250707130208890](./页.assets/image-20250707130208890.png)

![image-20250707130531141](./页.assets/image-20250707130531141.png)

成功弹窗，表明调用该函数没有问题。

> 注意，之前在申请内存的时候，只申请了读写权限，并没有申请执行权限。
>
> 但是后面将这段内存转换为函数的入口地址以后，成功的调用并且执行，这表明在101012下并没有对内存的执行权限进行划分，**所有的内存都有可执行的权限**。

![image-20250707130519463](./页.assets/image-20250707130519463.png)

此时调用零地址会报错。

![image-20250707131331666](./页.assets/image-20250707131331666.png)

用调用门提权后，再调用零地址。

![image-20250707131712062](./页.assets/image-20250707131712062.png)



![image-20250707132834478](./页.assets/image-20250707132834478.png)

shellcode大小0x1000 bufcode大小16字节。

通过调用门来提权，转到目标函数执行Shellcode，我们需要将shellcode的首地址传递过去，对应的用retf返回的时候返回4字节。保存fs的值，返回的时候恢复fs。



在跳转目标函数中挂物理页。

首先，在堆栈里面，想要取得shellcode的地址，即为[esp + 8]

![image-20250707134331216](./页.assets/image-20250707134331216.png)

然后要挂物理页到零地址，需要计算PTE。运用Windows下计算PTE的算法。

![image-20250707134507366](./页.assets/image-20250707134507366.png)



零地址，即为PTT表的首地址，在101012下也就是0xC0000000。将页挂在零地址。

![image-20250707135026215](./页.assets/image-20250707135026215.png)

在调用调用门的之前暂停，在Windbg构建调用门。

![image-20250707135154900](./页.assets/image-20250707135154900.png)

写入调用门，跳入到调用函数以后，打开反汇编。

![image-20250707140230896](./页.assets/image-20250707140230896.png)

修改，将存放和恢复fs值的步骤放到调用门里面，放到主函数里面恢复的话，会弹出内存访问的错误。FS与当前的程序的运行环境相关（零环与三环），相应的堆栈也要加上4字节，因为，压入以后，esp指向fs

![image-20250707145623668](./页.assets/image-20250707145623668.png)

计算出PTE以后，查看零地址的内容为空。

![image-20250707145711061](./页.assets/image-20250707145711061.png)

成功写入

![image-20250707145737783](./页.assets/image-20250707145737783.png)

继续运行的话会因为FS在返回之后在主函数进行赋值，但此时在三环下对FS进行修改是没有权限的，会导致报错。

![image-20250707140551703](./页.assets/image-20250707140551703.png)

其次呢，由于缓存的缘故，需要在将页挂好之后，暂停一下，将缓存刷新掉，然后调用零地址页。

![image-20250707144752050](./页.assets/image-20250707144752050.png)

重新运行，查看零地址部分是成功挂上页的。

![image-20250707150137758](./页.assets/image-20250707150137758.png)



继续运行，在调用shellcode的时候暂停，刷新一下缓存，成功在零地址执行shellcode。

![image-20250707150355661](./页.assets/image-20250707150355661.png)



也就是说，只要我们知道了页表的基址，我们就可以申请一块内存挂在页表上，运行自己的代码。并且，由于这块内存不是Windows分配的，所以Windwos提供的API是监测不到这块内存的。

验证是否能够监测到

打开CE，选择进程

![image-20250707151207341](./页.assets/image-20250707151207341.png)

查看内存区域

![image-20250707151311147](./页.assets/image-20250707151311147.png)

注意观察，申请的这块内存的状态是Free的，是空的，但是其具体的里面是有数据的，也即是，这个页的实际状态和真实状态不一致，表明这块内存是不受Windows监测的，那么对应的Windows提供的API自然就监测不到它。

![image-20250707151509926](./页.assets/image-20250707151509926.png)

对应着，如果将页挂在进程的空隙部分，例如dll与dll之间有部分空闲的内存碎片，到了64bit系统，这块内存碎片会更大。



![image-20250707151904461](./页.assets/image-20250707151904461.png)

Windows下而已遍历每一个块，可以知道这块内存是否已占用，这块内存大小、属性等等。



###### 验证PAT位置1，对读写的影响

将挂上的物理页的PTE的PAT位改为1，对应的PTE改为3ec558e7

![image-20250707160358576](./页.assets/image-20250707160358576.png)

![image-20250707160811596](./页.assets/image-20250707160811596.png)

同理，刷新一下，刷掉缓存。![image-20250707160848257](./页.assets/image-20250707160848257.png)

正确执行，也即为这不妨碍这段内存的读写

![image-20250707160939872](./页.assets/image-20250707160939872.png)





# 29912分页

## PTE、PDE基址的计算

手动计算：

![image-20250708113733505](./页.assets/image-20250708113733505.png)

前面的地址部分是相同的。

![image-20250708113810313](./页.assets/image-20250708113810313.png)

2 9 9 12 前面的2bit对应最大值为十进制的4，从0开始编号下标就是3，即**索引值就是3**, 将3对应与2 9 9 12 前面的2bit，因此左移9 + 9 + 12 = 30位，在该算法中可以将这个索引值理解为一个规定。将该**索引值左移与2bit(PDPTI)部分的最低值位对应，即为PTE的基址**。

如果读取别PDPTE 会发现没有这个现象。也即是每一个CR3指向的PDPTE的最后一个段，会将该CR3的PDPTE保存一份。

![image-20250708141244416](./页.assets/image-20250708141244416.png)

对应的十六进制为

0xC000 0000 

该地址为PTE的基址。

![image-20250708113856432](./页.assets/image-20250708113856432.png)

同样的

将索引值3与第二个9bit对应，则将3左移9+12 = 21位，3<<21的十六进制为 

0x60 0000

在用PTE的基址加上该值 结果为PDE的基址

PDE.base = C000 0000 + 60 0000 = C060 0000

![image-20250708114343151](./页.assets/image-20250708114343151.png)

### Windows下的基址算法

同理 逆向MmisaddressValid函数，可以观察到在29912下的Windows的PTE的基址和PDE的基址的计算算法

![image-20250708125005636](./页.assets/image-20250708125005636.png)

对于edi、esi这两个寄存器，通常是为了不破坏旧的寄存器的环境，而设立的非易变寄存器。而**对于ecx，不是非易变寄存器的，在函数开头压入栈中，通常是因为接下来的语句里面可能会用到。**而不是为了压入参数。

![image-20250708125253821](./页.assets/image-20250708125253821.png)

``` 
shr eax,12h
and eax, 3FF8h
sub eax, 3FA00000h
```

将线性地址放入到eax中，让地址右移12h(18)位，由于物理地址变成了64bit，最后的结果要乘以8，这里就由手算的时候的PTI的偏移（9 + 12 = 21）位，变为了现在的21-3 = 8位。

与上3FF8保留PDI部分。

![image-20250708131136283](./页.assets/image-20250708131136283.png)

`0x3FA00000h` ，取其相反数的补码，有(-3FA00000)~补~  = `C060 0000` 为PDE的基址

![image-20250708132428616](./页.assets/image-20250708132428616.png)

紧急着，由于物理地址变为了8字节，而没有一次寻址8字节这样的机制，因此就变为了将8字节地址变为高4字节地址和低4字节地址，然后在取地址的时候一次取4字节，先取低4字节地址，再取高4字节地址。

```
mov ecx,[eax]
mov eax,[eax+4]
```

![image-20250708132958295](./页.assets/image-20250708132958295.png)

接下来，取出低4字节，并判断它的P位，如果P位为零，就跳转返回0，否则继续判断是否为大页。

![image-20250708143249943](./页.assets/image-20250708143249943.png)



![image-20250708143654958](./页.assets/image-20250708143654958.png)

```
shr edx, 9
and edx, 7FFFF8h
mov ecx, [edx-3FFFFFFCh]
sub edx, 40000000h
```

计算PTE的思路：

edx里面存放的是线性地址

由于64bit的物理地址，最终的结果会乘以8，那么就在原本的右移12位的基础上乘以8（左移3位）变为右移9位。

与上7FFFF8 得到PTE

这里的`0x3FFFFFFCh`和`40000000h` 求对应的相反数的补码为`0xC000 0004`和`0xC000 0000`分别与PTE相加，即得到物理地址的低四位和高四位

> 例如
>
> edx = 0x12345678
>
> 0001 0010 0011 0100 0101 0110 0111 1000
>
> edx >> 9 = 0x9 1 A 2 B
>
> 9 1 A 2 B & 7FFFF8 = 91A28
>
> 091A28 + C000 0004 = C0091A2C
>
> 091A28 + C000 0000 = C0091A28

![image-20250708150513108](./页.assets/image-20250708150513108.png)

![image-20250708150744435](./页.assets/image-20250708150744435.png)

> leave 等价于快捷键   其是mov esp,ebp; 和pop ebp;的组合 在函数执行的时候，我们就已经将esp的值赋值给ebp了，那么无论在途中，压入了多少个参数，弹出了多少参数，是否会导致堆栈不平衡，都可以将其直接还原为函数运行时的堆栈情况。

![image-20250708150848236](./页.assets/image-20250708150848236.png)



### 29912分页的改进

- 32bit的物理地址变为64bit

**在29912下的物理地址变成了64bit**。这样设计的好处是，**当地址总线超过了32根以后，系统能够识别更多的地址总线**，而如果是原本的101012分页的32bit物理地址，当地址总线超过32根以后，系统是无法识别的。

- 增加了硬件可执行管理

![image-20250708120046486](./页.assets/image-20250708120046486.png)

XD位 (execute disable)

- 63位

- =1 执行关闭
- =0 执行开启

XD位为1，表示不可执行的

![image-20250708120641061](./页.assets/image-20250708120641061.png)



29912的划分

2（PDPTE） 9(PDE) 9(PTE) 12(offset)

从原本的三段变成了4段，在页目录表前面又增加了2bit大小的 PDPTE位。原本在101012下，管理进程内存的页表大小为1024 * 1024 \* 4 = 4MB

现在由于增加了这4个PDPTE，并且地址由32位变为了64位

管理进程内存的页表大小变为 4 * 512\*512\*8 = 8MB

![image-20250708121145476](./页.assets/image-20250708121145476.png)



对应的PDE.ps位为1 代表着大页，29912的一个大页也是从PTI到offset全部变为偏移，那么一个大页就有2^9^ \* 2^12^ = 2MB



手动拆分29912

线性地址->物理地址

对于gdt表地址80b99000，对应于0010   0 0000 0101   1 1001 1001    0000 0000 0000 

有PDPTE = 2

PDI = 5

PTI = 199

原本是32bit地址乘以4

现为64bit地址乘以8

![image-20250708124230450](./页.assets/image-20250708124230450.png)

## 控制寄存器

CR3 是CPU的每个核都有一份

gdt 和 idt也是多核多个的

![image-20250711102512966](./页.assets/image-20250711102512966.png)

### CR3

PCD PWT 位与前面提到的作用相同，当PCD(Page Cache Disable) = 1 的时候，代表是没有页缓存的。

### CR2

主要用于保存访问错误的页地址，例如当访问一个没有挂物理页的内存地址时，处理器通过访问CR2，直到出问题的内存地址是哪一个。

### CR0

大策略控制寄存器，在CR0中可以操控是否开启保护模式，开启段。当然，开启保护模式需要到总线a20写入字。

#### PE、PG位

> CR0的PE = 1 时，开启保护模式、开启段
>
> PG = 1时，开启页模式。
>
> 开启段是开启页的前提，即可以有段页、可以只有段、可以都没有，但是不能只有页，
>
> 即**没有PE  = 0， PG = 1**的情况存在。

#### CD、NW位

![image-20250711104834016](./页.assets/image-20250711104834016.png)

- CD(Cache Disable)
  - 缓存总开关，当CD = 1 所有的缓存都失效。
- NW(Not Write through)
  - 直写总开关
  - 当NW = 1时，系统中的所有的页都只能回写，不能直写，但是当CD = 1时（即缓存关闭），那么NW位设置为多少都是没有作用的。
  - CD = 0时 NW = 1 会产生异常

#### AM位

对齐位，作用于三环。

![image-20250701171912575](./页.assets/image-20250701171912575.png)

eflg.AC基于AM位，AM = 1 AC才有效。

若AM = 1，需要按照CPU的宽度进行对齐，例如32bit电脑，就需要4字节对齐。即对于ESP、EIP对齐，在执行代码的时候会强制要求地址按照字节对齐，否则会报错。字节对齐，方便CPU寻址，并且只浪费较小的内存空间

#### WP

写保护位

当页中的R/W位，将其置为0时，即只有只读权限，那么就不允许往这块内存中写内容。**但是若将CR0上的WP写保护给关闭了以后，即使R/W = 0，我们依然可以写入**。类似于强制写。



#### 浮点

CPU是可以处理浮点运算的，但是其处理的浮点运算在算力上有极限，因此，支持外部的浮点运算器。下面是几个与浮点有关的位：

##### TS

call far 或者 int **进入任务门时**  会将TS置1，表明进入了任务段，并且退出任务段，该位不会恢复为零，需要手动置零。注意，只有在零环下可用，在一环或者二环下虽然也是特权指令，但依然不可以使用。

![image-20250711122618872](./页.assets/image-20250711122618872.png)

TS置为1的时候会对浮点指令产生影响，因此，**在从任务段返回的时候，应该手动将其置为零。**

![image-20250711123327098](./页.assets/image-20250711123327098.png)



##### NE、ME



![image-20250711112547647](./页.assets/image-20250711112547647.png)

当产生异常了以后，将NE位置为0的时候，外部处理器就可以接管这个异常进行处理，这个异常处理器就是一个接口。允许将浮点异常，在外部进行浮点的模拟及运算。

即可以通过该位判断MMX/SSE系列的指令是否能用。

![image-20250711113547164](./页.assets/image-20250711113547164.png)

在三环下判断MMX/SSE是否能用，可以用CPUID，可以查出是否支持该指令，当然，即使支持，若EM位没有设定，那也是不可以使用的。



##### MP

MP位通常与TS位一起使用，并且通常情况下，TS是置为0的，此时MP的值无效。

![image-20250711124214879](./页.assets/image-20250711124214879.png)

##### 总结

![image-20250711124438490](./页.assets/image-20250711124438490.png)



### CR4

![image-20250711140731215](./页.assets/image-20250711140731215.png)





#### VME

- 虚拟8086环境
  - 为了程序的兼容性，一些程序仍然需要运行在8086环境下去运行。
  - 支持运行8086，但是否模拟了环境，需要另说，因为windows下很可能没有提供一些8086的dll库。

#### PVI 

- 虚拟8086 中断
  - 例如：INT 13 进入磁盘

#### TSD

![image-20250711125516567](./页.assets/image-20250711125516567.png)

#### DE 

调试寄存器的开关(开启dr4 dr5)

- = 1 可以使用dr4 dr5
- = 0 不可以使用dr4 dr5

dr0~dr7

dr0~dr3 地址寄存器 写下4个硬件断点

dr6状态寄存器  由系统维护

dr7配置寄存器 确认硬件断点的类型

dr4 dr5

dr4 == dr6

dr5 == dr7

可以用来过拦截，有部分的拦截拦截的是dr6 与dr7 用dr4 dr5 就可以绕过这种写法。

#### PSE 

大页控制器

简写 D == Disable

​		E == Enable

通常1表示是  0 表示否

那么当控制寄存器的简写末尾为D，就代表失效，那么1就表示关闭 0就表示开启

反之，末尾简写位E，1就代表打开，0就代表关闭。

PSE = 0

那么PDE.PS = 1 也不会有大页，即不生效

#### PAE

-  = 1 开启29912
-  = 0 关闭29912 即为101012

当然在x64下，这个位零与一是没有关系的

#### MCE

![image-20250711131922600](./页.assets/image-20250711131922600.png)



#### PGE

page gloable enable



#### PCE

性能计数器

![image-20250711140830566](./页.assets/image-20250711140830566.png)

#### VMXE

开启VT

-  = 1 开启VT
-  = 0 关闭VT

#### SMXE 

开启上帝模式 smm（super mamager mode），进入上帝模式以后，接触的地址大多位物理地址，对其访问的限制也比较严格。

#### SMAP、SMEP

![image-20250711140742852](./页.assets/image-20250711140742852.png)

![image-20250711140811991](./页.assets/image-20250711140811991.png)

- SMEP 内核态 不能执行R3的地址代码

- SMAP 内核态 地址 不能直接访问R3地址数据

- AM位

  - AM = 1 以上设置有效

    AM = 0 以上设置无效

作用：

映射一块内存到低地址上去，并且以作为驱动方式来调用

即驱动程序在R3层上，此时**扫描就不容易扫描到该驱动程序**。

那么就可以将SMEP 置为1 不让内核态用户去执行三环地址下的驱动程序



> 如何破解？
>
> 可以将AM位置为0，使得其设置无效。并且，**如果直接修改SMEP会PG报错，但是修改AM位不会。**

通常情况下是将SMAP是置为0的，因为大多数的系统调用API会监测三环过来的地址是否有效。

```
try
{
	*address = *address;
}
```

但SMEP是通常是置为1的，对系统进行保护。





