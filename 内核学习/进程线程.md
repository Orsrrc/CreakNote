# 进程线程

进程是内存分配的最小单元，线程是运行的最小单元。一个进程如果没有线程，那么它无法处理任何的事物，而一个线程没有进程，那么它无法使用任何的内存空间。它们相互依赖。

## 进程结构

在进程中有一块区域用于描述进程的信息，包括PID、打开的句柄数量、它的父进程和它所占用的内存空间大小等等。线程也有这样一个字段用于描述线程的信息。当然，这两个字段所占用的内存空间都是进程所被分配的内存空间里面。

> 宏内核与微内核的设计理念
>
> Windows 微内核
>
> - 内核比较重要的部分（线程调度、时钟调度、内存管理算法）等进行封装
>
> Linux 宏内核
>
> - 将所有的内核程序打包在一个地方
>   - 仅有EProcess
>     - 线程的调度、时钟的调度等等都
>
> 宏内核比微内核大，并且宏内核包含了微内核

Windows下对进程的描述结构：

- EProcess E 在内核态常用的能够去操作的字段  执行体结构

- KProcess  K代表微内核的核心  内核结构

> 例如：
>
> > KeGetCurrentThread 给微内核设计的，设计时是不打算给用户调用的
> >
> > PsGetCurrentThread 用于给用户调用的

Windows下对线程的描述结构：

- KThread

- EThread



我们任意查看一个进程，可以看到在其EPROCESS结构里面包含了一个KPROCESS，这个KPROCESS就是内核内部自己调用的时所使用的结构。

![image-20250801112021976](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112021976.png)

再去解析一下这个结构，可以看到，当我们拿到一个进程了以后加上18h就是它的CR3

### 解析KProcess

![image-20250801113510063](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801113510063.png)

`KPROCESS`结构中包含了线程的链表，通过线程的链表头`ThreadListHead`可以遍历该进程下的所有线程

通过解析线程的结构`_KTHREAD`，我们可以看到其1e0的位置有一个线程链表的入口地址，也就是说**我们在进程中获取到的线程链表的头地址指向的是线程链表的入口地址**，通过该地址减去1e0就是单个线程的`_KTHREAD`结构首地址

![image-20250801112920900](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112920900.png)

![image-20250801112911591](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112911591.png)

再返回去看，

- 0x34有一个ProcessLock锁，这是为了同步而设置的锁。
  - 当Windows在修改进程的信息的时候会加上进程锁结构然后再去进行修改。

- 0x38 **亲核性**

  - 是一种偏好性的原理，即优先分配。
    - 假设一个CPU有两个核，线程的该字段对1号核标记为1，代表对1号核有偏好，那么在分配的时候，只要该核空闲，CPU都会尽量的满足，从而优先分配该核给线程执行事物。

  - 可以看到**线程记录结构`KPROCESS`里面的0x154是线程的亲核性。而进程的亲核性是给线程用的，当一个线程被创建了以后，其会继承进程的亲核性。**

- 0x44 就绪链表
  - 即进程中处于就绪态的线程将其按照链表顺序来提交给CPU

- 0x4C 换出的链表
  - 内存、线程的页被交换到磁盘上，用链表将其记录。

- 0x50 
  - 记录线程通常在哪几个处理器上活动。

- 0x5c ~ 0x61
  - 用于给线程继承的值，对于进程来说没什么用
    - 例如0x5c的ProcessFlags 为8，则每个线程刚刚创建好的时候，其优先级都是8.

- 在0x78处有一个进程的链表，记录了所有的进程。但在微内核下，可以看到，已经是没有用的了其值都为零

![image-20250801115336634](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801115336634.png)

### 解析EProcess

`ExitTime`字段，基本上只有在进程死亡时才会去修改，由此我们可以利用其存放数据，或者是打上标记。如果我们注入过该进程，那么在该地址位置打上标记来表明已被注入。

![image-20250801115852593](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801115852593.png)

- ProcessLock 进程锁
  - 同样，再修改时大多会将其锁上然后再去修改
- ActiveProcessLinks 
  - 进程的链表，其地址为0xb8即其地址指向的是进程的b8的位置，那么我们想要获取完整的进程的`EPROCESS`结构，就需要将地址减去b8

- SessionProcessLinks

  - 用户的链表。Windows对于多用户进行了标记，例如用户A登录其session = 1，用户B登录其Session = 2。
  - 不同用户创建的进程，其存放的进程链表不同，即相同的Session所创建的进程其存放在同一个SessionProcessLinks上。
  - 而ActiveProcessLinks不对Session进行区分，不论是哪一个用户所创建的进程，在该链表上都可以查找到。

- DebugPort

  - 只要其值不为NULL，就代表该进程是调试的状态

- ObjectTable

  - 句柄表，索引号

  - 例如，我们之前调用OpenProcess函数的时候会返回一个句柄索引号，通过该索引号到句柄表里面查找才可以找到对应的对象地址。

    ![image-20250801121408299](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801121408299.png)

- Token
  - 权限
  - 别的用户创建的进程，我们想要给这个进程提权（让其可以被读写、执行等等）就修改Token
- AddressCreationLock
  - 地址锁
    - 通常调用AllocVirtual 申请内存时，先锁住，不让别的进程在操作你的申请内存功能了，即如果两个进程进行通信，A进程操作B进程，让B进程申请一块内存，并且不断的让B进程申请内存，那么第一次要求时地址锁打开，B进程申请内存，这过程中如果A进程再要求B进程申请内存，就会等待。
    - 如果某一进程将地址锁锁上，并且不关闭，那么别的进程到本进程来申请内存的时候就会卡死，不过一般不会将该地址锁一直锁住，因为，进程在运行的过程中会使用一些库函数，并不能保证别人写的库里面没有申请内存。

- imageFileName
  - 获取到进程名，并且该变量只有15个字节，也就是当进程名字超过15个的时候，无法获取到完整的进程名。

再往下看可以看到在EPROCESS里面也有一个线程链表头，该链表于KPROCESS中的线程链表不是同一个

![image-20250801131303511](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801131303511.png)

由于微内核的关系，在内核里面有一个链表用于内核自己调用，而在执行体里面有另外一个链表给用户来使用

也就是这里的逻辑是

KPROCESS -> KTHREAD

EPROCESS->ETHREAD

可以看到，在ETHREAD中也有一个链表入口结构，那么在EPROCESS里面的链表头就是指向ETHEAD里面的0x268的位置。

![image-20250801131605297](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801131605297.png)



- SeAuditProcessCreationInfo
  - 可以获取到完整的进程路径

![image-20250801132828138](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801132828138.png)



取ImageFileName可以调用函数`PsGetProcessImageFileName`

![image-20250801132905850](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801132905850.png)

取完整的进程路径可以调用`SeLocateProcessImageName`函数，里面调用了`SePoPulateProcessImageName`来获取SeAuditProcessCreationInfo字段

![image-20250801133125036](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133125036.png)

![image-20250801133116887](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133116887.png)



- InheritedFromUniqueProcessId继承自进程ID
  - 即查看其父进程
    - 例如双击打开一个exe那么其父进程就是explorer.exe(资源管理器）

在64位下，进程结构里面会多一个wow64Process结构，通过这个结构可以判断该进程是x86的还是x64的，并且再判断时，还会判断PE头结构里面Machine的值，来增强可靠性。

![image-20250801133824634](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133824634.png)



![image-20250801133938842](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133938842.png)



> 作业：获取当前进程，将所有进程的名字打印出来

tips:当在VS中没有自动补全，可以重新扫描一下解决方案。

![image-20250801141039915](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141039915.png)

![image-20250801141136886](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141136886.png)

在VS中有两个宏`PsGetCurrentProcess`、`IoGetCurrentProcess` 都可以获取到当前的进程

通过调用`PsGetNextProcess`从而获取到下一个进程，该函数不导出，需要我们通过模块的查找找到该函数。该函数的逻辑是，如果传入的Process为空，则返回进程链表的第一个进程指针，可以通过判断其是否为第一个进程来循环遍历进程链表。

![image-20250801141510219](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141510219.png)

Nt系列的函数也可以拿到下一个进程，不过需要传入的是句柄，操作上稍微麻烦些。

![image-20250801141711442](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141711442.png)

来看一下`PsGetNextProcess`函数的实现

![image-20250801141859787](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141859787.png)

![image-20250801141908042](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141908042.png)

可以看到WInodws在内核自己调用的时候是获取到全部进程(ActiveProcess)的链表头，然后调用了一个宏来拿到下一个进程的进程对象。

这种宏的写法的含义是

ListEntry - &(EPROCESS)(0)->ActiveProcessLinks

这里的&(EPROCESS)(0)->ActiveProcessLinks，即相对于EPROCESS的首地址的偏移，前面我们看到在x86下是0xB8，那么由链表的入口减去其偏移，拿到的就是完整的进程的EPROCESS结构。

这种算法与我们前面所说的通过链表的入口地址减去偏移得到首地址的算法思想是一样的。

但是我们自己写的时候只能通过分析版本来获取到结构的偏移值，因为这个宏里面所使用的EPROCESS指针是没有导出的.

可以看到，虽然微软导出了PEPROCESS指针，但其所指向的KPROCESS没有被导出，因此我们对于偏移值只能手动计算。

![image-20250801142839811](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801142839811.png)







