# 进程线程

进程是内存分配的最小单元，线程是运行的最小单元。一个进程如果没有线程，那么它无法处理任何的事物，而一个线程没有进程，那么它无法使用任何的内存空间。它们相互依赖。

## 进程结构

在进程中有一块区域用于描述进程的信息，包括PID、打开的句柄数量、它的父进程和它所占用的内存空间大小等等。线程也有这样一个字段用于描述线程的信息。当然，这两个字段所占用的内存空间都是进程所被分配的内存空间里面。

> 宏内核与微内核的设计理念
>
> Windows 微内核
>
> - 内核比较重要的部分（线程调度、时钟调度、内存管理算法）等进行封装
>
> Linux 宏内核
>
> - 将所有的内核程序打包在一个地方
>   - 仅有EProcess
>     - 线程的调度、时钟的调度等等都
>
> 宏内核比微内核大，并且宏内核包含了微内核

Windows下对进程的描述结构：

- EProcess E 在内核态常用的能够去操作的字段  执行体结构

- KProcess  K代表微内核的核心  内核结构

> 例如：
>
> > KeGetCurrentThread 给微内核设计的，设计时是不打算给用户调用的
> >
> > PsGetCurrentThread 用于给用户调用的

Windows下对线程的描述结构：

- KThread

- EThread



我们任意查看一个进程，可以看到在其EPROCESS结构里面包含了一个KPROCESS，这个KPROCESS就是内核内部自己调用的时所使用的结构。

![image-20250801112021976](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112021976.png)

再去解析一下这个结构，可以看到，当我们拿到一个进程了以后加上18h就是它的CR3

### 解析KProcess

![image-20250801113510063](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801113510063.png)

`KPROCESS`结构中包含了线程的链表，通过线程的链表头`ThreadListHead`可以遍历该进程下的所有线程

通过解析线程的结构`_KTHREAD`，我们可以看到其1e0的位置有一个线程链表的入口地址，也就是说**我们在进程中获取到的线程链表的头地址指向的是线程链表的入口地址**，通过该地址减去1e0就是单个线程的`_KTHREAD`结构首地址

![image-20250801112920900](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112920900.png)

![image-20250801112911591](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112911591.png)

再返回去看，

- 0x34有一个ProcessLock锁，这是为了同步而设置的锁。
  - 当Windows在修改进程的信息的时候会加上进程锁结构然后再去进行修改。

- 0x38 **亲核性**

  - 是一种偏好性的原理，即优先分配。
    - 假设一个CPU有两个核，线程的该字段对1号核标记为1，代表对1号核有偏好，那么在分配的时候，只要该核空闲，CPU都会尽量的满足，从而优先分配该核给线程执行事物。

  - 可以看到**线程记录结构`KPROCESS`里面的0x154是线程的亲核性。而进程的亲核性是给线程用的，当一个线程被创建了以后，其会继承进程的亲核性。**

- 0x44 就绪链表
  - 即进程中处于就绪态的线程将其按照链表顺序来提交给CPU

- 0x4C 换出的链表
  - 内存、线程的页被交换到磁盘上，用链表将其记录。

- 0x50 
  - 记录线程通常在哪几个处理器上活动。

- 0x5c ~ 0x61
  - 用于给线程继承的值，对于进程来说没什么用
    - 例如0x5c的ProcessFlags 为8，则每个线程刚刚创建好的时候，其优先级都是8.

- 在0x78处有一个进程的链表，记录了所有的进程。但在微内核下，可以看到，已经是没有用的了其值都为零

![image-20250801115336634](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801115336634.png)

### 解析EProcess

`ExitTime`字段，基本上只有在进程死亡时才会去修改，由此我们可以利用其存放数据，或者是打上标记。如果我们注入过该进程，那么在该地址位置打上标记来表明已被注入。

![image-20250801115852593](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801115852593.png)

- ProcessLock 进程锁
  - 同样，再修改时大多会将其锁上然后再去修改
- ActiveProcessLinks 
  - 进程的链表，其地址为0xb8即其地址指向的是进程的b8的位置，那么我们想要获取完整的进程的`EPROCESS`结构，就需要将地址减去b8

- SessionProcessLinks

  - 用户的链表。Windows对于多用户进行了标记，例如用户A登录其session = 1，用户B登录其Session = 2。
  - 不同用户创建的进程，其存放的进程链表不同，即相同的Session所创建的进程其存放在同一个SessionProcessLinks上。
  - 而ActiveProcessLinks不对Session进行区分，不论是哪一个用户所创建的进程，在该链表上都可以查找到。

- DebugPort

  - 只要其值不为NULL，就代表该进程是调试的状态

- ObjectTable

  - 句柄表，索引号

  - 例如，我们之前调用OpenProcess函数的时候会返回一个句柄索引号，通过该索引号到句柄表里面查找才可以找到对应的对象地址。

    ![image-20250801121408299](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801121408299.png)

- Token
  - 权限
  - 别的用户创建的进程，我们想要给这个进程提权（让其可以被读写、执行等等）就修改Token
- AddressCreationLock
  - 地址锁
    - 通常调用AllocVirtual 申请内存时，先锁住，不让别的进程在操作你的申请内存功能了，即如果两个进程进行通信，A进程操作B进程，让B进程申请一块内存，并且不断的让B进程申请内存，那么第一次要求时地址锁打开，B进程申请内存，这过程中如果A进程再要求B进程申请内存，就会等待。
    - 如果某一进程将地址锁锁上，并且不关闭，那么别的进程到本进程来申请内存的时候就会卡死，不过一般不会将该地址锁一直锁住，因为，进程在运行的过程中会使用一些库函数，并不能保证别人写的库里面没有申请内存。

- imageFileName
  - 获取到进程名，并且该变量只有15个字节，也就是当进程名字超过15个的时候，无法获取到完整的进程名。

再往下看可以看到在EPROCESS里面也有一个线程链表头，该链表于KPROCESS中的线程链表不是同一个

![image-20250801131303511](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801131303511.png)

由于微内核的关系，在内核里面有一个链表用于内核自己调用，而在执行体里面有另外一个链表给用户来使用

也就是这里的逻辑是

KPROCESS -> KTHREAD

EPROCESS->ETHREAD

可以看到，在ETHREAD中也有一个链表入口结构，那么在EPROCESS里面的链表头就是指向ETHEAD里面的0x268的位置。

![image-20250801131605297](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801131605297.png)



- SeAuditProcessCreationInfo
  - 可以获取到完整的进程路径

![image-20250801132828138](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801132828138.png)



取ImageFileName可以调用函数`PsGetProcessImageFileName`

![image-20250801132905850](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801132905850.png)

取完整的进程路径可以调用`SeLocateProcessImageName`函数，里面调用了`SePoPulateProcessImageName`来获取SeAuditProcessCreationInfo字段

![image-20250801133125036](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133125036.png)

![image-20250801133116887](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133116887.png)



- InheritedFromUniqueProcessId继承自进程ID
  - 即查看其父进程
    - 例如双击打开一个exe那么其父进程就是explorer.exe(资源管理器）

在64位下，进程结构里面会多一个wow64Process结构，通过这个结构可以判断该进程是x86的还是x64的，并且再判断时，还会判断PE头结构里面Machine的值，来增强可靠性。

![image-20250801133824634](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133824634.png)



![image-20250801133938842](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133938842.png)



> 作业：获取当前进程，将所有进程的名字打印出来

tips:当在VS中没有自动补全，可以重新扫描一下解决方案。

![image-20250801141039915](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141039915.png)



## 进程遍历

### 进程链表遍历

![image-20250801141136886](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141136886.png)

在VS中有两个宏`PsGetCurrentProcess`、`IoGetCurrentProcess` 都可以获取到**当前的进程**

通过调用`PsGetNextProcess`从而获取到下一个进程，该函数不导出，需要我们通过模块的查找找到该函数。该函数的逻辑是，如果传入的Process为空，则返回进程链表的第一个进程指针，可以通过判断其是否为第一个进程来循环遍历进程链表。

![image-20250801141510219](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141510219.png)

Nt系列的函数也可以拿到下一个进程，不过需要传入的是句柄，操作上稍微麻烦些。

![image-20250801141711442](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141711442.png)

来看一下`PsGetNextProcess`函数的实现

![image-20250801141859787](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141859787.png)

![image-20250801141908042](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141908042.png)

可以看到WInodws在内核自己调用的时候是获取到全部进程(ActiveProcess)的链表头，然后调用了一个宏来拿到下一个进程的进程对象。

这种宏的写法的含义是

ListEntry - &(EPROCESS)(0)->ActiveProcessLinks

这里的&(EPROCESS)(0)->ActiveProcessLinks，即相对于EPROCESS的首地址的偏移，前面我们看到在x86下是0xB8，那么由链表的入口减去其偏移，拿到的就是完整的进程的EPROCESS结构。

这种算法与我们前面所说的通过链表的入口地址减去偏移得到首地址的算法思想是一样的。

但是我们自己写的时候只能通过分析版本来获取到结构的偏移值，因为这个宏里面所使用的EPROCESS指针是没有导出的.

可以看到，虽然微软导出了PEPROCESS指针，但其所指向的KPROCESS没有被导出，因此我们对于偏移值只能手动计算。

![image-20250801142839811](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801142839811.png)

还有一个逻辑是通过调用ZwQuerySysytemInfomation函数，查找ntdll里面的一个宏类似systemProcessInfo的宏，拿到这个宏以后可以找到该链表，然后遍历进程。

![image-20250802095837170](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802095837170.png)

### 暴力枚举

可以观察一下进程的PID，会发现进程的PID都是4的倍数。并且，当我们遍历到进程的PID以后，可以通过句柄表去拿到进程对象。

PID的最大值通常不会超过十万。因此，我们需要枚举的量不是很大，或者说通过暴力枚举，其算法复杂度不会特别的高。

![image-20250802094050391](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802094050391.png)

`PsLookupProcessByProcessId`通过进程PID获取进程

`PsLookupThreadByTHreadId`通过线程TID获取线程



System进程，它的进程对象是导出的。通过宏定义，我们可以拿到进程的对象。

因此从逻辑上对于0 号和4号 我们不需要去遍历，而8号PID代表着第一个线程，我们也不需要去遍历它。简单来说我们可以直接从12号开始遍历。

![image-20250802100418165](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802100418165.png)

注意，当一个进程被关掉以后，它的进程对象不是立马被回收的，因此可能在进程链表上还能遍历得到，但是其状态会标记为0（默认情况下大于零），或者看其PEB是否为0。

在进程的EPROCESS结构里面有一个ExitStatus字段，当该状态被标记为0，代表进程已被释放。

![image-20250802102510103](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802102510103.png)

可以看到一个正在运行的进程，其状态码的大小：

![image-20250802103234495](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103234495.png)

因此，当我们遍历到一个进程以后，需要去判断它是否是被关闭了。当我们通过`PsLookupProcessByProcessId`打开一个进程的时候，它会返回成功或者失败，而拿到进程对象以后可以对它的状态进行判断，可以看到259状态是挂起的一个状态。

![image-20250802103344269](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103344269.png)

通过PID查询到进程以后，其引用计数会加一，因此，对于不存在了的进程，我们遍历到了以后需要用引用计数减一。其中`PspClidTable`是一个全局的句柄表，通过句柄可查找到进程对象。

![image-20250802103732661](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103732661.png)

对于进程对象的引用计数，即有别的进程引用它，则引用计数加一，释放时，引用计数减一。

对象的引用计数不为零或者一时，该对象会一直存在直到没有人引用了以后，才会被释放。

我们可以查看一下该函数下调用的`ObReferenceObjectSafe`函数的代码，可以看到传入里面的v4就是其进程对象。函数在开头对进程对象的地址减去18h，前文提到过，这个偏移是进程对象的头结构，解析头结构可以看到里面存放着引用计数以及句柄引用计数。

![image-20250802103859503](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103859503.png)

在然后它调用了`_InterlockedcompareExchange`函数，查看其汇编代码

![image-20250802104050144](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802104050144.png)

可以看到有一个cmpxchg的一个汇编指令，该指令的作用就是进程内存的交换，从上下文可以看到，v2是进程对象的头结构，v3里面保存着v2的副本，将v3加一即将引用计数加一然后与v2(原本的头结构)进行内容的交换。

简单来说就是引用计数加一操作。

![image-20250802104403345](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802104403345.png)



调用`ObDereferenceObject`函数使得引用计数减一

我们也来看一下它的汇编代码

![image-20250802105822874](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802105822874.png)

可以看到其调用的函数里面有一个`_InterlockedDecrement`，其执行dec指令，进行自减操作。

![image-20250802105852059](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802105852059.png)

![image-20250802105937770](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802105937770.png)

代码编写：

![image-20250802114219723](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114219723.png)



![image-20250802114333803](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114333803.png)



![image-20250802114457573](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114457573.png)

打上代码标签，这样我们可以不用重复写某一段代码，而是用goto语句到该标签执行，然后返回

![image-20250802114523839](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114523839.png)

注意，在获取进程的完整路径名的时候，它在查询到路径以后，将路径放入了一块它自己申请的内存，在内核态下，任何关闭内存的申请与释放都必须匹配，因此，在拿到进程完整路径名以后，我们需要将这块申请的内存进行释放。

![image-20250802114649440](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114649440.png)

可以看到，它在申请内存的时候传入的参数是'fIes'，我们同样在释放的时候，释放相同的大小。

![image-20250802114856515](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114856515.png)

![image-20250802115046484](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115046484.png)

执行进行验证，发现Windbg报了一个错，由于system是一个虚构的进程，不存在该进程文件，因此其路径为NULL，而在**字符串匹配的时候需要申请内存，并且通过指针进行访问，最终导致蓝屏。**

因此，我们要么跳过该进程，从8或者12开始枚举，或者判断拿到的路径是否为空。



![image-20250802115110079](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115110079.png)

![image-20250802115351848](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115351848.png)



> 获取完整路径名来进行比较而不是通过ImageName短名字来进行比较的原因
>
> 我们查询一个名字很长（超过15字节）的进程，并且该进程真实存在
>
> ![image-20250802115506697](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115506697.png)
>
> ![image-20250802115542379](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115542379.png)
>
> ![image-20250802115613455](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115613455.png)
>
> 可以看到，其ImageFileName不全，如果通过短名字来进行查询的话，那么很有可能找不到进程名。

使用完以后记得释放，让引用计数减一。

![image-20250802115843838](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115843838.png)



Windows导出了一个获取进程ID的函数,在函数里面,我们通过定位特征的方法,**可以获取到完整的PID表,从而可以通过遍历ID表找到进程.**

![image-20250802123651954](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123651954.png)



## 进程保护

在进程的EPROCESS结构里面，有一个位段，即当看到多个地址一样的结构的时候，说明这一块区域的单位为bit位。

我们看到有一个`ProtectedProcess`位，修改该位，打开保护进程。

注意从Flags2开始数有12bit，对应为800，将其位置为1

![image-20250802120114003](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120114003.png)



因此我们在编写的时候获取到内存，然后写入0x800即可

![image-20250802120408398](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120408398.png)

该位置为1以后，保护的是进程的句柄不被打开，意味着无法被别的三环驱动调用

可以看到，OD、CE等扫描内存的工具都无法打开进程

![image-20250802120528218](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120528218.png)



![image-20250802120600914](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120600914.png)



到了Win10 Win11

对句柄的保护进行了修改

不再是打开开关，而是对保护的等级进行划分

保护等级高的可以打开保护等级低的进程

在Win10、Win11下有这个结构，并且导出，其参数Signer代表保护等级，最高等级可能是7级

![image-20250802120704231](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120704231.png)

在Win10 Win11下有个导出的函数，我们通过特征码的定位，可以拿到一个这个结构，并对结构进行修改即可

![image-20250802121035517](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802121035517.png)

### 进程隐藏

在Win7下，通过断开进程链表，可以实现隐藏进程

但是在Win10 Win11下不能用该方法，会导致蓝屏。

还有一种不完美的方式是将进程的ID置为0

![image-20250802123233025](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123233025.png)

![image-20250802123245877](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123245877.png)



在Win7下就无法找到该进程，但Win7下的进程管理器会卡一个bug

![image-20250802123326326](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123326326.png)

我们在Win10下测试，同样，通过偏移取到ID后置为0

![image-20250802123349970](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123349970.png)

注意到了x64，其地址占八字节，因此写入的时候需要写入八字节，用eq

![image-20250802123435380](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123435380.png)



可以看到，普通的扫描已经扫不到我们的进程了，但是通过扫描窗口仍然能找到我们的进程.

![image-20250802123520194](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123520194.png)

窗口里面保存一个专门设计给窗口用的win32Process结构，这个win32Process结构里面保存了EPROCESS了。因此，通过窗口就可以直接拿到进程指针

![image-20250802123001720](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123001720.png)

将窗口HOOK，可以对抗窗口的扫描。窗口链表的断链会卡死窗口。

三环与零环有一个存放窗口的共享内存，由此来解决三环获取窗口需要进入到零环去查找导致效率过低的问题。

因此三环的窗口遍历不进内核态，也能进行遍历。

由此，我们在内核将窗口相关的函数HOOK了以后，也无法阻挡三环的进程遍历窗口



> Win10 Win11的进程保护,是否基于系统回调?

对象类型回调

打开句柄时会调用OpenProcesdure 等回调函数，由于打开句柄时会判断是否有该权限

因此会调用SecurityProceDuce函数，进行安全检查。

我们打开对象的类型不是驱动对象与设备对象，没有名字，因此没有解析的回调

![image-20250802131130117](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131130117.png)

在OpenProcedure处打上断点，再用kv查看调用了这些函数，我们查看其汇编

`PspProcessOpen`

![image-20250802131441066](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131441066.png)

![image-20250802131550322](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131550322.png)

可以看到a5与0xFE7FE进行了判断，这里的a5是flag位

![image-20250802131609704](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131609704.png)

我们在查看一下`ObpIncremontHandlecountEx`函数，发现里面对访问的权限进行了检查，那么在上面的`PspProcessOpen`函数里面也是对权限进行检查。这里的权限就是我们在调用的时候，所赋予的权限，例如读写权限、所有权限等。

![image-20250802131729700](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131729700.png)



## 线程结构



### KThread

![image-20250803115407738](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803115407738.png)

- `Head`可等待头
- `QuantumTarget` 
  - 时间碎片的单位，通常为6（3的倍数）
  - 线程每执行一个指令周期，该值就会减三
  - Win7后变为到点时间戳
    - 即时间戳一到，表明线程的运行时间到，更换线程

- `InitialStack`
  - 栈底
- `StackLimit`
  - 栈顶

- `KernelStack`
  - 保存当前的ESP
  - 当发生线程切换时，需要保存原线程的环境，将寄存器等值存放在原线程的堆栈里面，然后将ESP值存放在KernelStack里边，在切换会当前线程以后，从KernelStack字段去拿取ESP恢复环境
  - 线程切换经常使用
- `ThreadLock`
  - 系统修改线程信息的时候，会加锁，修改完成以后释放
- Running
  - 表示线程是否在运行
- Alerted[2]
  - 可警惕，与APC相关，设置是否允许被唤醒的状态
  - APC时查看该字段
  - [0]Kernel的状态
    - True，表示当前线程在等待状态下允许被唤醒
  - [1]user的状态
- Alertable
  - =1线程可以唤醒
  - 强制唤醒时查看该字段
- ApcInterruptRequest
  - =1支持Apc中断
- systemThread
  - =1该线程为系统线程
    - 纯内核线程 只包含ETHREAD KThread结构
  - =0用户态线程
    - 除ETHREAD KThread外，还有TEB结构
- ApcState
  - ApcListHead[2]
  - Process
  - KernelApcInProgress
  - KernelApcPending
    - ApcListHead[0]  链表是否有节点
    - = 1 表示三环下的Apc链表存在
  - UserApcPending
    - ApcListHead[1] 链表是否有节点
    -  = 1 表示三环下的Apc链表存在

> 创建线程的进程，叫亲生进程
>
> 将线程挂靠到别的进程，被挂靠进程叫做养父进程或者叫养分进程
>
> 线程临时性的属于别的进程，在运行时由别的进程提供内存空间，这一步叫挂靠，最终会回到亲生进程里面去。

其中`Process`注明了线程的归属，即当前提供给线程运行所需内存的进程是哪一个。例如，当前没有挂靠，那么就是亲生进程。反之，如果挂靠到另外一个进程，那么就是养父进程。

挂靠只能在内核态下实现。在**内核态下大部分内存是共享的**，线程从三环切换到零环以后，三环下的堆栈会切换为零环的堆栈，那么当线程挂靠到别的进程的时候，由于内存是共享的，就不需要再创建一个堆栈来对线程的环境进行保存。 

挂靠以后，如果是纯内核的线程，是可以不用回去的，但如果是从三环上来的线程，那么最终需要回到三环去执行。这是由于被挂靠的进程在零环，没有三环的环境，因此，无法提供三环的堆栈，如果不返回，则会蓝屏。

`ApcListHead`即指向一个KAPC的一个结构。该字段是APC链表数组，表明在三环下和在零环下各有一个APC链表

![image-20250803101441195](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803101441195.png)

注意，该链表指向ApcListEntry字段，即从APC链表拿到其KAPC地址以后，要减去0x0c才是完整的KAPC结构地址



- Priority
  - 线程的优先级
  - 0-31 数字越大，优先级越改，普通线程的优先级是8
  - Windows基于抢占式资源管理算法，即优先级越高，其执行的优先级、所分配的资源就越多
  - 在切换线程的时候，Windows会动态的修改线程的优先级，之前给某一线程分配了一个较低的优先级，那么在切换线程的时候就会给该线程的优先级分配高一些，以防止产生饥饿现象。



- NextProcess

  - 线程下一次切换的核

    - 例如，线程当前运行在1号核，该值为4（0100），代表三号核。那么下一次运行的时候就会被分配到三号核。

- DeferredProcessor 线程延时就绪
  - 线程在运行时由于优先级过低，NextProcess位中的核被优先分配给了别的线程，那么本线程就会变为为延时就绪状态，这里面也会设置一个值例如2（0010），代表二号核，在本线程运行时就会按照DeferredProcessor 字段设置的核来进行分配



- ContextSwitch 当前线程切换了多少次
  - 一个线程如果经常的运行，就肯定会经常地切换。
  - 通常检测线程的切换次数是比较多的。即**如果一个线程频繁的切换，那么它很有可能是检测线程**。通过查看该字段，来进行一个大概范围的判断，可以初步窥探到哪个线程是检测线程。然后再去看模块。



- state

  - Initialized 初始化
    - 仅有一次
  - Ready 准备执行
  - Standby 备用状态
  - Terminated 死亡状态
    - 只有一次
  - Waiting 等待状态
  - Transition 换入换出
    - 由于某些线程执行效率比较低，此时，会将其堆栈放入到虚拟磁盘上，但与线程是否执行没有任何的关系。
    - 假设一个线程长时间的等待某一资源的释放，由于线程处于等待状态，其堆栈空间仍然存在，因此，为了节省空间，会先将线程的所占内存的资源换到磁盘上面去，当线程被唤醒等待执行时才换回。
  - DeferredReady 延时就绪准备
    - 线程的状态大多是从就绪准备到准备执行这样一种状态序列
    - waiting状态可以直接到Ready状态，但有时也可以从waiting状态到就绪准备状态
    - 就绪准备的作用可以看成是Ready状态的后备军，即当一个线程在Ready状态准备执行的时候，由于被更高等级的线程给抢占了或者是其所需要的资源被占用了，会变成就绪准备状态而不是变为等待状态，给线程的二次就绪提速。

  - GateWait 间隔等待
    - 不常出现，可能被废弃

  由于Windows的不同版本，其线程的状态设定都不同，因此不用特别的记忆

![image-20250803115231677](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803115231677.png)

- WaitBlockList
  - 等待块
- WaitListEntry
  - 等待链表
  - 线程在等待状态下，插入到等待链表
  - 进程的等待链表

线程切换时有32个全局的就绪链表，这全局的就绪链表里面包含系统中的所有的线程



- Timer 定时器
  - 线程内核下的定时器

![image-20250803113937418](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803113937418.png)

   -	GUiTHread
     -	判断是否为GUI线程
     -	调用user32里面的模块时就是一个UI线程

   -	waitBlock
     -	默认情况下，WaitBlockList里面的节点是指向WaitBlock字段的

- ProviousMode 
  - 先前模式
- UserAffinity
  - 用户亲核性
  - 切换线程在内核态下用
- `Process`永远指向线程的创建者，与state下的Process不同，它永远指向提供内存的地方。

`IoGetCurrentProcess`获取当前线程的养分进程

![image-20250803115321749](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803115321749.png)

`IoThreadToProcess`获取当前线程的亲生进程

![image-20250803115259093](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803115259093.png)



### EThread

![image-20250803115420068](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803115420068.png)

- StartAddress
  - 线程的起始地址，用于记录函数在创建线程时所传递的线程地址
    - 纯内核线程，该地址就是函数的地址
    - 三环线程，该地址是函数给的封装结构的地址
- Win32StartAddress
  - R3线程的起始地址



对于无模块函数，大多检测程序会检测线程的入口地址是否是一个无模块函数，如果是就报错或者判断为病毒。

我们来修改一下线程入口地址来进行测试

![image-20250803120401239](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803120401239.png)

可以看到，PCHunter中的线程入口指向的是R3的线程入口地址

![image-20250803120421262](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803120421262.png)

我们修改R3的线程入口地址

![image-20250803120545105](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803120545105.png)

检测程序爆红

![image-20250803120616430](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803120616430.png)

#### 绕过线程入口检测

那么如何绕过该检测？

可以在创建线程的时候，给的函数地址是一个别的有模块的一个函数地址，然后HOOK住该函数，在里面添加一个跳转语句跳转到我们的无模块的函数执行。

跳转以后还原我们HOOK的函数，让检测程序正常检测该函数的编码，而我们的无模块函数正常执行。

![image-20250803121440569](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803121440569.png)

![image-20250803122408526](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803122408526.png)

模块变成ntdll，成功隐藏线程入口

![image-20250803122428105](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803122428105.png)

- HideFromDebugger
  - = 1 线程触发调试事件不会被断下
    - 如果是该线程是逃逸线程，执行的断点位置，调试器奔溃
    - 如果是一般线程，当断下时，线程不会被挂起



`ZwSetInformationThread`函数，可以设置该位`ThreadHiderFromDebugger`。

![image-20250803122514753](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803122514753.png)

![image-20250803122457972](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803122457972.png)

设置完该位了以后，注意是不可逆的。也就是说如果将其打开了以后，在内核或者在三环下是没有API去将它还原或者修改回去的。我们只能手动的去修改。

可以看一下处理时的情况，可以看到它调用的函数是直接将该位置为某个值，而不是根据我们传入的参数去修改debugger位的值，因此说它是不可逆的。

![image-20250803122926906](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250803122926906.png)

作业：

1.修改调试位，让进程在调试器里面运行一下，看看效果

2.通过代码方式创建并隐藏线程入口











