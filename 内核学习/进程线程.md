# 进程线程

进程是内存分配的最小单元，线程是运行的最小单元。一个进程如果没有线程，那么它无法处理任何的事物，而一个线程没有进程，那么它无法使用任何的内存空间。它们相互依赖。

## 进程结构

在进程中有一块区域用于描述进程的信息，包括PID、打开的句柄数量、它的父进程和它所占用的内存空间大小等等。线程也有这样一个字段用于描述线程的信息。当然，这两个字段所占用的内存空间都是进程所被分配的内存空间里面。

> 宏内核与微内核的设计理念
>
> Windows 微内核
>
> - 内核比较重要的部分（线程调度、时钟调度、内存管理算法）等进行封装
>
> Linux 宏内核
>
> - 将所有的内核程序打包在一个地方
>   - 仅有EProcess
>     - 线程的调度、时钟的调度等等都
>
> 宏内核比微内核大，并且宏内核包含了微内核

Windows下对进程的描述结构：

- EProcess E 在内核态常用的能够去操作的字段  执行体结构

- KProcess  K代表微内核的核心  内核结构

> 例如：
>
> > KeGetCurrentThread 给微内核设计的，设计时是不打算给用户调用的
> >
> > PsGetCurrentThread 用于给用户调用的

Windows下对线程的描述结构：

- KThread

- EThread



我们任意查看一个进程，可以看到在其EPROCESS结构里面包含了一个KPROCESS，这个KPROCESS就是内核内部自己调用的时所使用的结构。

![image-20250801112021976](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112021976.png)

再去解析一下这个结构，可以看到，当我们拿到一个进程了以后加上18h就是它的CR3

### 解析KProcess

![image-20250801113510063](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801113510063.png)

`KPROCESS`结构中包含了线程的链表，通过线程的链表头`ThreadListHead`可以遍历该进程下的所有线程

通过解析线程的结构`_KTHREAD`，我们可以看到其1e0的位置有一个线程链表的入口地址，也就是说**我们在进程中获取到的线程链表的头地址指向的是线程链表的入口地址**，通过该地址减去1e0就是单个线程的`_KTHREAD`结构首地址

![image-20250801112920900](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112920900.png)

![image-20250801112911591](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801112911591.png)

再返回去看，

- 0x34有一个ProcessLock锁，这是为了同步而设置的锁。
  - 当Windows在修改进程的信息的时候会加上进程锁结构然后再去进行修改。

- 0x38 **亲核性**

  - 是一种偏好性的原理，即优先分配。
    - 假设一个CPU有两个核，线程的该字段对1号核标记为1，代表对1号核有偏好，那么在分配的时候，只要该核空闲，CPU都会尽量的满足，从而优先分配该核给线程执行事物。

  - 可以看到**线程记录结构`KPROCESS`里面的0x154是线程的亲核性。而进程的亲核性是给线程用的，当一个线程被创建了以后，其会继承进程的亲核性。**

- 0x44 就绪链表
  - 即进程中处于就绪态的线程将其按照链表顺序来提交给CPU

- 0x4C 换出的链表
  - 内存、线程的页被交换到磁盘上，用链表将其记录。

- 0x50 
  - 记录线程通常在哪几个处理器上活动。

- 0x5c ~ 0x61
  - 用于给线程继承的值，对于进程来说没什么用
    - 例如0x5c的ProcessFlags 为8，则每个线程刚刚创建好的时候，其优先级都是8.

- 在0x78处有一个进程的链表，记录了所有的进程。但在微内核下，可以看到，已经是没有用的了其值都为零

![image-20250801115336634](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801115336634.png)

### 解析EProcess

`ExitTime`字段，基本上只有在进程死亡时才会去修改，由此我们可以利用其存放数据，或者是打上标记。如果我们注入过该进程，那么在该地址位置打上标记来表明已被注入。

![image-20250801115852593](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801115852593.png)

- ProcessLock 进程锁
  - 同样，再修改时大多会将其锁上然后再去修改
- ActiveProcessLinks 
  - 进程的链表，其地址为0xb8即其地址指向的是进程的b8的位置，那么我们想要获取完整的进程的`EPROCESS`结构，就需要将地址减去b8

- SessionProcessLinks

  - 用户的链表。Windows对于多用户进行了标记，例如用户A登录其session = 1，用户B登录其Session = 2。
  - 不同用户创建的进程，其存放的进程链表不同，即相同的Session所创建的进程其存放在同一个SessionProcessLinks上。
  - 而ActiveProcessLinks不对Session进行区分，不论是哪一个用户所创建的进程，在该链表上都可以查找到。

- DebugPort

  - 只要其值不为NULL，就代表该进程是调试的状态

- ObjectTable

  - 句柄表，索引号

  - 例如，我们之前调用OpenProcess函数的时候会返回一个句柄索引号，通过该索引号到句柄表里面查找才可以找到对应的对象地址。

    ![image-20250801121408299](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801121408299.png)

- Token
  - 权限
  - 别的用户创建的进程，我们想要给这个进程提权（让其可以被读写、执行等等）就修改Token
- AddressCreationLock
  - 地址锁
    - 通常调用AllocVirtual 申请内存时，先锁住，不让别的进程在操作你的申请内存功能了，即如果两个进程进行通信，A进程操作B进程，让B进程申请一块内存，并且不断的让B进程申请内存，那么第一次要求时地址锁打开，B进程申请内存，这过程中如果A进程再要求B进程申请内存，就会等待。
    - 如果某一进程将地址锁锁上，并且不关闭，那么别的进程到本进程来申请内存的时候就会卡死，不过一般不会将该地址锁一直锁住，因为，进程在运行的过程中会使用一些库函数，并不能保证别人写的库里面没有申请内存。

- imageFileName
  - 获取到进程名，并且该变量只有15个字节，也就是当进程名字超过15个的时候，无法获取到完整的进程名。

再往下看可以看到在EPROCESS里面也有一个线程链表头，该链表于KPROCESS中的线程链表不是同一个

![image-20250801131303511](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801131303511.png)

由于微内核的关系，在内核里面有一个链表用于内核自己调用，而在执行体里面有另外一个链表给用户来使用

也就是这里的逻辑是

KPROCESS -> KTHREAD

EPROCESS->ETHREAD

可以看到，在ETHREAD中也有一个链表入口结构，那么在EPROCESS里面的链表头就是指向ETHEAD里面的0x268的位置。

![image-20250801131605297](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801131605297.png)



- SeAuditProcessCreationInfo
  - 可以获取到完整的进程路径

![image-20250801132828138](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801132828138.png)



取ImageFileName可以调用函数`PsGetProcessImageFileName`

![image-20250801132905850](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801132905850.png)

取完整的进程路径可以调用`SeLocateProcessImageName`函数，里面调用了`SePoPulateProcessImageName`来获取SeAuditProcessCreationInfo字段

![image-20250801133125036](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133125036.png)

![image-20250801133116887](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133116887.png)



- InheritedFromUniqueProcessId继承自进程ID
  - 即查看其父进程
    - 例如双击打开一个exe那么其父进程就是explorer.exe(资源管理器）

在64位下，进程结构里面会多一个wow64Process结构，通过这个结构可以判断该进程是x86的还是x64的，并且再判断时，还会判断PE头结构里面Machine的值，来增强可靠性。

![image-20250801133824634](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133824634.png)



![image-20250801133938842](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801133938842.png)



> 作业：获取当前进程，将所有进程的名字打印出来

tips:当在VS中没有自动补全，可以重新扫描一下解决方案。

![image-20250801141039915](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141039915.png)



## 进程遍历

### 进程链表遍历

![image-20250801141136886](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141136886.png)

在VS中有两个宏`PsGetCurrentProcess`、`IoGetCurrentProcess` 都可以获取到**当前的进程**

通过调用`PsGetNextProcess`从而获取到下一个进程，该函数不导出，需要我们通过模块的查找找到该函数。该函数的逻辑是，如果传入的Process为空，则返回进程链表的第一个进程指针，可以通过判断其是否为第一个进程来循环遍历进程链表。

![image-20250801141510219](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141510219.png)

Nt系列的函数也可以拿到下一个进程，不过需要传入的是句柄，操作上稍微麻烦些。

![image-20250801141711442](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141711442.png)

来看一下`PsGetNextProcess`函数的实现

![image-20250801141859787](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141859787.png)

![image-20250801141908042](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801141908042.png)

可以看到WInodws在内核自己调用的时候是获取到全部进程(ActiveProcess)的链表头，然后调用了一个宏来拿到下一个进程的进程对象。

这种宏的写法的含义是

ListEntry - &(EPROCESS)(0)->ActiveProcessLinks

这里的&(EPROCESS)(0)->ActiveProcessLinks，即相对于EPROCESS的首地址的偏移，前面我们看到在x86下是0xB8，那么由链表的入口减去其偏移，拿到的就是完整的进程的EPROCESS结构。

这种算法与我们前面所说的通过链表的入口地址减去偏移得到首地址的算法思想是一样的。

但是我们自己写的时候只能通过分析版本来获取到结构的偏移值，因为这个宏里面所使用的EPROCESS指针是没有导出的.

可以看到，虽然微软导出了PEPROCESS指针，但其所指向的KPROCESS没有被导出，因此我们对于偏移值只能手动计算。

![image-20250801142839811](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250801142839811.png)

还有一个逻辑是通过调用ZwQuerySysytemInfomation函数，查找ntdll里面的一个宏类似systemProcessInfo的宏，拿到这个宏以后可以找到该链表，然后遍历进程。

![image-20250802095837170](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802095837170.png)

### 暴力枚举

可以观察一下进程的PID，会发现进程的PID都是4的倍数。并且，当我们遍历到进程的PID以后，可以通过句柄表去拿到进程对象。

PID的最大值通常不会超过十万。因此，我们需要枚举的量不是很大，或者说通过暴力枚举，其算法复杂度不会特别的高。

![image-20250802094050391](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802094050391.png)

`PsLookupProcessByProcessId`通过进程PID获取进程

`PsLookupThreadByTHreadId`通过线程TID获取线程



System进程，它的进程对象是导出的。通过宏定义，我们可以拿到进程的对象。

因此从逻辑上对于0 号和4号 我们不需要去遍历，而8号PID代表着第一个线程，我们也不需要去遍历它。简单来说我们可以直接从12号开始遍历。

![image-20250802100418165](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802100418165.png)

注意，当一个进程被关掉以后，它的进程对象不是立马被回收的，因此可能在进程链表上还能遍历得到，但是其状态会标记为0（默认情况下大于零），或者看其PEB是否为0。

在进程的EPROCESS结构里面有一个ExitStatus字段，当该状态被标记为0，代表进程已被释放。

![image-20250802102510103](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802102510103.png)

可以看到一个正在运行的进程，其状态码的大小：

![image-20250802103234495](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103234495.png)

因此，当我们遍历到一个进程以后，需要去判断它是否是被关闭了。当我们通过`PsLookupProcessByProcessId`打开一个进程的时候，它会返回成功或者失败，而拿到进程对象以后可以对它的状态进行判断，可以看到259状态是挂起的一个状态。

![image-20250802103344269](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103344269.png)

通过PID查询到进程以后，其引用计数会加一，因此，对于不存在了的进程，我们遍历到了以后需要用引用计数减一。其中`PspClidTable`是一个全局的句柄表，通过句柄可查找到进程对象。

![image-20250802103732661](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103732661.png)

对于进程对象的引用计数，即有别的进程引用它，则引用计数加一，释放时，引用计数减一。

对象的引用计数不为零或者一时，该对象会一直存在直到没有人引用了以后，才会被释放。

我们可以查看一下该函数下调用的`ObReferenceObjectSafe`函数的代码，可以看到传入里面的v4就是其进程对象。函数在开头对进程对象的地址减去18h，前文提到过，这个偏移是进程对象的头结构，解析头结构可以看到里面存放着引用计数以及句柄引用计数。

![image-20250802103859503](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802103859503.png)

在然后它调用了`_InterlockedcompareExchange`函数，查看其汇编代码

![image-20250802104050144](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802104050144.png)

可以看到有一个cmpxchg的一个汇编指令，该指令的作用就是进程内存的交换，从上下文可以看到，v2是进程对象的头结构，v3里面保存着v2的副本，将v3加一即将引用计数加一然后与v2(原本的头结构)进行内容的交换。

简单来说就是引用计数加一操作。

![image-20250802104403345](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802104403345.png)



调用`ObDereferenceObject`函数使得引用计数减一

我们也来看一下它的汇编代码

![image-20250802105822874](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802105822874.png)

可以看到其调用的函数里面有一个`_InterlockedDecrement`，其执行dec指令，进行自减操作。

![image-20250802105852059](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802105852059.png)

![image-20250802105937770](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802105937770.png)

代码编写：

![image-20250802114219723](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114219723.png)



![image-20250802114333803](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114333803.png)



![image-20250802114457573](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114457573.png)

打上代码标签，这样我们可以不用重复写某一段代码，而是用goto语句到该标签执行，然后返回

![image-20250802114523839](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114523839.png)

注意，在获取进程的完整路径名的时候，它在查询到路径以后，将路径放入了一块它自己申请的内存，在内核态下，任何关闭内存的申请与释放都必须匹配，因此，在拿到进程完整路径名以后，我们需要将这块申请的内存进行释放。

![image-20250802114649440](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114649440.png)

可以看到，它在申请内存的时候传入的参数是'fIes'，我们同样在释放的时候，释放相同的大小。

![image-20250802114856515](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802114856515.png)

![image-20250802115046484](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115046484.png)

执行进行验证，发现Windbg报了一个错，由于system是一个虚构的进程，不存在该进程文件，因此其路径为NULL，而在**字符串匹配的时候需要申请内存，并且通过指针进行访问，最终导致蓝屏。**

因此，我们要么跳过该进程，从8或者12开始枚举，或者判断拿到的路径是否为空。



![image-20250802115110079](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115110079.png)

![image-20250802115351848](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115351848.png)



> 获取完整路径名来进行比较而不是通过ImageName短名字来进行比较的原因
>
> 我们查询一个名字很长（超过15字节）的进程，并且该进程真实存在
>
> ![image-20250802115506697](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115506697.png)
>
> ![image-20250802115542379](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115542379.png)
>
> ![image-20250802115613455](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115613455.png)
>
> 可以看到，其ImageFileName不全，如果通过短名字来进行查询的话，那么很有可能找不到进程名。

使用完以后记得释放，让引用计数减一。

![image-20250802115843838](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802115843838.png)



Windows导出了一个获取进程ID的函数,在函数里面,我们通过定位特征的方法,**可以获取到完整的PID表,从而可以通过遍历ID表找到进程.**

![image-20250802123651954](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123651954.png)



## 进程保护

在进程的EPROCESS结构里面，有一个位段，即当看到多个地址一样的结构的时候，说明这一块区域的单位为bit位。

我们看到有一个`ProtectedProcess`位，修改该位，打开保护进程。

注意从Flags2开始数有12bit，对应为800，将其位置为1

![image-20250802120114003](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120114003.png)



因此我们在编写的时候获取到内存，然后写入0x800即可

![image-20250802120408398](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120408398.png)

该位置为1以后，保护的是进程的句柄不被打开，意味着无法被别的三环驱动调用

可以看到，OD、CE等扫描内存的工具都无法打开进程

![image-20250802120528218](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120528218.png)



![image-20250802120600914](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120600914.png)



到了Win10 Win11

对句柄的保护进行了修改

不再是打开开关，而是对保护的等级进行划分

保护等级高的可以打开保护等级低的进程

在Win10、Win11下有这个结构，并且导出，其参数Signer代表保护等级，最高等级可能是7级

![image-20250802120704231](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802120704231.png)

在Win10 Win11下有个导出的函数，我们通过特征码的定位，可以拿到一个这个结构，并对结构进行修改即可

![image-20250802121035517](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802121035517.png)

### 进程隐藏

在Win7下，通过断开进程链表，可以实现隐藏进程

但是在Win10 Win11下不能用该方法，会导致蓝屏。

还有一种不完美的方式是将进程的ID置为0

![image-20250802123233025](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123233025.png)

![image-20250802123245877](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123245877.png)



在Win7下就无法找到该进程，但Win7下的进程管理器会卡一个bug

![image-20250802123326326](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123326326.png)

我们在Win10下测试，同样，通过偏移取到ID后置为0

![image-20250802123349970](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123349970.png)

注意到了x64，其地址占八字节，因此写入的时候需要写入八字节，用eq

![image-20250802123435380](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123435380.png)



可以看到，普通的扫描已经扫不到我们的进程了，但是通过扫描窗口仍然能找到我们的进程.

![image-20250802123520194](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123520194.png)

窗口里面保存一个专门设计给窗口用的win32Process结构，这个win32Process结构里面保存了EPROCESS了。因此，通过窗口就可以直接拿到进程指针

![image-20250802123001720](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802123001720.png)

将窗口HOOK，可以对抗窗口的扫描。窗口链表的断链会卡死窗口。

三环与零环有一个存放窗口的共享内存，由此来解决三环获取窗口需要进入到零环去查找导致效率过低的问题。

因此三环的窗口遍历不进内核态，也能进行遍历。

由此，我们在内核将窗口相关的函数HOOK了以后，也无法阻挡三环的进程遍历窗口



> Win10 Win11的进程保护,是否基于系统回调?

对象类型回调

打开句柄时会调用OpenProcesdure 等回调函数，由于打开句柄时会判断是否有该权限

因此会调用SecurityProceDuce函数，进行安全检查。

由于对象的类型不是驱动对象与设备对象，没有名字，因此没有解析的回调

![image-20250802131130117](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131130117.png)

在OpenProcedure处打上断点，再用kv查看调用了这些函数，我们查看其汇编

`PspProcessOpen`

![image-20250802131441066](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131441066.png)

![image-20250802131550322](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131550322.png)

可以看到a5与0xFE7FE进行了判断，这里的a5是flag位

![image-20250802131609704](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131609704.png)

我们在查看一下`ObpIncremontHandlecountEx`函数，发现里面对访问的权限进行了检查，那么在上面的`PspProcessOpen`函数里面也是对权限进行检查。这里的权限就是我们在调用的时候，所赋予的权限，例如读写权限、所有权限等

![image-20250802131729700](./%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.assets/image-20250802131729700.png)
